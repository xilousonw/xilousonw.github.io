<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>西楼</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-07-14T00:39:54.345Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>xilousonw</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>hexo 常见问题解决</title>
    <link href="http://yoursite.com/2020/07/14/hexo%20%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3/"/>
    <id>http://yoursite.com/2020/07/14/hexo%20%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3/</id>
    <published>2020-07-14T00:39:54.345Z</published>
    <updated>2020-07-14T00:39:54.345Z</updated>
    
    <content type="html"><![CDATA[<p>1 在hexo g hexo d后 CNAME文件不见了导致网站404：</p><p>需要重新git push一下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git init</span><br><span class="line">git remote add origin https:&#x2F;&#x2F;github.com&#x2F;xilousonw&#x2F;xilousonw.github.io</span><br><span class="line">git add .</span><br><span class="line">git commit -m &quot;Initial commit&quot;</span><br><span class="line">git push -u origin master</span><br></pre></td></tr></table></figure><p>2.在执行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote add origin https:&#x2F;&#x2F;github.com&#x2F;xilousonw&#x2F;xilousonw.github.io</span><br></pre></td></tr></table></figure><p>后，出现</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fatal: remote origin already exists.</span><br></pre></td></tr></table></figure><p>这事由于目标已经存在</p><p>需要执行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git remote rm origin</span><br><span class="line">然后重新执行</span><br><span class="line">git remote add origin https:&#x2F;&#x2F;github.com&#x2F;xilousonw&#x2F;xilousonw.github.io</span><br></pre></td></tr></table></figure><p>3.如果在执行git push之后出现</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">To https:&#x2F;&#x2F;github.com&#x2F;xilousonw&#x2F;xilousonw.github.io</span><br><span class="line"> ! [rejected]        master -&gt; master (fetch first)</span><br><span class="line">error: failed to push some refs to &#39;https:&#x2F;&#x2F;github.com&#x2F;xilousonw&#x2F;xilousonw.github.io&#39;</span><br><span class="line">hint: Updates were rejected because the remote contains work that you do</span><br><span class="line">hint: not have locally. This is usually caused by another repository pushing</span><br><span class="line">hint: to the same ref. You may want to first integrate the remote changes</span><br><span class="line">hint: (e.g., &#39;git pull ...&#39;) before pushing again.</span><br><span class="line">hint: See the &#39;Note about fast-forwards&#39; in &#39;git push --help&#39; for details.</span><br></pre></td></tr></table></figure><p>那么只需要执行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git pull --rebase origin master</span><br></pre></td></tr></table></figure><p>然后重新push即可</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;1 在hexo g hexo d后 CNAME文件不见了导致网站404：&lt;/p&gt;
&lt;p&gt;需要重新git push一下&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span c
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>16-Linux——计划任务</title>
    <link href="http://yoursite.com/2019/03/09/Linux%E2%80%94%E2%80%94%E8%AE%A1%E5%88%92%E4%BB%BB%E5%8A%A1/"/>
    <id>http://yoursite.com/2019/03/09/Linux%E2%80%94%E2%80%94%E8%AE%A1%E5%88%92%E4%BB%BB%E5%8A%A1/</id>
    <published>2019-03-09T13:38:20.000Z</published>
    <updated>2020-08-18T12:15:48.385Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-计划任务基本概述"><a href="#1-计划任务基本概述" class="headerlink" title="1.计划任务基本概述"></a>1.计划任务基本概述</h2><h3 id="1-什么是crond"><a href="#1-什么是crond" class="headerlink" title="1.什么是crond"></a>1.什么是crond</h3><p>crond就是计划任务，类似于我们平时生活中的闹钟。定点执行。</p><p>2.为什么要使用crond<br>crond主要是做一些周期性的任务，比如: 凌晨3点定时备份数据。比如：11点开启网站抢购接口，12点关闭网站抢购接口。</p><h3 id="3-计划任务主要分为以下两种使用情况"><a href="#3-计划任务主要分为以下两种使用情况" class="headerlink" title="3.计划任务主要分为以下两种使用情况:"></a>3.计划任务主要分为以下两种使用情况:</h3><p>1.系统级别的定时任务： 临时文件清理、系统信息采集、日志文件切割<br>2.用户级别的定时任务： 定时向互联网同步时间、定时备份系统配置文件、定时备份数据库的数据</p><h2 id="2-计划任务时间管理"><a href="#2-计划任务时间管理" class="headerlink" title="2.计划任务时间管理"></a>2.计划任务时间管理</h2><h3 id="1-Crontab配置文件记录了时间周期的含义"><a href="#1-Crontab配置文件记录了时间周期的含义" class="headerlink" title="1.Crontab配置文件记录了时间周期的含义"></a>1.Crontab配置文件记录了时间周期的含义</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">[root@lqz ~]# vim &#x2F;etc&#x2F;crontab</span><br><span class="line">SHELL&#x3D;&#x2F;bin&#x2F;bash                     #执行命令的解释器</span><br><span class="line">PATH&#x3D;&#x2F;sbin:&#x2F;bin:&#x2F;usr&#x2F;sbin:&#x2F;usr&#x2F;bin  #环境变量</span><br><span class="line">MAILTO&#x3D;root                         #邮件发给谁</span><br><span class="line"># Example of job definition:</span><br><span class="line"># .---------------- minute (0 - 59) #分钟</span><br><span class="line"># |  .------------- hour (0 - 23)   #小时</span><br><span class="line"># |  |  .---------- day of month (1 - 31)   #日期</span><br><span class="line"># |  |  |  .------- month (1 - 12) OR jan,feb,mar,apr #月份</span><br><span class="line"># |  |  |  |  .---- day of week (0 - 6) (Sunday&#x3D;0 or 7) OR sun,mon,tue,wed,thu,fri,sat  #星期</span><br><span class="line"># |  |  |  |  |</span><br><span class="line">#            command to be executed</span><br><span class="line"></span><br><span class="line">#   表示任意的(分、时、日、月、周)时间都执行</span><br><span class="line"># -  表示一个时间范围段, 如5-7点</span><br><span class="line"># ,  表示分隔时段, 如6,0,4表示周六、日、四</span><br><span class="line"># &#x2F;1 表示每隔n单位时间, 如&#x2F;10 每10分钟</span><br></pre></td></tr></table></figure><h3 id="2-了解crontab的时间编写规范"><a href="#2-了解crontab的时间编写规范" class="headerlink" title="2.了解crontab的时间编写规范"></a>2.了解crontab的时间编写规范</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">00 02    ls      #每天的凌晨2点整执行</span><br><span class="line">00 02 1   ls      #每月的1日的凌晨2点整执行</span><br><span class="line">00 02 14 2  ls     #每年的2月14日凌晨2点执行</span><br><span class="line">00 02   7 ls      #每周天的凌晨2点整执行</span><br><span class="line">00 02  6 5 ls      #每年的6月周五凌晨2点执行</span><br><span class="line">00 02 14  7 ls     #每月14日或每周日的凌晨2点都执行</span><br><span class="line">00 02 14 2 7 ls     #每年的2月14日或每年2月的周天的凌晨2点执行   </span><br><span class="line">&#x2F;10  02    ls   #每天凌晨2点，每隔10分钟执行一次</span><br><span class="line">      ls       #每分钟都执行</span><br><span class="line">00 00 14 2   ls    #每年2月14日的凌晨执行命令 </span><br><span class="line">&#x2F;5      ls     #每隔5分钟执行一次</span><br><span class="line">00 02  1,5,8  ls  #每年的1月5月8月凌晨2点执行</span><br><span class="line">00 02 1-8    ls    #每月1号到8号凌晨2点执行</span><br><span class="line">0 21    ls       #每天晚上21:00执行</span><br><span class="line">45 4 1,10,22   ls #每月1、10、22日的4:45执行</span><br><span class="line">45 4 1-10   l     #每月1到10日的4:45执行</span><br><span class="line">3,15 8-11 &#x2F;2   ls #每隔两天的上午8点到11点的第3和第15分钟执行</span><br><span class="line">0 23-7&#x2F;1    ls   #晚上11点到早上7点之间，每隔一小时执行</span><br><span class="line">15 21   1-5 ls    #周一到周五每天晚上21:15执行</span><br></pre></td></tr></table></figure><h3 id="3-使用crontab编写cron定时任务"><a href="#3-使用crontab编写cron定时任务" class="headerlink" title="3.使用crontab编写cron定时任务"></a>3.使用crontab编写cron定时任务</h3><table><thead><tr><th>参数</th><th>含义</th></tr></thead><tbody><tr><td>-e</td><td>编辑定时任务</td></tr><tr><td>-l</td><td>查看定时任务</td></tr><tr><td>-r</td><td>删除定时任务</td></tr><tr><td>-u</td><td>指定其他用户</td></tr></tbody></table><h2 id="3-计划任务编写实践"><a href="#3-计划任务编写实践" class="headerlink" title="3.计划任务编写实践"></a>3.计划任务编写实践</h2><h3 id="1-使用root用户每5分钟执行一次时间同步"><a href="#1-使用root用户每5分钟执行一次时间同步" class="headerlink" title="1.使用root用户每5分钟执行一次时间同步"></a>1.使用root用户每5分钟执行一次时间同步</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#1.如何同步时间</span><br><span class="line">[root@lqz ~]# ntpdate time.windows.com &amp;&gt;&#x2F;dev&#x2F;null</span><br><span class="line">#2.配置定时任务</span><br><span class="line">[root@lqz ~]# crontab -e -u root</span><br><span class="line">[root@lqz ~]# crontab -l -u root</span><br><span class="line">&#x2F;5     ntpdate time.windows.com &amp;&gt;&#x2F;dev&#x2F;null</span><br></pre></td></tr></table></figure><h3 id="2-每天的下午3-5点，每隔半小时执行一次sync命令"><a href="#2-每天的下午3-5点，每隔半小时执行一次sync命令" class="headerlink" title="2.每天的下午3,5点，每隔半小时执行一次sync命令"></a>2.每天的下午3,5点，每隔半小时执行一次sync命令</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@lqz ~]# crontab -l</span><br><span class="line">&#x2F;30 15,17    sync &amp;&gt;&#x2F;dev&#x2F;null</span><br></pre></td></tr></table></figure><h3 id="3-案例：每天凌晨3点做一次备份？备份-etc-目录到-backup下面"><a href="#3-案例：每天凌晨3点做一次备份？备份-etc-目录到-backup下面" class="headerlink" title="3.案例：每天凌晨3点做一次备份？备份/etc/目录到/backup下面"></a>3.案例：每天凌晨3点做一次备份？备份/etc/目录到/backup下面</h3><p>1) 将备份命令写入一个脚本中<br>2) 每天备份文件名要求格式: 2019-05-01_hostname_etc.tar.gz<br>3) 在执行计划任务时，不要输出任务信息<br>4) 存放备份内容的目录要求只保留三天的数据</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">#1.实现如上备份需求</span><br><span class="line">[root@lqz ~]# mkdir &#x2F;backup</span><br><span class="line">[root@lqz ~]# tar zcf $(date +%F)_$(hostname)_etc.tar.gz &#x2F;etc</span><br><span class="line">[root@lqz ~]# find &#x2F;backup -name “.tar.gz” -mtime +3 -exec rm -f &#123;&#125;;</span><br><span class="line"></span><br><span class="line">#2.将命令写入至一个文件中</span><br><span class="line">[root@lqz ~]# vim &#x2F;root&#x2F;back.sh</span><br><span class="line">mkdir &#x2F;backup</span><br><span class="line">tar zcf $(date +%F)_$(hostname)_etc.tar.gz &#x2F;etc</span><br><span class="line">find &#x2F;backup -name “.tar.gz” -mtime +3 -exec rm -f &#123;&#125;;</span><br><span class="line"></span><br><span class="line">#3.配置定时任务</span><br><span class="line">[root@lqz ~]# crontab -l</span><br><span class="line">00 03    bash &#x2F;root&#x2F;back.sh  &amp;&gt;&#x2F;dev&#x2F;null</span><br><span class="line"></span><br><span class="line">#3.备份脚本</span><br></pre></td></tr></table></figure><h3 id="4-crond注意的事项"><a href="#4-crond注意的事项" class="headerlink" title="4.crond注意的事项"></a>4.crond注意的事项</h3><p>1) 给定时任务注释<br>2) 将需要定期执行的任务写入Shell脚本中，避免直接使用命令无法执行的情况tar date<br>3) 定时任务的结尾一定要有&amp;&gt;/dev/null或者将结果追加重定向&gt;&gt;/tmp/date.log文件<br>4) 注意有些命令是无法成功执行的 echo “123” &gt;&gt;/tmp/test.log &amp;&gt;/dev/null<br>5.如果一定要是用命令，命令必须使用绝对路径</p><p>5.crond如何备份</p><p>1) 通过查找/var/log/cron中执行的记录，去推算任务执行的时间<br>2) 定时的备份/var/spool/cron/{usernmae}</p><p>6.crond如何拒绝某个用户使用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#1.使用root将需要拒绝的用户加入&#x2F;etc&#x2F;cron.deny</span><br><span class="line">[root@lqz ~]# echo &quot;lqz&quot; &gt;&gt; &#x2F;etc&#x2F;cron.deny</span><br><span class="line"></span><br><span class="line">#2.登陆该普通用户，测试是否能编写定时任务</span><br><span class="line">[oldboy@lqz ~]$ crontab -e</span><br><span class="line">You (lqz) are not allowed to use this program (crontab)</span><br><span class="line">See crontab(1) for more information</span><br></pre></td></tr></table></figure><h2 id="4-计划任务如何调试"><a href="#4-计划任务如何调试" class="headerlink" title="4.计划任务如何调试"></a>4.计划任务如何调试</h2><h3 id="1-crond调试"><a href="#1-crond调试" class="headerlink" title="1.crond调试"></a>1.crond调试</h3><p>1) 调整任务每分钟执行的频率, 以便做后续的调试。<br>2) 如果使用cron运行脚本，请将脚本执行的结果写入指定日志文件, 观察日志内容是否正常。<br>3) 命令使用绝对路径, 防止无法找到命令导致定时任务执行产生故障。<br>4) 通过查看/var/log/cron日志，以便检查我们执行的结果，方便进行调试。</p><h3 id="2-crond编写思路"><a href="#2-crond编写思路" class="headerlink" title="2.crond编写思路"></a>2.crond编写思路</h3><ul><li>1.手动执行命令，然后保留执行成功的结果。</li><li>2.编写脚本<ul><li>脚本需要统一路径/scripts</li><li>脚本内容复制执行成功的命令(减少每个环节出错几率)</li><li>脚本内容尽可能的优化, 使用一些变量或使用简单的判断语句</li><li>脚本执行的输出信息可以重定向至其他位置保留或写入/dev/null</li></ul></li><li>3.执行脚本<ul><li>使用bash命令执行, 防止脚本没有增加执行权限(/usr/bin/bash)</li><li>执行脚本成功后，复制该执行的命令，以便写入cron</li></ul></li><li>4.编写计划任务<ul><li>加上必要的注释信息, 人、时间、任务</li><li>设定计划任务执行的周期</li><li>粘贴执行脚本的命令(不要手敲)</li></ul></li><li>5.调试计划任务<ul><li>增加任务频率测试</li><li>检查环境变量问题</li><li>检查crond服务日志</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1-计划任务基本概述&quot;&gt;&lt;a href=&quot;#1-计划任务基本概述&quot; class=&quot;headerlink&quot; title=&quot;1.计划任务基本概述&quot;&gt;&lt;/a&gt;1.计划任务基本概述&lt;/h2&gt;&lt;h3 id=&quot;1-什么是crond&quot;&gt;&lt;a href=&quot;#1-什么是crond&quot;
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>15-Linux——磁盘管理</title>
    <link href="http://yoursite.com/2019/03/08/Linux%E2%80%94%E2%80%94%E7%A3%81%E7%9B%98%E7%AE%A1%E7%90%86/"/>
    <id>http://yoursite.com/2019/03/08/Linux%E2%80%94%E2%80%94%E7%A3%81%E7%9B%98%E7%AE%A1%E7%90%86/</id>
    <published>2019-03-08T14:28:31.000Z</published>
    <updated>2020-08-18T12:15:38.243Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-磁盘的基本概念"><a href="#1-磁盘的基本概念" class="headerlink" title="1.磁盘的基本概念"></a>1.磁盘的基本概念</h2><h3 id="1-什么是磁盘"><a href="#1-什么是磁盘" class="headerlink" title="1.什么是磁盘"></a>1.什么是磁盘</h3><p>绝大多数人对硬盘都不陌生，<br>一块小小的硬盘里，就可以存储海量的照片音乐和电影，尤其是我们喜爱的各类动作片。<br>但如此小的空间，是如何储存那么多信息的呢？</p><p><img src= "/img/loading.gif" data-src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ghu74p7kx2g30b205o1h5.gif" alt="img"></p><p>每个硬盘中心都是一摞高速运转的圆盘，在圆盘上附着的一圈金属颗粒，每个金属颗粒都有自己的磁化程度，用于储存0和1。<br><img src= "/img/loading.gif" data-src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ghu74u1ba3g30b205o1kx.gif" alt="img"></p><p>当记录数据时，硬盘的磁头开始通电，形成强磁场，数据在磁场的作用下转变成电流，使颗粒磁化，从而将信息记录在圆盘上。<br><img src= "/img/loading.gif" data-src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ghu750jjpqg30b205o1kx.gif" alt="img"></p><p>由海量颗粒组成的信息，就是我们存在硬盘里的数据。<br><img src= "/img/loading.gif" data-src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ghu755p4cnj30gk09amyw.jpg" alt="img"></p><p><a href="https://zhidao.baidu.com/question/518945599.html" target="_blank" rel="noopener">什么是磁盘、软盘、硬盘？</a></p><h2 id="2-磁盘的基本结构"><a href="#2-磁盘的基本结构" class="headerlink" title="2.磁盘的基本结构"></a>2.磁盘的基本结构</h2><p>1.什么是盘片: 硬盘一般有一个或多个盘片，每个盘片可以有两面，即第一个盘片的正面为0面，反面为1面然后依次类推。<br>2.什么是磁道:每个盘片的盘面在出厂的时候被划分出了多个同心圆环，数据就存储在这样的同心圆环上面，我们将这样的圆环称为磁道(Track)，每个盘面可以划分多个磁道。但肉业不可见。<br>3.什么是扇区: 在硬盘出厂时会对磁盘进行一次低格，其实就是再每个磁道划分为若干个弧段，每个弧段就是一个扇区 (Sector)。扇区是硬盘上存储的物理单位，现在每个扇区可存储512字节数据已经成了业界的约定。<br>4.什么是柱面:柱面实际上就是我们抽象出来的一个逻辑概念，简单来说就是处于同一个垂直区域的磁道称为 柱面 ，即各盘面上面相同位置磁道的集合。这样数据如果存储到相同半径磁道上的同一扇区，这样可以实现并行读取，主要是减少磁头寻道时间。<br>5.什么是磁头: 读取磁盘磁道上面金属块，主要负责读或写入数据。</p><p><img src= "/img/loading.gif" data-src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ghu759jzvoj30hb0buq4x.jpg" alt="img"><br><img src= "/img/loading.gif" data-src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ghu75ffahij30vk0u0aii.jpg" alt="img"></p><h2 id="3-磁盘的预备知识"><a href="#3-磁盘的预备知识" class="headerlink" title="3.磁盘的预备知识"></a>3.磁盘的预备知识</h2><p>我们需要简单了解下磁盘的接口类型、磁盘涉及的相关术语、磁盘在Linux下的命名方式。</p><h3 id="1-磁盘的接口类型"><a href="#1-磁盘的接口类型" class="headerlink" title="1.磁盘的接口类型"></a>1.磁盘的接口类型</h3><p>IDE，Scsi（已经被淘汰）<br><img src= "/img/loading.gif" data-src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ghu75jg4uej30c009o0tx.jpg" alt="img">))<img src= "/img/loading.gif" data-src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ghu7680mk6j30c0086gn1.jpg" alt="img"></p><p>SATA III 与SAS(企业使用较多)<br><img src= "/img/loading.gif" data-src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ghu76c42gbj30ra0d8jt8.jpg" alt="img"></p><p>ssd的Msata接口为超极本设计，但是被m.2接口的SSD替代，而m.2接口(支持SATA、PCI-E双通道协议)</p><p>1、M.2接口是为超极本量身定做的新一代接口标准，以取代原来的mSATA接口。拥有更小巧的规格尺寸，还是更高的传输性能，M.2都远胜于mSATA。 <a href="https://baike.baidu.com/item/m.2接口/18010680?fr=aladdin" target="_blank" rel="noopener">m2接口百度百科</a> <a href="https://zhidao.baidu.com/question/754765227221408324.html" target="_blank" rel="noopener">固态硬盘SATA和mSATA有什么区别</a><br>2、M.2几个名词需要各位读者知道了解，<a href="https://baijiahao.baidu.com/s?id=1581244478575233647&wfr=spider&for=pc" target="_blank" rel="noopener">SATA和PCI-E AHCI和NVMe</a><br>3、最后呢，可以扩展了解 <a href="http://baijiahao.baidu.com/s?id=1604321789851430125&wfr=spider&for=pc" target="_blank" rel="noopener">M.2固态硬盘使用过程中常见问题？</a></p><h3 id="2-磁盘的基本术语"><a href="#2-磁盘的基本术语" class="headerlink" title="2.磁盘的基本术语"></a>2.磁盘的基本术语</h3><p>尺寸: 2.5英寸 3.5英寸<br>容量：KB MB GB TB PB EB<br>转速：7500 15000<br>IOPS：每秒能够发生IO的次数</p><h3 id="3-磁盘在系统上的命名方式"><a href="#3-磁盘在系统上的命名方式" class="headerlink" title="3.磁盘在系统上的命名方式"></a>3.磁盘在系统上的命名方式</h3><table><thead><tr><th>设备名称</th><th>分区信息</th><th>设备类型</th></tr></thead><tbody><tr><td>/dev/sda</td><td>/dev/sda1</td><td>第一块物理磁盘第一分区</td></tr><tr><td>/dev/sdb</td><td>/dev/sdb2</td><td>第二块物理磁盘第二个分区</td></tr><tr><td>/dev/vdd</td><td>/dev/vdd4</td><td>第四块虚拟磁盘的第四个分区</td></tr></tbody></table><p>PS1：系统中分区由数字编号表示，1~4留给主分区使用和扩展分区，逻辑分区从5开始，为什么分区还有限制？不应该是随意分配？因为MBR分区表只能分配4个主分区？why？<br><a href="https://baike.baidu.com/item/主引导记录/7612638" target="_blank" rel="noopener">MBR为什么只能划分4个主分区</a></p><p>PS2: 前面我们已经提到过MBR分区表只能分配4个主分区，但现在还有一种新型的分区表GPT，GPT支持分配128个主分区。注意MBR与GPT之间不能互转，会导致数据丢失。<br><a href="http://www.udaxia.com/wtjd/6117.html" target="_blank" rel="noopener">MBR与GPT之间又有什么区别</a></p><h2 id="4-磁盘基本分区Fdisk"><a href="#4-磁盘基本分区Fdisk" class="headerlink" title="4.磁盘基本分区Fdisk"></a>4.磁盘基本分区Fdisk</h2><p>1.添加一块小于2TB的磁盘进行使用，步骤如下:<br>1.给虚拟机添加一块新的硬盘<br>2.使用fdisk进行分区<br>3.使用mkfs进行格式化<br>4.使用mount进行挂载<br>PS: 生产分区建议，如无特殊需求直接使用整个磁盘即可，无需分区。<br>PS: 学习分区建议: 1P+1E(3L) 2P+1E(2L) 3P+1E(1L) (仅适用于练习)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">[root@lqz ~]# fdisk -l</span><br><span class="line">[root@lqz ~]# fdisk  &#x2F;dev&#x2F;sdb</span><br><span class="line">Command (m for help): m         #输入m列出常用的命令</span><br><span class="line">Command action</span><br><span class="line">   a   toggle a bootable flag               #切换分区启动标记</span><br><span class="line">   b   edit bsd disklabel                   #编辑sdb磁盘标签</span><br><span class="line">   c   toggle the dos compatibility flag    #切换dos兼容模式</span><br><span class="line">   d   delete a partition                   #删除分区</span><br><span class="line">   l   list known partition types           #显示分区类型</span><br><span class="line">   m   print this menu                       #显示帮助菜单</span><br><span class="line">   n   add a new partition                  #新建分区</span><br><span class="line">   o   create a new empty DOS partition table   #创建新的空白分区表</span><br><span class="line">   p   print the partition table            #显示分区表的信息</span><br><span class="line">   q   quit without saving changes          #不保存退出</span><br><span class="line">   s   create a new empty Sun disklabel     #创建新的Sun磁盘标签</span><br><span class="line">   t   change a partitions system id       #修改分区ID,可以通过l查看id</span><br><span class="line">   u   change display&#x2F;entry units           #修改容量单位,磁柱或扇区</span><br><span class="line">   v   verify the partition table           #检验分区表</span><br><span class="line">   w   write table to disk and exit         #保存退出</span><br><span class="line">   x   extra functionality (experts only)   #拓展功能</span><br></pre></td></tr></table></figure><h3 id="1-fdisk创建主分区"><a href="#1-fdisk创建主分区" class="headerlink" title="1.fdisk创建主分区"></a>1.fdisk创建主分区</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Command (m for help): n</span><br><span class="line">Partition type:</span><br><span class="line">   p   primary (0 primary, 0 extended, 4 free)  #主分区</span><br><span class="line">   e   extended  #扩展分区</span><br><span class="line">Select (default p): p   #选择创建主分区</span><br><span class="line">Partition number (1-4, default 1):  #默认创建第一个主分区</span><br><span class="line">First sector (2048-2097151, default 2048): #默认扇区回车</span><br><span class="line">Using default value 2048</span><br><span class="line">Last sector, +sectors or +size&#123;K,M,G&#125; (2048-2097151, default 2097151): +50M #分配50MB</span><br></pre></td></tr></table></figure><h3 id="2-fdisk创建扩展分区"><a href="#2-fdisk创建扩展分区" class="headerlink" title="2.fdisk创建扩展分区"></a>2.fdisk创建扩展分区</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Command (m for help): n  #新建分区</span><br><span class="line">Partition type:</span><br><span class="line">   p   primary (1 primary, 0 extended, 3 free)</span><br><span class="line">   e   extended</span><br><span class="line">Select (default p): e   #创建扩展分区</span><br><span class="line">Partition number (2-4, default 2):</span><br><span class="line">First sector (104448-2097151, default 104448):</span><br><span class="line">Using default value 104448</span><br><span class="line">Last sector, +sectors or +size&#123;K,M,G&#125; (104448-2097151, default 2097151): #空间都给到扩展分区</span><br></pre></td></tr></table></figure><h3 id="3-fdisk创建逻辑分区"><a href="#3-fdisk创建逻辑分区" class="headerlink" title="3.fdisk创建逻辑分区"></a>3.fdisk创建逻辑分区</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Command (m for help): n  #新建分区</span><br><span class="line">Partition type:</span><br><span class="line">   p   primary (1 primary, 1 extended, 2 free)</span><br><span class="line">   l   logical (numbered from 5)</span><br><span class="line">Select (default p): l   #创建逻辑分区</span><br><span class="line">Adding logical partition 5</span><br><span class="line">First sector (106496-2097151, default 106496):</span><br><span class="line">Using default value 106496</span><br><span class="line">Last sector, +sectors or +size&#123;K,M,G&#125; (106496-2097151, default 2097151): +100M  #分配100MB空间</span><br></pre></td></tr></table></figure><h3 id="4-fdisk查看分区情况，并保存"><a href="#4-fdisk查看分区情况，并保存" class="headerlink" title="4.fdisk查看分区情况，并保存"></a>4.fdisk查看分区情况，并保存</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Command (m for help): p #查看分区创建</span><br><span class="line">Device Boot      Start         End      Blocks   Id  System</span><br><span class="line">&#x2F;dev&#x2F;sdb1            2048      104447       51200   83  Linux</span><br><span class="line">&#x2F;dev&#x2F;sdb2          104448     2097151      996352    5  Extended</span><br><span class="line">&#x2F;dev&#x2F;sdb5          106496      311295      102400   83  Linux</span><br><span class="line"></span><br><span class="line">#保存分区</span><br><span class="line">Command (m for help): w</span><br><span class="line">The partition table has been altered!</span><br><span class="line">Calling ioctl() to re-read partition table.</span><br><span class="line">Syncing disks.</span><br><span class="line"></span><br><span class="line">#检查磁盘是否是MBR分区方式</span><br><span class="line">[root@lqz ~]# fdisk &#x2F;dev&#x2F;sdb -l|grep type</span><br><span class="line">Disk label type: dos</span><br><span class="line"></span><br><span class="line">#安装parted, 刷新内核立即生效,无需重启</span><br><span class="line">[root@lqz ~]# yum -y install parted</span><br><span class="line">[root@lqz ~]# partprobe &#x2F;dev&#x2F;sdb</span><br></pre></td></tr></table></figure><h3 id="5-格式化磁盘"><a href="#5-格式化磁盘" class="headerlink" title="5.格式化磁盘"></a>5.格式化磁盘</h3><p>mkfs格式化磁盘，实质创建文件系统，文件系统类似于将房子装修成3室一厅，还是2室一厅。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#选项: </span><br><span class="line"># -b  设定数据区块占用空间大小，目前支持1024、2048、4096 bytes每个块。</span><br><span class="line"># -t  用来指定什么类型的文件系统，可以是ext4, xfs</span><br><span class="line"># -i  设定inode的大小</span><br><span class="line"># -N  设定inode数量，防止Inode数量不够导致磁盘不足</span><br><span class="line"></span><br><span class="line">#1.格式化整个磁盘</span><br><span class="line">[root@lqz ~]# mkfs.ext4  &#x2F;dev&#x2F;sdb </span><br><span class="line"></span><br><span class="line">#2.格式化磁盘的某个分区</span><br><span class="line">[root@lqz ~]# mkfs.xfs  &#x2F;dev&#x2F;sdb1</span><br></pre></td></tr></table></figure><h3 id="6-使用mount挂载并使用"><a href="#6-使用mount挂载并使用" class="headerlink" title="6.使用mount挂载并使用"></a>6.使用mount挂载并使用</h3><p>如果需要使用该磁盘的空间，需要准备一个空的目录作为挂载点，与该设备进行关联。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@lqz ~]# mkdir &#x2F;data</span><br><span class="line">[root@lqz ~]# mount &#x2F;dev&#x2F;sdb1 &#x2F;data</span><br></pre></td></tr></table></figure><h2 id="5-磁盘的基本分区Gdisk"><a href="#5-磁盘的基本分区Gdisk" class="headerlink" title="5.磁盘的基本分区Gdisk"></a>5.磁盘的基本分区Gdisk</h2><p>前面我们已经了解到fdisk分区，但fdisk不支持给高于2TB的磁盘进行分区。如果有单块盘高于2TB，建议使用Gdisk进行分区。</p><h3 id="1-使用gdisk进行磁盘分区"><a href="#1-使用gdisk进行磁盘分区" class="headerlink" title="1.使用gdisk进行磁盘分区"></a>1.使用gdisk进行磁盘分区</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">#1.安装gdisk分区工具</span><br><span class="line">[root@lqz ~]# yum install gdisk -y</span><br><span class="line"></span><br><span class="line">#2.创建一个新分区，500MB大小</span><br><span class="line">[root@lqz ~]# gdisk &#x2F;dev&#x2F;sdb</span><br><span class="line">Command (? for help): n     #创建新分区</span><br><span class="line">Partition number (1-128, default 1):</span><br><span class="line">First sector (34-2097118, default &#x3D; 2048) or &#123;+-&#125;size&#123;KMGTP&#125;:</span><br><span class="line">Last sector (2048-2097118, default &#x3D; 2097118) or &#123;+-&#125;size&#123;KMGTP&#125;: +500M #分配500M大小</span><br><span class="line"></span><br><span class="line">Command (? for help): p #打印查看</span><br><span class="line">Number  Start (sector)    End (sector)  Size       Code  Name</span><br><span class="line">   1            2048         1026047   500.0 MiB   8300  Linux filesystem</span><br><span class="line"></span><br><span class="line">Command (? for help): w #保存分区</span><br><span class="line">Do you want to proceed? (Y&#x2F;N): y    #确认</span><br><span class="line">OK; writing new GUID partition table (GPT) to &#x2F;dev&#x2F;sdb.</span><br><span class="line">The operation has completed successfully.</span><br><span class="line"></span><br><span class="line">#3.创建完成后，可以尝试检查磁盘是否为gpt格式</span><br><span class="line">[root@lqz-node1 &#x2F;]# fdisk &#x2F;dev&#x2F;sdb -l|grep type</span><br><span class="line">Disk label type: gpt</span><br><span class="line"></span><br><span class="line">#4.安装parted, 刷新内核立即生效,无需重启</span><br><span class="line">[root@lqz ~]# yum -y install parted</span><br><span class="line">[root@lqz ~]# partprobe &#x2F;dev&#x2F;sdb</span><br></pre></td></tr></table></figure><h3 id="2-使用mkfs进行格式化磁盘。前面已经介绍过，此处不反复介绍。"><a href="#2-使用mkfs进行格式化磁盘。前面已经介绍过，此处不反复介绍。" class="headerlink" title="2.使用mkfs进行格式化磁盘。前面已经介绍过，此处不反复介绍。"></a>2.使用mkfs进行格式化磁盘。前面已经介绍过，此处不反复介绍。</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@lqz ~]# mkfs.xfs  &#x2F;dev&#x2F;sdb</span><br></pre></td></tr></table></figure><h3 id="3-使用mount命令将某个目录挂载该分区，进行使用。"><a href="#3-使用mount命令将某个目录挂载该分区，进行使用。" class="headerlink" title="3.使用mount命令将某个目录挂载该分区，进行使用。"></a>3.使用mount命令将某个目录挂载该分区，进行使用。</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@lqz ~]# mkdir &#x2F;data_gdisk</span><br><span class="line">[root@lqz ~]# mount &#x2F;dev&#x2F;sdb &#x2F;data_gdisk</span><br></pre></td></tr></table></figure><h2 id="6-磁盘挂载方式Mount"><a href="#6-磁盘挂载方式Mount" class="headerlink" title="6.磁盘挂载方式Mount"></a>6.磁盘挂载方式Mount</h2><p>前面我们已经提到过，如果需要使用磁盘的空间，需要准备一个空的目录作为挂载点，与该设备进行关联。mount主要是为文件系统指定一个访问入口。<br>PS: 类似我的商场没有门，那么就无法进入购买商品，此时通过mount命令可以创建一个入口。给超市安装一个门。如图:</p><h3 id="1-通过mount进行挂载，但重启将会失效。我们称为临时生效。"><a href="#1-通过mount进行挂载，但重启将会失效。我们称为临时生效。" class="headerlink" title="1.通过mount进行挂载，但重启将会失效。我们称为临时生效。"></a>1.通过mount进行挂载，但重启将会失效。我们称为临时生效。</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 选项：-t指定文件系统挂载分区 -a 挂载&#x2F;etc&#x2F;fstab中的配置文件 -o 指定挂载参数</span><br><span class="line"># 挂载&#x2F;dev&#x2F;sdb1至db1目录</span><br><span class="line">[root@lqz ~]# mkdir &#x2F;db1</span><br><span class="line">[root@lqz ~]# mount -t xfs &#x2F;dev&#x2F;sdb1  &#x2F;db1&#x2F;</span><br></pre></td></tr></table></figure><h3 id="2-挂载的磁盘，如果不想使用可以使用umount进行卸载。"><a href="#2-挂载的磁盘，如果不想使用可以使用umount进行卸载。" class="headerlink" title="2.挂载的磁盘，如果不想使用可以使用umount进行卸载。"></a>2.挂载的磁盘，如果不想使用可以使用umount进行卸载。</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">#选项： -l 强制卸载</span><br><span class="line"></span><br><span class="line">#1.卸载目录方式</span><br><span class="line">[root@lqz ~]# umount &#x2F;db1</span><br><span class="line"></span><br><span class="line">#2.卸载设备方式</span><br><span class="line">[root@lqz ~]# umount &#x2F;dev&#x2F;sdb1</span><br><span class="line"></span><br><span class="line">#3.umount不能卸载的情况</span><br><span class="line">[root@lqz db1]# umount &#x2F;db1  </span><br><span class="line">umount: &#x2F;db1: device is busy.</span><br><span class="line">        (In some cases useful info about processes that use</span><br><span class="line">         the device is found by lsof(8) or fuser(1)</span><br><span class="line"></span><br><span class="line">#PS: 如上情况解决办法有两种, 1.切换至其他目录 2.使用&#39;-l&#39;选项强制卸载    </span><br><span class="line">[root@student db1]# umount -l &#x2F;db1</span><br></pre></td></tr></table></figure><h3 id="3-如果需要实现永久挂载则需要将挂载信息写入-etc-fstab配置文件中实现。"><a href="#3-如果需要实现永久挂载则需要将挂载信息写入-etc-fstab配置文件中实现。" class="headerlink" title="3.如果需要实现永久挂载则需要将挂载信息写入/etc/fstab配置文件中实现。"></a>3.如果需要实现永久挂载则需要将挂载信息写入/etc/fstab配置文件中实现。</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">#1.使用blkid命令获取各设备的UUID</span><br><span class="line">[root@lqz ~]# blkid |grep &quot;sdb1&quot;</span><br><span class="line">&#x2F;dev&#x2F;sdb1: UUID&#x3D;&quot;e271b5b2-b1ba-4b18-bde5-66e394fb02d9&quot; TYPE&#x3D;&quot;xfs&quot;</span><br><span class="line"></span><br><span class="line">#2.使用UUID挂载磁盘sdb1分区至于db1， 测试挂载</span><br><span class="line">[root@lqz ~]# mount UUID&#x3D;&quot;e271b5b2-b1ba-4b18-bde5-66e394fb02d9&quot; &#x2F;db1</span><br><span class="line"></span><br><span class="line">#3.写入&#x2F;etc&#x2F;fstab中，实现开机自动挂载</span><br><span class="line">[root@lqz ~]# tail -1 &#x2F;etc&#x2F;fstab    </span><br><span class="line">UUID&#x3D;e271b5b2-b1ba-4b18-bde5-66e394fb02d9 &#x2F;db1 xfs  defaults 0  0</span><br><span class="line"></span><br><span class="line">#4.加载fstab配置文件, 同时检测语法是否有错误</span><br><span class="line">[root@lqz ~]# mount –a</span><br></pre></td></tr></table></figure><p>3./etc/fstab配置文件编写格式</p><table><thead><tr><th>要挂载的设备</th><th>挂载点(入口)</th><th>文件系统类型</th><th>挂载参数</th><th>是否备份</th><th>是否检查</th></tr></thead><tbody><tr><td>/dev/sdb1</td><td>/db1</td><td>xfs</td><td>defaults</td><td>0</td><td>0</td></tr></tbody></table><p>第四列：挂载参数。挂载参数有很多，在这块我们了解即可，不必深究。</p><table><thead><tr><th>参数</th><th>含义</th></tr></thead><tbody><tr><td>async/sync</td><td>是否为同步方式运行。默认async</td></tr><tr><td>user/nouser</td><td>是否允许普通用户使用mount命令挂载。默认nouser</td></tr><tr><td>exec/noexe</td><td>是否允许可执行文件执行。默认exec</td></tr><tr><td>suid/nosuid</td><td>是否允许存在suid属性的文件。默认suid</td></tr><tr><td>auto/noauto</td><td>执行mount -a 命令时，此文件系统是否被主动挂载。默认auto</td></tr><tr><td>rw/ro</td><td>是否以只读或者读写模式进行挂载。默认rw</td></tr><tr><td>default</td><td>具有rw,suid,dev,exec,auto,nouser,async等默认参数的设定</td></tr></tbody></table><p>第五列：是否进行备份。通常这个参数的值为0或者1</p><table><thead><tr><th>选项</th><th>含义</th></tr></thead><tbody><tr><td>0</td><td>代表不做备份</td></tr><tr><td>1</td><td>代表要每天进行备份操作</td></tr><tr><td>2</td><td>代表不定日期的进行备份操作</td></tr></tbody></table><p>第六列：是否检验扇区：开机的过程中，系统默认会以fsck检验我们系统是否为完整</p><table><thead><tr><th>选项</th><th>含义</th></tr></thead><tbody><tr><td>0</td><td>不要检验磁盘是否有坏道</td></tr><tr><td>1</td><td>检验</td></tr><tr><td>2</td><td>校验 (当1级别检验完成之后进行2级别检验)</td></tr></tbody></table><h2 id="7-虚拟磁盘介绍SWAP"><a href="#7-虚拟磁盘介绍SWAP" class="headerlink" title="7.虚拟磁盘介绍SWAP"></a>7.虚拟磁盘介绍SWAP</h2><p>Swap分区在系统的物理内存不够时，将硬盘空间中的一部分空间释放出来，以供当前运行的程序使用。<br>PS: 当物理内存不够时会随机kill占用内存的进程，从而产生oom，临时使用swap可以解决。</p><h3 id="1-创建分区，并格式化为swap分区。"><a href="#1-创建分区，并格式化为swap分区。" class="headerlink" title="1.创建分区，并格式化为swap分区。"></a>1.创建分区，并格式化为swap分区。</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@lqz ~]# fdisk  &#x2F;dev&#x2F;sdb       #分1个G大小</span><br><span class="line">[root@lqz ~]# mkswap &#x2F;dev&#x2F;sdb1      #格式化为swap</span><br></pre></td></tr></table></figure><h3 id="2-查看当前swap分区大小，然后进行扩展和缩小"><a href="#2-查看当前swap分区大小，然后进行扩展和缩小" class="headerlink" title="2.查看当前swap分区大小，然后进行扩展和缩小"></a>2.查看当前swap分区大小，然后进行扩展和缩小</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">[root@lqz ~]# free -m</span><br><span class="line">              total        used        free      shared  buff&#x2F;cache   available</span><br><span class="line">Mem:           1980        1475          80          10         424         242</span><br><span class="line">Swap:          2047           4        2043</span><br><span class="line"></span><br><span class="line">#1.扩展swap分区大小</span><br><span class="line">[root@lqz ~]# swapon &#x2F;dev&#x2F;sdb2</span><br><span class="line">[root@lqz ~]# free -m</span><br><span class="line">              total        used        free      shared  buff&#x2F;cache   available</span><br><span class="line">Mem:           1980        1475          80          10         424         242</span><br><span class="line">Swap:          3047           4        2043</span><br><span class="line">[root@lqz ~]# swapon -a #代表激活所有的swap</span><br><span class="line"></span><br><span class="line">#2.缩小swap分区大小</span><br><span class="line">[root@lqz ~]# swapoff &#x2F;dev&#x2F;sdb1</span><br><span class="line">[root@lqz ~]# free -m</span><br><span class="line">              total        used        free      shared  buff&#x2F;cache   available</span><br><span class="line">Mem:           1980        1475          80          10         424         242</span><br><span class="line">Swap:          2047           4        2043</span><br><span class="line">[root@lqz ~]# swapoff -a #代表关闭所有的swap</span><br></pre></td></tr></table></figure><h3 id="3-检查当前swap分区有哪些设备"><a href="#3-检查当前swap分区有哪些设备" class="headerlink" title="3.检查当前swap分区有哪些设备"></a>3.检查当前swap分区有哪些设备</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@lqz ~]# swapon -s</span><br><span class="line">文件名             类型      大小   已用  权限</span><br><span class="line">&#x2F;dev&#x2F;dm-1   partition   2097148   4616    -2</span><br><span class="line">&#x2F;dev&#x2F;sdb1   partition   1048572   0       -2</span><br></pre></td></tr></table></figure><h3 id="4-如果磁盘没有过多的分区可用，也可以通过文件增加SWAP空间，本质上还是磁盘"><a href="#4-如果磁盘没有过多的分区可用，也可以通过文件增加SWAP空间，本质上还是磁盘" class="headerlink" title="4.如果磁盘没有过多的分区可用，也可以通过文件增加SWAP空间，本质上还是磁盘"></a>4.如果磁盘没有过多的分区可用，也可以通过文件增加SWAP空间，本质上还是磁盘</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@lqz ~]# dd if&#x3D;&#x2F;dev&#x2F;zero of&#x3D;&#x2F;opt&#x2F;swap_file bs&#x3D;1M count&#x3D;500</span><br><span class="line">[root@lqz ~]# chmod 0600 &#x2F;opt&#x2F;swap_file</span><br><span class="line">[root@lqz ~]# mkswap -f &#x2F;opt&#x2F;swap_file </span><br><span class="line">[root@lqz ~]# swapon &#x2F;opt&#x2F;swap_file</span><br><span class="line">[root@lqz ~]# free -m</span><br></pre></td></tr></table></figure><p>PS: 如果希望swap开机自动挂载，将swap信息追加至/etc/fstab即可。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1-磁盘的基本概念&quot;&gt;&lt;a href=&quot;#1-磁盘的基本概念&quot; class=&quot;headerlink&quot; title=&quot;1.磁盘的基本概念&quot;&gt;&lt;/a&gt;1.磁盘的基本概念&lt;/h2&gt;&lt;h3 id=&quot;1-什么是磁盘&quot;&gt;&lt;a href=&quot;#1-什么是磁盘&quot; class=&quot;he
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>14-Linux——系统服务</title>
    <link href="http://yoursite.com/2019/03/07/Linux%E2%80%94%E2%80%94%E7%B3%BB%E7%BB%9F%E6%9C%8D%E5%8A%A1/"/>
    <id>http://yoursite.com/2019/03/07/Linux%E2%80%94%E2%80%94%E7%B3%BB%E7%BB%9F%E6%9C%8D%E5%8A%A1/</id>
    <published>2019-03-07T13:20:41.000Z</published>
    <updated>2020-08-18T12:14:47.408Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-Linux启动流程"><a href="#1-Linux启动流程" class="headerlink" title="1.Linux启动流程"></a>1.Linux启动流程</h2><p><a href="https://www.runoob.com/linux/linux-system-boot.html" target="_blank" rel="noopener">CentOS6启动级别</a><br><a href="https://www.processon.com/view/link/5bffde0ae4b0f012f2382181" target="_blank" rel="noopener">CentOS6 VS Centos7开机启动流程图解</a></p><h2 id="2-Linux运行级别"><a href="#2-Linux运行级别" class="headerlink" title="2.Linux运行级别"></a>2.Linux运行级别</h2><h3 id="1-什么是运行级别，运行级别就是操作系统当前正在运行的功能级别"><a href="#1-什么是运行级别，运行级别就是操作系统当前正在运行的功能级别" class="headerlink" title="1.什么是运行级别，运行级别就是操作系统当前正在运行的功能级别"></a>1.什么是运行级别，运行级别就是操作系统当前正在运行的功能级别</h3><table><thead><tr><th>System V init运行级别</th><th>systemd目标名称</th><th>作用</th></tr></thead><tbody><tr><td>0</td><td>runlevel0.target, poweroff.target</td><td>关机</td></tr><tr><td>1</td><td>runlevel1.target, rescue.target</td><td>单用户模式</td></tr><tr><td>2</td><td>runlevel2.target, multi-user.target</td><td></td></tr><tr><td>3</td><td>runlevel3.target, multi-user.target</td><td>多用户的文本界面</td></tr><tr><td>4</td><td>runlevel4.target, multi-user.target</td><td></td></tr><tr><td>5</td><td>runlevel5.target, graphical.target</td><td>多用户的图形界面</td></tr><tr><td>6</td><td>runlevel6.target, reboot.target</td><td>重启</td></tr></tbody></table><h3 id="2-如何调整系统启动的运行级别？systemd使用’targets’而不是runlevels。默认情况下，有两个主要目标"><a href="#2-如何调整系统启动的运行级别？systemd使用’targets’而不是runlevels。默认情况下，有两个主要目标" class="headerlink" title="2.如何调整系统启动的运行级别？systemd使用’targets’而不是runlevels。默认情况下，有两个主要目标:"></a>2.如何调整系统启动的运行级别？systemd使用’targets’而不是runlevels。默认情况下，有两个主要目标:</h3><p>multi-user.target：类似于运行级别3<br>graphical.target： 类似于运行级别5</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#1.查看系统默认运行级别</span><br><span class="line">[root@student ~]# systemctl get-default</span><br><span class="line"></span><br><span class="line">#2.要设置默认目标，请运行</span><br><span class="line">[root@student ~]# systemctl set-default TARGET.target</span><br></pre></td></tr></table></figure><h2 id="3-Linux-systemd"><a href="#3-Linux-systemd" class="headerlink" title="3.Linux systemd"></a>3.Linux systemd</h2><h3 id="1-systemd的由来"><a href="#1-systemd的由来" class="headerlink" title="1.systemd的由来"></a>1.systemd的由来</h3><p>Linux一直以来都是采用init进程作为祖宗进程，但是init有两个缺点：<br>1、启动时间长。Init进程是串行启动，只有前一个进程启动完，才会启动下一个进程。<br>2、启动脚本复杂，初始化完成后系统会加载很多脚本，脚本都会处理各自的情况，这会让脚本多而复杂。<br>Centos5 是启动速度最慢的，串行启动过程，无论进程相互之间有无依赖关系。<br>Centos6 相对启动速度有所改进。有依赖的进程之间依次启动而其他与之没有依赖关系的则并行同步启动。<br>Centos7 所有进程无论有无依赖关系则都是并行启动（当然很多时候进程没有真正启动而是只有一个信号或者说是标记而已，在真正利用的时候才会真正启动。）<br><img src= "/img/loading.gif" data-src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ghu785l0iqj30jy0am3zu.jpg" alt="img"></p><h3 id="2-什么是systemd"><a href="#2-什么是systemd" class="headerlink" title="2.什么是systemd"></a>2.什么是systemd</h3><p>systemd即为system daemon守护进程，systemd主要解决上文的问题而诞生，systemd的目标是，为系统的启动和管理提供一套完整的解决方案。</p><h3 id="3-systemd的优势"><a href="#3-systemd的优势" class="headerlink" title="3.systemd的优势"></a>3.systemd的优势</h3><p>1、最新系统都采用systemd管理（RedHat7,CentOS7,Ubuntu15等）<br>2、Centos7支持开机并行启动服务，显著提高开机启动效率。<br>3、Centos7关机只关闭正在运行的服务，而Centos6全部都关闭一次。<br>4、Centos7服务的启动与停止不在使用脚本进行管理，也就是/etc/init.d下不在有脚本。<br>5、Centos7使用systemd解决原有模式缺陷，比如原有service不会关闭程序产生的子进程。</p><p>3.systemd相关配置文件<br>/usr/lib/systemd/system/ #类似Centos6系统的启动脚本，/etc/init.d/<br>/etc/systemd/system/ #类似Centos6系统的/etc/rc.d/rcN.d/<br>/etc/systemd/system/multi-user.target.wants/</p><p>4.systemd管理服务相关命令<br>systemctl管理服务的启动、重启、停止、重载、查看状态等常用命令</p><table><thead><tr><th>systemctl命令</th><th>作用</th></tr></thead><tbody><tr><td>systemctl start crond.service</td><td>启动服务</td></tr><tr><td>systemctl stop crond.service</td><td>停止服务</td></tr><tr><td>systemctl restart crond.service</td><td>重启服务</td></tr><tr><td>systemctl reload crond.service</td><td>重新加载配置</td></tr><tr><td>systemctl status crond.servre</td><td>查看服务运行状态</td></tr><tr><td>systemctl is-active sshd.service</td><td>查看服务是否在运行中</td></tr><tr><td>systemctl mask crond.servre</td><td>禁止服务运行</td></tr><tr><td>systemctl unmask crond.servre</td><td>取消禁止服务运行</td></tr></tbody></table><p>当我们使用systemctl启动一个守护进程后，可以通过sysytemctl status查看此守护进程的状态</p><table><thead><tr><th>状态</th><th>描述</th></tr></thead><tbody><tr><td>loaded</td><td>服务单元的配置文件已经被处理</td></tr><tr><td>active(running)</td><td>服务持续运行</td></tr><tr><td>active(exited)</td><td>服务成功完成一次的配置</td></tr><tr><td>active(waiting)</td><td>服务已经运行但在等待某个事件</td></tr><tr><td>inactive</td><td>服务没有在运行</td></tr><tr><td>enabled</td><td>服务设定为开机运行</td></tr><tr><td>disabled</td><td>服务设定为开机不运行</td></tr><tr><td>static</td><td>服务开机不启动，但可以被其他服务调用启动</td></tr></tbody></table><p>systemctl 设置服务开机启动、不启动、查看各级别下服务启动状态等常用命令</p><table><thead><tr><th>systemctl命令（7系统）</th><th>作用</th></tr></thead><tbody><tr><td>systemctl enable crond.service</td><td>开机自动启动</td></tr><tr><td>systemctl disable crond.service</td><td>开机不自动启动</td></tr><tr><td>systemctl list-unit-files</td><td>查看各个级别下服务的启动与禁用</td></tr><tr><td>systemctl is-enabled crond.service</td><td>查看特定服务是否为开机自启动</td></tr><tr><td>systemctl daemon-reload</td><td>创建新服务文件需要重载变更</td></tr></tbody></table><p>CentOS7系统, 管理员可以使用 systemctl 命令来管理服务器启动与停止</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#关机相关命令</span><br><span class="line">systemctl poweroff      #立即关机，常用</span><br><span class="line">#重启相关命令</span><br><span class="line">systemctl reboot        #重启命令，常用</span><br></pre></td></tr></table></figure><p>systemctl的journalctl日志</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">journalctl -n 20    #查看最后20行</span><br><span class="line">journalctl -f       #动态查看日志</span><br><span class="line">journalctl -p err   #查看日志的级别</span><br><span class="line">journalctl -u crond #查看某个服务的单元的日志</span><br></pre></td></tr></table></figure><h2 id="4-Linux单用户模式"><a href="#4-Linux单用户模式" class="headerlink" title="4.Linux单用户模式"></a>4.Linux单用户模式</h2><p>如何使用单用户模式进行变更系统密码？以Centos7系统为例：(Centos6破解方式请自行百度)</p><p>第1步：重启Linux系统主机并出现引导界面时，按下键盘上的e键进入内核编辑界面<br><img src= "/img/loading.gif" data-src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ghu78c0vtlj313o0liq5i.jpg" alt="img"><br>第2步：在linux16这行的后面添加<code>enforcing=0 init=/bin/bash</code>，然后按下Ctrl + X组合键来运行修改过的内核程序<br><img src= "/img/loading.gif" data-src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ghu78hpm7rj313o0l4445.jpg" alt="img">第3步：大约5秒过后，进入到系统的单用户模式，依次输入以下命令，等待系统重启操作完毕，然后就可以使用新密码来登录Linux系统了。命令行执行效果如图所示。<br><img src= "/img/loading.gif" data-src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ghu78m2qbcj31880b2ju5.jpg" alt="img"><br><a href="https://mp.weixin.qq.com/s/1f-zCq8j4gL3xiB3AV9K3A" target="_blank" rel="noopener">Centos7单用户破解密码更为详细版</a></p><h2 id="5-Linux下救援模式"><a href="#5-Linux下救援模式" class="headerlink" title="5.Linux下救援模式"></a>5.Linux下救援模式</h2><p>场景一：当系统坏了，无法登陆系统，但需要把里面的数据复制出来，怎么办？</p><p>步骤一、先挂载光盘，然后选择光盘引导为第一位<br><img src= "/img/loading.gif" data-src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ghu78q5klhj30zk0t0gsi.jpg" alt="img"><br>步骤二、进入故障排除模式–&gt;然后选择救援模式<br><img src= "/img/loading.gif" data-src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ghu78uscnyj30zk0t0jtr.jpg" alt="img"><br><img src= "/img/loading.gif" data-src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ghu78za1euj30zk0t0tce.jpg" alt="img"><br>步骤三、挂载真实系统后，发现数据都还存在<br><img src= "/img/loading.gif" data-src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ghu799c6qxj311e0u0n7x.jpg" alt="img"></p><p>场景二、修复MBR，主要出现在安装双系统时，后安装的系统把原来系统的MBR删除了，需要修复。</p><p>步骤一、破坏硬盘的前446字节，模拟MBR引号损坏，会发现重启无法启动系统</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@m01 ~]# dd if&#x3D;&#x2F;dev&#x2F;zero of&#x3D;&#x2F;dev&#x2F;sda bs&#x3D;1 count&#x3D;446</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ghu79ech5bj31400okaeh.jpg" alt="img"><br>步骤二、重启系统，然后按照之前的操作进入救援模式，然后分配一个shell终端，挂载真实的操作系统进行修复<br><img src= "/img/loading.gif" data-src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ghu79jsjmpj311e0u0qdo.jpg" alt="img"><br>步骤二、修复MBR引导，然后重启连接服务器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#1.使用grub修复</span><br><span class="line"># grub2-install &#x2F;dev&#x2F;sda</span><br><span class="line"></span><br><span class="line">#2.然后退出</span><br><span class="line"># exit</span><br><span class="line"></span><br><span class="line">#3.最后重启进入系统</span><br><span class="line"># reboot</span><br></pre></td></tr></table></figure><p>场景三、Centos7误删除grub文件如何进行修复。<br>步骤一、模拟误删故障</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#1.删除grub2 </span><br><span class="line">[root@m01 ~]# rm -rf  &#x2F;boot&#x2F;grub2 </span><br><span class="line">#2.重启计算机 </span><br><span class="line">[root@m01 ~]# reboot</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ghu79v2mrgj31400okmz3.jpg" alt="img"><br>步骤二、重启系统，然后按照之前的操作进入救援模式，然后分配一个shell终端，挂载真实的操作系统进行修复<br><img src= "/img/loading.gif" data-src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ghu7a4vrs6j311e0u07ez.jpg" alt="img"><br>步骤三、使用grub2-install、grub2-mkconfig恢复配置文件<br><img src= "/img/loading.gif" data-src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ghu7abz0x6j311e0u0n5f.jpg" alt="img"></p><p>PS: 最后别忘记修改 BIOS 引导，让硬盘回归到第一引导</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1-Linux启动流程&quot;&gt;&lt;a href=&quot;#1-Linux启动流程&quot; class=&quot;headerlink&quot; title=&quot;1.Linux启动流程&quot;&gt;&lt;/a&gt;1.Linux启动流程&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://www.runoob.com/li
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>13-Linux——进程管理</title>
    <link href="http://yoursite.com/2019/03/06/Linux%E2%80%94%E2%80%94%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/"/>
    <id>http://yoursite.com/2019/03/06/Linux%E2%80%94%E2%80%94%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/</id>
    <published>2019-03-06T13:50:40.000Z</published>
    <updated>2020-08-18T12:14:26.216Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-介绍"><a href="#1-介绍" class="headerlink" title="1.介绍"></a>1.介绍</h2><h3 id="1-什么是进程"><a href="#1-什么是进程" class="headerlink" title="1.什么是进程"></a>1.什么是进程</h3><p>比如: 开发写的代码我们称为程序，那么将开发的代码运行起来。我们称为进程。<br>总结一句话就是: 当我们运行一个程序，那么我们将运行的程序叫进程。<br>PS1: 当程序运行为进程后，系统会为该进程分配内存，以及进程运行的身份和权限。<br>PS2: 在进程运行的过程中，系统会有各种指标来表示当前运行的状态。</p><h3 id="2-程序和进程的区别"><a href="#2-程序和进程的区别" class="headerlink" title="2.程序和进程的区别"></a>2.程序和进程的区别</h3><p>1.程序是数据和指令的集合，是一个静态的概念。比如/bin/ls、/bin/cp等二进制文件。同时程序可以长期存在系统中。<br>2.进程是程序运行的过程，是一个动态的概念。进程是存在生命周期的概念的，也就是说进程会随着程序的终止而销毁，不会永久存在系统中。</p><h3 id="3-进程的生命周期"><a href="#3-进程的生命周期" class="headerlink" title="3.进程的生命周期"></a>3.进程的生命周期</h3><p>生命周期就是指一个对象的生老病死。用处很广。</p><p><img src= "/img/loading.gif" data-src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ghu76tkolgj310w0a20u5.jpg" alt="img"></p><p>当父进程接收到任务调度时，会通过fock派生子进程来处理，那么子进程会继承父进程属性。<br>1.子进程在处理任务代码时，父进程会进入等待状态中…<br>2.子进程在处理任务代码后，会执行退出，然后唤醒父进程来回收子进程的资源。<br>3.如果子进程在处理任务过程中，父进程退出了，子进程没有退出，那么这些子进程就没有父进程来管理了，就变成僵尸进程。<br>PS: 每个进程都父进程的PPID，子进程则叫PID。</p><p>例: 假设现在我是蒋先生(system进程)….故事持续中…..</p><h2 id="2-监控进程状态"><a href="#2-监控进程状态" class="headerlink" title="2.监控进程状态"></a>2.监控进程状态</h2><p>程序在运行后，我们需要了解进程的运行状态。查看进程的状态分为: 静态和动态两种方式</p><h3 id="1-使用ps命令查看当前的进程状态-静态"><a href="#1-使用ps命令查看当前的进程状态-静态" class="headerlink" title="1.使用ps命令查看当前的进程状态(静态)"></a>1.使用ps命令查看当前的进程状态(静态)</h3><p>1)示例、ps -aux常用组合，查看进程 用户、PID、占用cpu百分比、占用内存百分比、状态、执行的命令等</p><p><img src= "/img/loading.gif" data-src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ghu770thw2j31gq0p4n8c.jpg" alt="img"></p><table><thead><tr><th>状态</th><th>描述</th></tr></thead><tbody><tr><td>USER</td><td>启动进程的用户</td></tr><tr><td>PID</td><td>进程运行的ID号</td></tr><tr><td>%CPU</td><td>进程占用CPU百分比</td></tr><tr><td>%MEM</td><td>进程占用内存百分比</td></tr><tr><td>VSZ</td><td>进程占用虚拟内存大小 (单位KB)</td></tr><tr><td>RSS</td><td>进程占用物理内存实际大小 (单位KB)</td></tr><tr><td>TTY</td><td>进程是由哪个终端运行启动的tty1、pts/0等 ?表示内核程序与终端无关</td></tr><tr><td>STAT</td><td>进程运行过程中的状态 man ps （/STATE）</td></tr><tr><td>START</td><td>进程的启动时间</td></tr><tr><td>TIME</td><td>进程占用 CPU 的总时间(为0表示还没超过秒)</td></tr><tr><td>COMMAND</td><td>程序的运行指令，[ 方括号 ] 属于内核态的进程。 没有 [ ] 的是用户态进程。</td></tr></tbody></table><h3 id="2-STAT状态的S、Ss、S-、R、R、S-等等，都是什么意思"><a href="#2-STAT状态的S、Ss、S-、R、R、S-等等，都是什么意思" class="headerlink" title="2.STAT状态的S、Ss、S+、R、R、S+等等，都是什么意思?"></a>2.STAT状态的S、Ss、S+、R、R、S+等等，都是什么意思?</h3><p><img src= "/img/loading.gif" data-src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ghu779g9pgj31gq0p4am5.jpg" alt="img"></p><table><thead><tr><th>STAT基本状态</th><th>描述</th><th>STAT状态+符号</th><th>描述</th></tr></thead><tbody><tr><td>R</td><td>进程运行</td><td>s</td><td>进程是控制进程， Ss进程的领导者，父进程</td></tr><tr><td>S</td><td>可中断睡眠</td><td>&lt;</td><td>进程运行在高优先级上，S&lt;优先级较高的进程</td></tr><tr><td>T</td><td>进程被暂停</td><td>N</td><td>进程运行在低优先级上，SN优先级较低的进程</td></tr><tr><td>D</td><td>不可中断睡眠</td><td>+</td><td>当前进程运行在前台，R+该表示进程在前台运行</td></tr><tr><td>Z</td><td>僵尸进程</td><td>l</td><td>进程是多线程的，Sl表示进程是以线程方式运行</td></tr></tbody></table><p>案例一、PS命令查看进程状态切换</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">#1.在终端1上运行vim</span><br><span class="line">[root@lqz ~]# vim oldboy</span><br><span class="line"></span><br><span class="line">#2.在终端2上运行ps命令查看状态</span><br><span class="line">[root@lqz ~]# ps aux|grep oldboy    #S表示睡眠模式，+表示前台运行</span><br><span class="line">root      58118  0.4  0.2 151788  5320 pts&#x2F;1    S+   22:11   0:00 oldboy</span><br><span class="line">root      58120  0.0  0.0 112720   996 pts&#x2F;0    R+   22:12   0:00 grep --color&#x3D;auto oldboy</span><br><span class="line">#在终端1上挂起vim命令，按下：ctrl+z </span><br><span class="line"></span><br><span class="line">#3.回到终端2再次运行ps命令查看状态</span><br><span class="line">[root@lqz ~]# ps aux|grep oldboy    #T表示停止状态</span><br><span class="line">root      58118  0.1  0.2 151788  5320 pts&#x2F;1    T    22:11   0:00 vim oldboy</span><br><span class="line">root      58125  0.0  0.0 112720   996 pts&#x2F;0    R+   22:12   0:00 grep --color&#x3D;auto oldboy</span><br></pre></td></tr></table></figure><p>案例二、PS命令查看不可中断状态进程</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#1.使用tar打包文件时，可以通过终端不断查看状态，由S+，R+变为D+</span><br><span class="line">[root@lqz ~]# tar -czf etc.tar.gz &#x2F;etc&#x2F; &#x2F;usr&#x2F; &#x2F;var&#x2F;</span><br><span class="line"></span><br><span class="line">[root@lqz ~]# ps aux|grep tar|grep -v grep</span><br><span class="line">root      58467  5.5  0.2 127924  5456 pts&#x2F;1    R+   22:22   0:04 tar -czf etc.tar.gz &#x2F;etc&#x2F; </span><br><span class="line">[root@lqz ~]# ps aux|grep tar|grep -v grep</span><br><span class="line">root      58467  5.5  0.2 127088  4708 pts&#x2F;1    S+   22:22   0:03 tar -czf etc.tar.gz &#x2F;etc&#x2F; </span><br><span class="line">[root@lqz ~]# ps aux|grep tar|grep -v grep</span><br><span class="line">root      58467  5.6  0.2 127232  4708 pts&#x2F;1    D+   22:22   0:03 tar -czf etc.tar.gz &#x2F;etc&#x2F;</span><br></pre></td></tr></table></figure><h3 id="2-使用top命令查看当前的进程状态-动态"><a href="#2-使用top命令查看当前的进程状态-动态" class="headerlink" title="2.使用top命令查看当前的进程状态(动态)"></a>2.使用top命令查看当前的进程状态(动态)</h3><p><img src= "/img/loading.gif" data-src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ghu77gow7kj31ea0mcdrs.jpg" alt="img"></p><table><thead><tr><th>任务</th><th>含义</th></tr></thead><tbody><tr><td>Tasks: 129 total</td><td>当然进程的总数</td></tr><tr><td>1 running</td><td>正在运行的进程数</td></tr><tr><td>128 sleeping</td><td>睡眠的进程数</td></tr><tr><td>0 stopped</td><td>停止的进程数</td></tr><tr><td>0 zombie</td><td>僵尸进程数</td></tr><tr><td>%Cpu(s): 0.7 us</td><td>系统用户进程使用CPU百分比</td></tr><tr><td>0.7 sy</td><td>内核中的进程占用CPU百分比，通常内核是于硬件进行交互</td></tr><tr><td>98.7 id</td><td>空闲CPU的百分比</td></tr><tr><td>0.0 wa</td><td>CPU等待IO完成的时间</td></tr><tr><td>0.0 hi</td><td>硬中断，占的CPU百分比</td></tr><tr><td>0.0 si</td><td>软中断，占的CPU百分比</td></tr><tr><td>0.0 st</td><td>比如虚拟机占用物理CPU的时间</td></tr></tbody></table><p><a href="https://www.cnblogs.com/lqz/p/10789270.html" target="_blank" rel="noopener">PS: 如何理解中断这个东西</a></p><p>top 常见指令</p><table><thead><tr><th>字母</th><th>含义</th></tr></thead><tbody><tr><td>h</td><td>查看帮出</td></tr><tr><td>1</td><td>数字1，显示所有CPU核心的负载</td></tr><tr><td>z</td><td>以高亮显示数据</td></tr><tr><td>b</td><td>高亮显示处于R状态的进程</td></tr><tr><td>M</td><td>按内存使用百分比排序输出</td></tr><tr><td>P</td><td>按CPU使用百分比排序输出</td></tr><tr><td>q</td><td>退出top</td></tr></tbody></table><h2 id="3-管理进程状态"><a href="#3-管理进程状态" class="headerlink" title="3.管理进程状态"></a>3.管理进程状态</h2><p>当程序运行为进程后，如果希望停止进程，怎么办呢? 那么此时我们可以使用linux的kill命令对进程发送关闭信号。当然除了kill、还有killall，pkill</p><h3 id="1-使用kill-l列出当前系统所支持的信号"><a href="#1-使用kill-l列出当前系统所支持的信号" class="headerlink" title="1.使用kill -l列出当前系统所支持的信号"></a>1.使用kill -l列出当前系统所支持的信号</h3><p><img src= "/img/loading.gif" data-src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ghu77namunj31ea0mcqfj.jpg" alt="img"><br>虽然linux支持信号很多，但是我们仅列出我们最为常用的3个信号</p><table><thead><tr><th>数字编号</th><th>信号含义</th><th>信号翻译</th></tr></thead><tbody><tr><td>1</td><td>SIGHUP</td><td>通常用来重新加载配置文件</td></tr><tr><td>9</td><td>SIGKILL</td><td>强制杀死进程</td></tr><tr><td>15</td><td>SIGTERM</td><td>终止进程，默认kill使用该信号</td></tr></tbody></table><p>1.我们使用kill命令杀死指定PID的进程。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">#1.给 vsftpd 进程发送信号 1,15</span><br><span class="line">[root@lqz ~]# yum -y install vsftpd</span><br><span class="line">[root@lqz ~]# systemctl start vsftpd</span><br><span class="line">[root@lqz ~]# ps aux|grep vsftpd</span><br><span class="line"></span><br><span class="line">#2.发送重载信号，例如 vsftpd 的配置文件发生改变，希望重新加载</span><br><span class="line">[root@lqz ~]# kill -1 9160</span><br><span class="line"></span><br><span class="line">#3.发送停止信号，当然vsftpd 服务有停止的脚本 systemctl stop vsftpd</span><br><span class="line">[root@lqz ~]# kill 9160</span><br><span class="line"></span><br><span class="line">#4.发送强制停止信号，当无法停止服务时，可强制终止信号</span><br><span class="line">[root@lqz ~]# kill -9 9160</span><br></pre></td></tr></table></figure><p>2.Linux系统中的killall、pkill命令用于杀死指定名字的进程。我们可以使用kill命令杀死指定进程PID的进程，如果要找到我们需要杀死的进程，我们还需要在之前使用ps等命令再配合grep来查找进程，而killall、pkill把这两个过程合二为一，是一个很好用的命令。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#例1、通过服务名称杀掉进程</span><br><span class="line">[root@lqz ~]# pkill nginx</span><br><span class="line">[root@lqz ~]# killall nginx</span><br><span class="line"></span><br><span class="line">#例2、使用pkill踢出从远程登录到本机的用户，终止pts&#x2F;0上所有进程, 并且bash也结束（用户被强制退出）</span><br><span class="line">[root@lqz ~]# pkill -9 -t pts&#x2F;0</span><br></pre></td></tr></table></figure><h2 id="4-管理后台进程"><a href="#4-管理后台进程" class="headerlink" title="4.管理后台进程"></a>4.管理后台进程</h2><h3 id="1-什么是后台进程"><a href="#1-什么是后台进程" class="headerlink" title="1.什么是后台进程"></a>1.什么是后台进程</h3><p>通常进程都会在终端前台运行，一旦关闭终端，进程也会随着结束，那么此时我们就希望进程能在后台运行，就是将在前台运行的进程放入后台运行，这样及时我们关闭了终端也不影响进程的正常运行。</p><h3 id="2-我们为什么要将进程放入后台运行"><a href="#2-我们为什么要将进程放入后台运行" class="headerlink" title="2.我们为什么要将进程放入后台运行"></a>2.我们为什么要将进程放入后台运行</h3><p>比如：我们此前在国内服务器往国外服务器传输大文件时，由于网络的问题需要传输很久，如果在传输的过程中出现网络抖动或者不小心关闭了终端则会导致传输失败，如果能将传输的进程放入后台，是不是就能解决此类问题了。</p><h3 id="3-使用什么工具将进程放入后台"><a href="#3-使用什么工具将进程放入后台" class="headerlink" title="3.使用什么工具将进程放入后台"></a>3.使用什么工具将进程放入后台</h3><p>早期的时候大家都选择使用&amp;符号将进程放入后台，然后在使用jobs、bg、fg等方式查看进程状态，但太麻烦了。也不直观，所以我们推荐使用screen。</p><p>1.jobs、bg、fg的使用(强烈不推荐，了解即可)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[root@lqz ~]# sleep 3000 &amp; &#x2F;&#x2F;运行程序(时)，让其在后台执行 </span><br><span class="line">[root@lqz ~]# sleep 4000 &#x2F;&#x2F;^Z,将前台的程序挂起(暂停)到后台 </span><br><span class="line">[2]+ Stopped sleep 4000</span><br><span class="line">[root@lqz ~]# ps aux |grep sleep</span><br><span class="line">[root@lqz ~]# jobs  &#x2F;&#x2F;查看后台作业</span><br><span class="line">[1]- Running sleep 3000 &amp; </span><br><span class="line">[2]+ Stopped sleep 4000</span><br><span class="line"></span><br><span class="line">[root@lqz ~]# bg %2     &#x2F;&#x2F;让作业 2 在后台运行</span><br><span class="line">[root@lqz ~]# fg %1     &#x2F;&#x2F;将作业 1 调回到前台</span><br><span class="line">[root@lqz ~]# kill %1   &#x2F;&#x2F;kill 1，终止 PID 为 1 的进程</span><br><span class="line"></span><br><span class="line">[root@lqz ~]# (while :; do date; sleep 2; done) &amp; &#x2F;&#x2F;进程在后台运行，但输出依然在当前终端</span><br><span class="line">[root@lqz ~]# (while :; do date; sleep 2; done) &amp;&gt;&#x2F;dev&#x2F;null &amp;</span><br></pre></td></tr></table></figure><p>2.screen的使用(强烈推荐，生产必用)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">#1.安装</span><br><span class="line">[root@oldboy ~]# yum install screen -y</span><br><span class="line"></span><br><span class="line">#2.开启一个screen窗口,指定名称</span><br><span class="line">[root@oldboy ~]# screen -S wget_mysql</span><br><span class="line"></span><br><span class="line">#3.在screen窗口中执行任务即可</span><br><span class="line"></span><br><span class="line">#4.平滑的退出screen,但不会终止screen中的任务。注意: 如果使用exit 才算真的关闭screen窗口</span><br><span class="line">ctrl+a+d</span><br><span class="line"></span><br><span class="line">#5.查看当前正在运行的screen有哪些</span><br><span class="line">[root@oldboy ~]# screen -list</span><br><span class="line">There is a screen on:</span><br><span class="line">    22058.wget_mysql    (Detached)</span><br><span class="line">1 Socket in &#x2F;var&#x2F;run&#x2F;screen&#x2F;S-root.</span><br><span class="line"></span><br><span class="line">#6.进入正在运行的screen</span><br><span class="line">[root@oldboy ~]# screen -r wget_mysql</span><br><span class="line">[root@oldboy ~]# screen -r 22058</span><br></pre></td></tr></table></figure><h2 id="5-进程的优先级-进阶"><a href="#5-进程的优先级-进阶" class="headerlink" title="5.进程的优先级[进阶]"></a>5.进程的优先级[进阶]</h2><h3 id="1-什么优先级"><a href="#1-什么优先级" class="headerlink" title="1.什么优先级"></a>1.什么优先级</h3><p>优先级指的是优先享受资源，比如排队买票时，军人优先、老人优先。等等</p><h3 id="2-为什么要有系统优先级"><a href="#2-为什么要有系统优先级" class="headerlink" title="2.为什么要有系统优先级"></a>2.为什么要有系统优先级</h3><p>举个例子: 海底捞火锅正常情况下响应就特别快，那么当节假日来临时人员突增则会导致处理请求特别慢，那么假设我是海底捞VIP客户(最高优先级)，无论门店多么繁忙，我都不用排队，海底捞人员会直接服务于我，满足我的需求。至于没有VIP的人员(较低优先级)则进入排队等待状态。(PS: 至于等多久，那…..)</p><h3 id="3-系统中如何给进程配置优先级"><a href="#3-系统中如何给进程配置优先级" class="headerlink" title="3.系统中如何给进程配置优先级?"></a>3.系统中如何给进程配置优先级?</h3><p>在启动进程时，为不同的进程使用不同的调度策略。<br>nice 值越高： 表示优先级越低，例如+19，该进程容易将CPU 使用量让给其他进程。<br>nice 值越低： 表示优先级越高，例如-20，该进程更不倾向于让出CPU。</p><p>1) 使用top或ps命令查看进程的优先级</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#1.使用top可以查看nice优先级。  NI: 实际nice级别，默认是0。 PR: 显示nice值，-20映射到0，+19映射到39</span><br><span class="line">PID USER      PR  NI    VIRT    RES    SHR S %CPU %MEM     TIME+ COMMAND</span><br><span class="line">1083 root      20   0  298628   2808   1544 S  0.3  0.1   2:49.28 vmtoolsd</span><br><span class="line">5    root       0 -20       0      0      0 S  0.0  0.0   0:00.00 kworker&#x2F;0:+</span><br><span class="line"></span><br><span class="line">#2.使用ps查看进程优先级</span><br><span class="line">[root@m01 ~]# ps axo command,nice |grep sshd|grep -v grep</span><br><span class="line">&#x2F;usr&#x2F;sbin&#x2F;sshd -D             0</span><br><span class="line">sshd: root@pts&#x2F;2              0</span><br></pre></td></tr></table></figure><p>2) nice指定程序的优先级。语法格式 nice -n 优先级数字 进程名称</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#1.开启vim并且指定程序优先级为-5</span><br><span class="line">[root@m01 ~]# nice -n -5 vim &amp;</span><br><span class="line">[1] 98417</span><br><span class="line"></span><br><span class="line">#2.查看该进程的优先级情况</span><br><span class="line">[root@m01 ~]# ps axo pid,command,nice |grep 98417</span><br><span class="line"> 98417 vim                         -5</span><br></pre></td></tr></table></figure><p>3) renice命令修改一个正在运行的进程优先级。语法格式 renice -n 优先级数字 进程pid</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">#1.查看sshd进程当前的优先级状态</span><br><span class="line">[root@m01 ~]# ps axo pid,command,nice |grep 折叠shd</span><br><span class="line"> 70840 sshd: root@pts&#x2F;2              0</span><br><span class="line"> 98002 &#x2F;usr&#x2F;sbin&#x2F;sshd -D             0</span><br><span class="line"> </span><br><span class="line">#2.调整sshd主进程的优先级</span><br><span class="line">[root@m01 ~]# renice -n -20 98002</span><br><span class="line">98002 (process ID) old priority 0, new priority -20</span><br><span class="line"></span><br><span class="line">#3.调整之后记得退出终端</span><br><span class="line">[root@m01 ~]# ps axo pid,command,nice |grep 折叠shd</span><br><span class="line"> 70840 sshd: root@pts&#x2F;2              0</span><br><span class="line"> 98002 &#x2F;usr&#x2F;sbin&#x2F;sshd -D           -20</span><br><span class="line">[root@m01 ~]# exit</span><br><span class="line"></span><br><span class="line">#4.当再次登陆sshd服务，会由主进程fork子进程(那么子进程会继承主进程的优先级)</span><br><span class="line">[root@m01 ~]# ps axo pid,command,nice |grep 折叠shd</span><br><span class="line"> 98002 &#x2F;usr&#x2F;sbin&#x2F;sshd -D           -20</span><br><span class="line"> 98122 sshd: root@pts&#x2F;0            -20</span><br></pre></td></tr></table></figure><p><a href="https://www.xuliangwei.com/bgx/1337.html" target="_blank" rel="noopener">生产案例、Linux出现假死，怎么办，又如何通过nice解决？</a></p><h2 id="6-系统平均负载-进阶"><a href="#6-系统平均负载-进阶" class="headerlink" title="6.系统平均负载[进阶]"></a>6.系统平均负载[进阶]</h2><p>每次发现系统变慢时，我们通常做的第一件事，就是执行 top 或者 uptime 命令，来了解系统的负载情况。比如像下面这样，我在命令行里输入了 uptime 命令，系统也随即给出了结果。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@m01 ~]# uptime</span><br><span class="line"> 04:49:26 up 2 days,  2:33,  2 users,  load average: 0.70, 0.04, 0.05</span><br><span class="line">#我们已经比较熟悉前面几列，它们分别是当前时间、系统运行时间以及正在登录用户数。</span><br><span class="line"></span><br><span class="line"># 而最后三个数字呢，依次则是过去 1 分钟、5 分钟、15 分钟的平均负载（Load Average）。</span><br></pre></td></tr></table></figure><h3 id="1-什么是平均负载"><a href="#1-什么是平均负载" class="headerlink" title="1.什么是平均负载"></a>1.什么是平均负载</h3><p>平均负载不就是单位时间内的 CPU 使用率吗？上面的 0.70，就代表 CPU 使用率是 70%。其实上并…..<br>那到底如何理解平均负载: 平均负载是指单位时间内，系统处于可运行状态和不可中断状态的平均进程数，也就是平均活跃进程数， PS: 平均负载与 CPU 使用率并没有直接关系。</p><h3 id="2-可运行状态和不可中断状态是什么"><a href="#2-可运行状态和不可中断状态是什么" class="headerlink" title="2.可运行状态和不可中断状态是什么"></a>2.可运行状态和不可中断状态是什么</h3><p>1.可运行状态进程，是指正在使用 CPU 或者正在等待 CPU 的进程，也就是我们ps 命令看到处于 R 状态的进程。<br>2.不可中断进程，(你做什么事情的时候是不能打断的?) 系统中最常见的是等待硬件设备的 I/O 响应，也就是我们 ps 命令中看到的 D 状态（也称为 Disk Sleep）的进程。<br>例如: 当一个进程向磁盘读写数据时，为了保证数据的一致性，在得到磁盘回复前，它是不能被其他进程或者中断打断的，这个时候的进程就处于不可中断状态。如果此时的进程被打断了，就容易出现磁盘数据与进程数据不一致的问题。所以，不可中断状态实际上是系统对进程和硬件设备的一种保护机制。</p><p>划重点，因此你可以简单理解为，平均负载其实就是单位时间内的活跃进程数。</p><h3 id="3-那平均负载为多少时合理"><a href="#3-那平均负载为多少时合理" class="headerlink" title="3.那平均负载为多少时合理"></a>3.那平均负载为多少时合理</h3><p>最理想的状态是每个 CPU 上都刚好运行着一个进程，这样每个 CPU 都得到了充分利用。所以在评判平均负载时，首先你要知道系统有几个 CPU，这可以通过 top 命令获取，或<code>grep &#39;model name&#39; /proc/cpuinfo</code></p><p>例1、假设现在在 4、2、1核的CPU上，如果平均负载为 2 时，意味着什么呢？<br>Q1.在4 个 CPU 的系统上，意味着 CPU 有 50% 的空闲。<br>Q2.在2 个 CPU 的系统上，意味着所有的 CPU 都刚好被完全占用。<br>Q3.而1 个 CPU 的系统上，则意味着有一半的进程竞争不到 CPU。</p><p>PS: 平均负载有三个数值，我们应该关注哪个呢?<br>实际上，我们都需要关注。就好比上海4月的天气，如果只看晚上天气，感觉在过冬天呢。但如果你结合了早上、中午、晚上三个时间点的温度来看，基本就可以全方位了解这一天的天气情况了。</p><p>1.如果 1 分钟、5 分钟、15 分钟的三个值基本相同，或者相差不大，那就说明系统负载很平稳。<br>2.但如果 1 分钟的值远小于 15 分钟的值，就说明系统最近 1 分钟的负载在减少，而过去 15 分钟内却有很大的负载。<br>3.反过来，如果 1 分钟的值远大于 15 分钟的值，就说明最近 1 分钟的负载在增加，这种增加有可能只是临时性的，也有可能还会持续上升，所以就需要持续观察。<br>PS: 一旦 1 分钟的平均负载接近或超过了 CPU 的个数，就意味着系统正在发生过载的问题，这时就得分析问题，并要想办法优化了</p><p>在来看个例子3、假设我们在有2个 CPU 系统上看到平均负载为 2.73，6.90，12.98<br>那么说明在过去1 分钟内，系统有 136% 的超载 (2.73/2=136%)<br>而在过去 5 分钟内，有 345% 的超载 (6.90/2=345%)<br>而在过去15 分钟内，有 649% 的超载，(12.98/2=649%)<br>但从整体趋势来看，系统的负载是在逐步的降低。</p><h3 id="4-那么在实际生产环境中，平均负载多高时，需要我们重点关注呢？"><a href="#4-那么在实际生产环境中，平均负载多高时，需要我们重点关注呢？" class="headerlink" title="4.那么在实际生产环境中，平均负载多高时，需要我们重点关注呢？"></a>4.那么在实际生产环境中，平均负载多高时，需要我们重点关注呢？</h3><p>当平均负载高于 CPU 数量 70% 的时候，你就应该分析排查负载高的问题了。一旦负载过高，就可能导致进程响应变慢，进而影响服务的正常功能。<br>但 70% 这个数字并不是绝对的，最推荐的方法，还是把系统的平均负载监控起来，然后根据更多的历史数据，判断负载的变化趋势。当发现负载有明显升高趋势时，比如说负载翻倍了，你再去做分析和调查。</p><h3 id="5-平均负载与-CPU-使用率有什么关系"><a href="#5-平均负载与-CPU-使用率有什么关系" class="headerlink" title="5.平均负载与 CPU 使用率有什么关系"></a>5.平均负载与 CPU 使用率有什么关系</h3><p>在实际工作中，我们经常容易把平均负载和 CPU 使用率混淆，所以在这里，我也做一个区分。可能你会疑惑，既然平均负载代表的是活跃进程数，那平均负载高了，不就意味着 CPU 使用率高吗？<br>我们还是要回到平均负载的含义上来，平均负载是指单位时间内，处于可运行状态和不可中断状态的进程数。所以，它不仅包括了正在使用 CPU 的进程，还包括等待 CPU 和等待 I/O 的进程。</p><p>而 CPU 使用率，是单位时间内 CPU 繁忙情况的统计，跟平均负载并不一定完全对应。比如：<br>CPU 密集型进程，使用大量 CPU 会导致平均负载升高，此时这两者是一致的；<br>I/O 密集型进程，等待 I/O 也会导致平均负载升高，但 CPU 使用率不一定很高；<br>大量等待 CPU 的进程调度也会导致平均负载升高，此时的 CPU 使用率也会比较高。</p><h3 id="6-平均负载案例分析实战"><a href="#6-平均负载案例分析实战" class="headerlink" title="6.平均负载案例分析实战"></a>6.平均负载案例分析实战</h3><p>下面，我们以三个示例分别来看这三种情况，并用 stress、mpstat、pidstat 等工具，找出平均负载升高的根源。<br>stress 是 Linux 系统压力测试工具，这里我们用作异常进程模拟平均负载升高的场景。<br>mpstat 是多核 CPU 性能分析工具，用来实时查看每个 CPU 的性能指标，以及所有 CPU 的平均指标。<br>pidstat 是一个常用的进程性能分析工具，用来实时查看进程的 CPU、内存、I/O 以及上下文切换等性能指标。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#如果出现无法使用mpstat、pidstat命令查看%wait指标建议更新下软件包</span><br><span class="line">wget http:&#x2F;&#x2F;pagesperso-orange.fr&#x2F;sebastien.godard&#x2F;sysstat-11.7.3-1.x86_64.rpm</span><br><span class="line">rpm -Uvh sysstat-11.7.3-1.x86_64.rpm</span><br></pre></td></tr></table></figure><p>场景一：CPU 密集型进程</p><p>1.首先，我们在第一个终端运行 stress 命令，模拟一个 CPU 使用率 100% 的场景：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@m01 ~]# stress --cpu 1 --timeout 600</span><br></pre></td></tr></table></figure><p>2.接着，在第二个终端运行 uptime 查看平均负载的变化情况</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 使用watch -d 参数表示高亮显示变化的区域(注意负载会持续升高)</span><br><span class="line">[root@m01 ~]# watch -d uptime</span><br><span class="line">17:27:44 up 2 days,  3:11,  3 users,  load average: 1.10, 0.30, 0.17</span><br></pre></td></tr></table></figure><p>3.最后，在第三个终端运行 mpstat 查看 CPU 使用率的变化情况</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># -P ALL 表示监控所有 CPU，后面数字 5 表示间隔 5 秒后输出一组数据</span><br><span class="line">[root@m01 ~]# mpstat -P ALL 5</span><br><span class="line">Linux 3.10.0-957.1.3.el7.x86_64 (m01)   2019年04月29日     _x86_64_    (1 CPU)</span><br><span class="line"></span><br><span class="line">17时32分03秒  CPU    %usr   %nice    %sys %iowait    %irq   %soft  %steal  %guest  %gnice   %idle</span><br><span class="line">17时32分08秒  all   99.80    0.00    0.20    0.00    0.00    0.00    0.00    0.00    0.00    0.00</span><br><span class="line">17时32分08秒    0   99.80    0.00    0.20    0.00    0.00    0.00    0.00    0.00    0.00    0.00</span><br><span class="line"></span><br><span class="line">#单核CPU所以只有一个all和0</span><br></pre></td></tr></table></figure><p>4.从终端二中可以看到，1 分钟的平均负载会慢慢增加到 1.00，而从终端三中还可以看到，正好有一个 CPU 的使用率为 100%，但它的 iowait 只有 0。这说明，平均负载的升高正是由于 CPU 使用率为 100% 。那么，到底是哪个进程导致了 CPU 使用率为 100% 呢？可以使用 pidstat 来查询</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 间隔 5 秒后输出一组数据</span><br><span class="line">[root@m01 ~]# pidstat -u 5 1</span><br><span class="line">Linux 3.10.0-957.1.3.el7.x86_64 (m01)   2019年04月29日     _x86_64_(1 CPU)</span><br><span class="line"></span><br><span class="line">17时33分21秒   UID       PID    %usr %system  %guest    %CPU   CPU  Command</span><br><span class="line">17时33分26秒     0    110019   98.80    0.00    0.00   98.80     0  stress</span><br><span class="line"></span><br><span class="line">#从这里可以明显看到，stress 进程的 CPU 使用率为 100%。</span><br></pre></td></tr></table></figure><p>场景二：I/O 密集型进程</p><p>1.首先还是运行 stress 命令，但这次模拟 I/O 压力，即不停地执行 sync</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@m01 ~]# stress  --io 1 --timeout 600s</span><br></pre></td></tr></table></figure><p>2.然后在第二个终端运行 uptime 查看平均负载的变化情况：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@m01 ~]# watch -d uptime</span><br><span class="line">18:43:51 up 2 days,  4:27,  3 users,  load average: 1.12, 0.65, 0.00</span><br></pre></td></tr></table></figure><p>3.最后第三个终端运行 mpstat 查看 CPU 使用率的变化情况：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># 显示所有 CPU 的指标，并在间隔 5 秒输出一组数据</span><br><span class="line">[root@m01 ~]# mpstat -P ALL 5</span><br><span class="line">Linux 3.10.0-693.2.2.el7.x86_64 (bgx.com)   2019年05月07日     _x86_64_    (1 CPU)</span><br><span class="line"></span><br><span class="line">14时20分07秒  CPU    %usr   %nice    %sys %iowait    %irq   %soft  %steal  %guest  %gnice   %idle</span><br><span class="line">14时20分12秒  all    0.20    0.00   82.45   17.35    0.00    0.00    0.00    0.00    0.00    0.00</span><br><span class="line">14时20分12秒    0    0.20    0.00   82.45   17.35    0.00    0.00    0.00    0.00    0.00    0.00</span><br><span class="line"></span><br><span class="line">#会发现cpu的与内核打交道的sys占用非常高</span><br></pre></td></tr></table></figure><p>4.那么到底是哪个进程，导致 iowait 这么高呢？我们还是用 pidstat 来查询</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># 间隔 5 秒后输出一组数据，-u 表示 CPU 指标</span><br><span class="line">[root@m01 ~]# pidstat -u 5 1</span><br><span class="line">Linux 3.10.0-957.1.3.el7.x86_64 (m01)   2019年04月29日     _x86_64_(1 CPU)</span><br><span class="line">18时29分37秒   UID       PID    %usr %system  %guest   %wait    %CPU   CPU  Command</span><br><span class="line">18时29分42秒     0    127259   32.60    0.20    0.00   67.20   32.80     0  stress</span><br><span class="line">18时29分42秒     0    127261    4.60   28.20    0.00   67.20   32.80     0  stress</span><br><span class="line">18时29分42秒     0    127262    4.20   28.60    0.00   67.20   32.80     0  stress</span><br><span class="line"></span><br><span class="line">#可以发现，还是 stress 进程导致的。</span><br></pre></td></tr></table></figure><p>场景三：大量进程的场景<br>当系统中运行进程超出 CPU 运行能力时，就会出现等待 CPU 的进程。</p><p>1.首先，我们还是使用 stress，但这次模拟的是 4 个进程</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@m01 ~]# stress -c 4 --timeout 600</span><br></pre></td></tr></table></figure><p>2.由于系统只有 1 个 CPU，明显比 4 个进程要少得多，因而，系统的 CPU 处于严重过载状态</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@m01 ~]# watch -d uptime</span><br><span class="line">19:11:07 up 2 days,  4:45,  3 users,  load average: 4.65, 2.65, 4.65</span><br></pre></td></tr></table></figure><p>3.然后，再运行 pidstat 来看一下进程的情况：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># 间隔 5 秒后输出一组数据</span><br><span class="line">[root@m01 ~]# pidstat -u 5 1</span><br><span class="line">平均时间:   UID       PID    %usr %system  %guest   %wait    %CPU   CPU  Command</span><br><span class="line">平均时间:     0    130290   24.55    0.00    0.00   75.25   24.55     -  stress</span><br><span class="line">平均时间:     0    130291   24.95    0.00    0.00   75.25   24.95     -  stress</span><br><span class="line">平均时间:     0    130292   24.95    0.00    0.00   75.25   24.95     -  stress</span><br><span class="line">平均时间:     0    130293   24.75    0.00    0.00   74.65   24.75     -  stress</span><br></pre></td></tr></table></figure><p>可以看出，4 个进程在争抢 1 个 CPU，每个进程等待 CPU 的时间（也就是代码块中的 %wait 列）高达 75%。这些超出 CPU 计算能力的进程，最终导致 CPU 过载。</p><p>分析完这三个案例，我再来归纳一下平均负载与CPU<br>平均负载提供了一个快速查看系统整体性能的手段，反映了整体的负载情况。但只看平均负载本身，我们并不能直接发现，到底是哪里出现了瓶颈。所以，在理解平均负载时，也要注意：<br>平均负载高有可能是 CPU 密集型进程导致的；<br>平均负载高并不一定代表 CPU 使用率高，还有可能是 I/O 更繁忙了；<br>当发现负载高的时候，你可以使用 mpstat、pidstat 等工具，辅助分析负载的来源</p><p><a href="https://www.cnblogs.com/muahao/p/6346775.html" target="_blank" rel="noopener">stress工具使用参考</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1-介绍&quot;&gt;&lt;a href=&quot;#1-介绍&quot; class=&quot;headerlink&quot; title=&quot;1.介绍&quot;&gt;&lt;/a&gt;1.介绍&lt;/h2&gt;&lt;h3 id=&quot;1-什么是进程&quot;&gt;&lt;a href=&quot;#1-什么是进程&quot; class=&quot;headerlink&quot; title=&quot;1.什
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>12-Linux——软件管理</title>
    <link href="http://yoursite.com/2019/03/04/Linux%E2%80%94%E2%80%94%E8%BD%AF%E4%BB%B6%E7%AE%A1%E7%90%86/"/>
    <id>http://yoursite.com/2019/03/04/Linux%E2%80%94%E2%80%94%E8%BD%AF%E4%BB%B6%E7%AE%A1%E7%90%86/</id>
    <published>2019-03-04T14:10:22.000Z</published>
    <updated>2020-08-18T12:14:04.195Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-RPM基本概述"><a href="#1-RPM基本概述" class="headerlink" title="1.RPM基本概述"></a>1.RPM基本概述</h2><h3 id="1-什么是rpm"><a href="#1-什么是rpm" class="headerlink" title="1.什么是rpm?"></a>1.什么是rpm?</h3><p>RPM全称 RPM Package Manager 缩写，由红帽开发用于软件包的安装升级卸载与查询</p><h3 id="2-rpm包名组成部分"><a href="#2-rpm包名组成部分" class="headerlink" title="2.rpm包名组成部分?"></a>2.rpm包名组成部分?</h3><p>RPM包命名以-将软件分成了若干部分<code>bash-4.2.46-28.el7.x86_64.rpm</code><br><img src= "/img/loading.gif" data-src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ghu71lrwt0j30qy07cq50.jpg" alt="img"></p><h3 id="3-如何获取rpm包"><a href="#3-如何获取rpm包" class="headerlink" title="3.如何获取rpm包"></a>3.如何获取rpm包</h3><p>在我们刚开始学习rpm包，建议先使用本地CentOS7的镜像，但实际生产环境中都是通过联网的方式获取rpm包。（先学会，你懂的？）<br>我们先通过虚拟机加载镜像，然后在linux中执行 <code>mount /dev/cdrom /mnt</code>，此时你会在<code>/mnt/Packages</code>目录下看到很多rpm的包文件。那么就可以开始rpm包管理之旅。</p><h3 id="4-扩展-Linux中除了rpm安装软件，是否还有安装软件方式"><a href="#4-扩展-Linux中除了rpm安装软件，是否还有安装软件方式" class="headerlink" title="4.扩展: Linux中除了rpm安装软件，是否还有安装软件方式?"></a>4.扩展: Linux中除了rpm安装软件，是否还有安装软件方式?</h3><table><thead><tr><th>分类</th><th>安装</th><th>版本</th></tr></thead><tbody><tr><td>rpm包</td><td>预先编译打包,安装简单</td><td>软件版本偏低</td></tr><tr><td>源码包</td><td>手动编译打包,安装繁琐</td><td>软件版本随意</td></tr><tr><td>二进制包</td><td>解压即可使用, 安装简单</td><td>不能修改源码</td></tr></tbody></table><h2 id="2-RPM使用示例"><a href="#2-RPM使用示例" class="headerlink" title="2.RPM使用示例"></a>2.RPM使用示例</h2><h3 id="1-rpm包如何安装"><a href="#1-rpm包如何安装" class="headerlink" title="1.rpm包如何安装"></a>1.rpm包如何安装</h3><p>以下列出了rpm命令进行安装软件的常用参数</p><table><thead><tr><th>选项</th><th>描述</th></tr></thead><tbody><tr><td>-i</td><td>安装rpm</td></tr><tr><td>-v</td><td>显示安装详细信息</td></tr><tr><td>-h</td><td>显示安装rpm进度</td></tr><tr><td>–force</td><td>强制重新安装</td></tr><tr><td>–nodeps</td><td>忽略依赖关系</td></tr></tbody></table><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">#安装软件包, 需要指定软件包绝对路径</span><br><span class="line">[root@lqz ~]# rpm -ivh &#x2F;mnt&#x2F;Packages&#x2F;tree-1.6.0-10.el7.x86_64.rpm</span><br><span class="line">[root@lqz ~]# rpm -ivh &#x2F;mnt&#x2F;Packages&#x2F;vsftpd-3.0.2-22.el7.x86_64.rpm</span><br><span class="line"></span><br><span class="line">#在软件包所在目录下可以不指定绝对路径</span><br><span class="line">[root@lqz ~]# cd &#x2F;mnt&#x2F;Packages&#x2F;</span><br><span class="line">[root@lqz Packages]# rpm -ivh zsh-5.0.2-28.el7.x86_64.rpm</span><br><span class="line"></span><br><span class="line">#如果软件包存在, 强制再次安装</span><br><span class="line">[root@lqz ~]# rpm -ivh --force &#x2F;mnt&#x2F;Packages&#x2F;tree-1.5.3-3.el6.x86_64.rpm</span><br><span class="line"></span><br><span class="line">#安装samba服务需要依赖其他组件, 使用--nodeps可重新强制安装</span><br><span class="line">[root@lqz ~]# rpm -ivh --nodeps  &#x2F;mnt&#x2F;Packages&#x2F;tree-1.6.0-10.el7.x86_64.rpm</span><br></pre></td></tr></table></figure><h3 id="2-如何查询已安装好的rpm包"><a href="#2-如何查询已安装好的rpm包" class="headerlink" title="2.如何查询已安装好的rpm包"></a>2.如何查询已安装好的rpm包</h3><table><thead><tr><th>选项</th><th>描述</th></tr></thead><tbody><tr><td>rpm -q</td><td>查看指定软件包是否安装</td></tr><tr><td>rpm -qa</td><td>查看系统中已安装的所有RPM软件包列表</td></tr><tr><td>rpm -qi</td><td>查看指定软件的详细信息</td></tr><tr><td>rpm -ql</td><td>查询指定软件包所安装的目录、文件列表</td></tr><tr><td>rpm -qc</td><td>查询指定软件包的配置文件</td></tr><tr><td>rpm -qf</td><td>查询文件或目录属于哪个RPM软件</td></tr><tr><td>rpm -qip</td><td>查询未安装的rpm包详细信息</td></tr><tr><td>rpm -qlp</td><td>查询未安装的软件包会产生哪些文件</td></tr></tbody></table><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">#查询vsftpd这个rpm包是否安装</span><br><span class="line">[root@lqz ~]# rpm -q vsftpd</span><br><span class="line"></span><br><span class="line">#模糊查找系统已安装的rpm包</span><br><span class="line">[root@lqz ~]# rpm -qa |grep ftp</span><br><span class="line"></span><br><span class="line">#查询vsftpd软件包的相关信息</span><br><span class="line">[root@lqz ~]# rpm -qi vsftpd</span><br><span class="line"></span><br><span class="line">#查询rpm包所安装的文件</span><br><span class="line">[root@lqz ~]# rpm -ql vsftpd</span><br><span class="line"></span><br><span class="line">#查询rpm包相关的配置文件</span><br><span class="line">[root@lqz ~]# rpm -qc vsftpd</span><br><span class="line"></span><br><span class="line">#查询配置文件或命令来自于哪个rpm包</span><br><span class="line">[root@lqz ~]# rpm -qf &#x2F;etc&#x2F;vsftpd&#x2F;vsftpd.conf</span><br><span class="line">[root@lqz ~]# rpm -qf &#x2F;usr&#x2F;sbin&#x2F;vsftpd</span><br><span class="line"></span><br><span class="line">#查询未安装的软件包会产生哪些文件</span><br><span class="line">[root@lqz ~]# rpm -qlp &#x2F;mnt&#x2F;Packages&#x2F;samba-3.6.23-41.el6.x86_64.rpm</span><br><span class="line"></span><br><span class="line">#查询未安装的软件包会产生哪些文件</span><br><span class="line">[root@lqz ~]# rpm -qip &#x2F;mnt&#x2F;Packages&#x2F;samba-3.6.23-41.el6.x86_64.rpm</span><br></pre></td></tr></table></figure><h3 id="3-RPM包升级"><a href="#3-RPM包升级" class="headerlink" title="3.RPM包升级"></a>3.RPM包升级</h3><table><thead><tr><th>选项</th><th>描述</th></tr></thead><tbody><tr><td>rpm -U</td><td>如果老版本不存在则全新安装，如果存在有新版即升级</td></tr></tbody></table><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># wget  https:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;zabbix&#x2F;zabbix&#x2F;3.0&#x2F;rhel&#x2F;7&#x2F;x86_64&#x2F;zabbix-agent-3.0.9-1.el7.x86_64.rpm</span><br><span class="line"># wget  https:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;zabbix&#x2F;zabbix&#x2F;4.2&#x2F;rhel&#x2F;7&#x2F;x86_64&#x2F;zabbix-agent-4.2.0-1.el7.x86_64.rpm</span><br><span class="line"></span><br><span class="line">#1.先安装低版本</span><br><span class="line">[root@www.lqz.com ~]# rpm -ivh zabbix-agent-3.0.9-1.el7.x86_64.rpm</span><br><span class="line">        </span><br><span class="line">#2.尝试安装高版本(会出现错误)</span><br><span class="line">[root@www.lqz.com ~]# rpm -ivh zabbix-agent-4.2.0-1.el7.x86_64.rpm</span><br><span class="line">        </span><br><span class="line">#3.使用升级的方式,完美解决替换</span><br><span class="line">[root@www.lqz.com ~]# rpm -Uvh zabbix-agent-4.2.0-1.el7.x86_64.rpm</span><br></pre></td></tr></table></figure><h3 id="4-RPM包卸载"><a href="#4-RPM包卸载" class="headerlink" title="4.RPM包卸载"></a>4.RPM包卸载</h3><p>卸载包时需要先把依赖的包卸载掉，如果依赖的包是系统所必须的，那就不能卸载这个包，否则会造成系统崩溃。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#先查询, 然后卸载 </span><br><span class="line">[root@www.lqz.com ~]# rpm -qa |grep sh</span><br><span class="line">[root@www.lqz.com ~]# rpm -e zsh</span><br></pre></td></tr></table></figure><h3 id="5-RPM包校验-扩展了解"><a href="#5-RPM包校验-扩展了解" class="headerlink" title="5.RPM包校验(扩展了解)"></a>5.RPM包校验(扩展了解)</h3><p>软件相关的数据库存放于<code>/var/lib/rpm</code>目录</p><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>S</td><td>文件的容量大小是否被改变</td></tr><tr><td>M</td><td>文件的类型或者文件的属性是否被修改</td></tr><tr><td>5</td><td>MD5 这一种指纹加密的内容已经不同</td></tr><tr><td>L</td><td>路径已经被改变</td></tr><tr><td>U</td><td>文件的所属主已被修改</td></tr><tr><td>G</td><td>文件的所属组已被修改</td></tr><tr><td>T</td><td>文件的创建时间已被改变</td></tr></tbody></table><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@www.lqz.com ~]# rpm -V vsftpd</span><br><span class="line">S.5....T.  c &#x2F;etc&#x2F;pam.d&#x2F;vsftpd</span><br><span class="line">.......T.  c &#x2F;etc&#x2F;vsftpd&#x2F;ftpusers</span><br><span class="line">S.5....T.  c &#x2F;etc&#x2F;vsftpd&#x2F;vsftpd.conf</span><br><span class="line">.M.......    &#x2F;var&#x2F;ftp&#x2F;pub</span><br></pre></td></tr></table></figure><h3 id="6-RPM包小结"><a href="#6-RPM包小结" class="headerlink" title="6.RPM包小结"></a>6.RPM包小结</h3><p>如何查询 util-linux 软件包安装了哪些文件？<br>如何查询 mkdir 命令是由哪个 RPM 软件包安装的？<br>安装 .rpm 软件包时，-i、-U、选项有何区别？</p><h2 id="3-YUM基本介绍"><a href="#3-YUM基本介绍" class="headerlink" title="3.YUM基本介绍"></a>3.YUM基本介绍</h2><h3 id="1-什么是YUM"><a href="#1-什么是YUM" class="headerlink" title="1.什么是YUM"></a>1.什么是YUM</h3><p>Yum是RedHat以及CentOS中的软件包管理器。能够通过互联网下载 .rpm 包并且安装，并可以自动处理依赖性关系，无须繁琐地一次次下载、安装。(PS: YUM是生产最佳实践)</p><h3 id="2-YUM源是什么"><a href="#2-YUM源是什么" class="headerlink" title="2.YUM源是什么"></a>2.YUM源是什么</h3><p>1要成功的使用 YUM 工具安装更新软件或系统，就需要有一个包含各种 rpm 软件包的repository（软件仓库），这个软件仓库我们习惯称为 yum 源。(可以是本地源、网络源)</p><h3 id="3-YUM源配置实例"><a href="#3-YUM源配置实例" class="headerlink" title="3.YUM源配置实例"></a>3.YUM源配置实例</h3><h4 id="1-阿里yum源"><a href="#1-阿里yum源" class="headerlink" title="1.阿里yum源"></a>1.阿里yum源</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#默认系统是国外源，需要替换为国内的源</span><br><span class="line">[root@www.lqz.com ~]# wget -O &#x2F;etc&#x2F;yum.repos.d&#x2F;CentOS-Base.repo </span><br><span class="line">http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;repo&#x2F;Centos-7.repo</span><br><span class="line"></span><br><span class="line">#扩展源，有很多软件在基本源中没有</span><br><span class="line">[root@www.lqz.com ~]# wget -O &#x2F;etc&#x2F;yum.repos.d&#x2F;epel.repo </span><br><span class="line">http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;repo&#x2F;epel-7.repo</span><br></pre></td></tr></table></figure><h4 id="2-Nginx官方源，比如在学习Nginx时需要使用官方的yum源来安装"><a href="#2-Nginx官方源，比如在学习Nginx时需要使用官方的yum源来安装" class="headerlink" title="2.Nginx官方源，比如在学习Nginx时需要使用官方的yum源来安装"></a>2.Nginx官方源，比如在学习Nginx时需要使用官方的yum源来安装</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@www.lqz.com ~]# vim &#x2F;etc&#x2F;yum.repos.d&#x2F;nginx.repo</span><br><span class="line">[nginx]</span><br><span class="line">name&#x3D;nginx repo </span><br><span class="line">baseurl&#x3D;http:&#x2F;&#x2F;nginx.org&#x2F;packages&#x2F;centos&#x2F;7&#x2F;$basearch&#x2F; </span><br><span class="line">gpgcheck&#x3D;0</span><br><span class="line">enabled&#x3D;1</span><br></pre></td></tr></table></figure><p>PS:源超找方式基本一致,zabbix，Docker、Nginx、saltstack、openstack</p><h2 id="4-YUM实践案例"><a href="#4-YUM实践案例" class="headerlink" title="4.YUM实践案例"></a>4.YUM实践案例</h2><h3 id="1-使用yum查询软件包的方式"><a href="#1-使用yum查询软件包的方式" class="headerlink" title="1.使用yum查询软件包的方式"></a>1.使用yum查询软件包的方式</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@www.lqz.com ~]# yum list</span><br><span class="line">[root@www.lqz.com ~]# yum list|grep ftp</span><br><span class="line">[root@www.lqz.com ~]# yum info ftp</span><br></pre></td></tr></table></figure><h3 id="2-使用yum安装软件包的方式"><a href="#2-使用yum安装软件包的方式" class="headerlink" title="2.使用yum安装软件包的方式"></a>2.使用yum安装软件包的方式</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[root@www.lqz.com ~]# yum install tree</span><br><span class="line">[root@www.lqz.com ~]# yum install tree -y    #非交互</span><br><span class="line"></span><br><span class="line">#安装本地的rpm包, 如果有依赖关系, 会自动从软件仓库中下载所需依赖</span><br><span class="line">[root@www.lqz.com ~]# yum localinstall &#x2F;mnt&#x2F;Packages&#x2F;bind-9.9.4-50.el7.x86_64.rpm</span><br><span class="line"></span><br><span class="line">#直接安装网络上的rpm包</span><br><span class="line">[root@www.lqz.com ~]# yum install http:&#x2F;&#x2F;repo.zabbix.com&#x2F;zabbix&#x2F;3.4&#x2F;rhel&#x2F;7&#x2F;x86_64&#x2F;zabbix-release-3.4-2.el7.noarch.rpm</span><br></pre></td></tr></table></figure><h3 id="3-使用yum重新安装软件包的方式"><a href="#3-使用yum重新安装软件包的方式" class="headerlink" title="3.使用yum重新安装软件包的方式"></a>3.使用yum重新安装软件包的方式</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">#1.如果不小心删除vsftpd配置文件</span><br><span class="line">[root@www.lqz.com ~]# rm -f &#x2F;etc&#x2F;vsftpd&#x2F;vsftpd.conf</span><br><span class="line"></span><br><span class="line">#2.可以对软件进行重新安装</span><br><span class="line">[root@www.lqz.com ~]# yum reinstall vsftpd</span><br><span class="line"></span><br><span class="line">#3.检查软件的配置文件</span><br><span class="line">[root@www.lqz.com ~]# rpm -qc vsftpd</span><br><span class="line">&#x2F;etc&#x2F;logrotate.d&#x2F;vsftpd</span><br><span class="line">&#x2F;etc&#x2F;pam.d&#x2F;vsftpd</span><br><span class="line">&#x2F;etc&#x2F;vsftpd&#x2F;ftpusers</span><br><span class="line">&#x2F;etc&#x2F;vsftpd&#x2F;user_list</span><br><span class="line">&#x2F;etc&#x2F;vsftpd&#x2F;vsftpd.conf</span><br></pre></td></tr></table></figure><h3 id="4使用yum更新软件包"><a href="#4使用yum更新软件包" class="headerlink" title="4使用yum更新软件包"></a>4使用yum更新软件包</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#对比Linux已安装的软件和yum仓库中的软件, 有哪些需要升级</span><br><span class="line">[root@www.lqz.com ~]# yum check-update</span><br><span class="line"></span><br><span class="line">#更新acl软件</span><br><span class="line">[root@www.lqz.com ~]#  yum update acl -y</span><br><span class="line"></span><br><span class="line">#如下的执行很危险，这代表更新整个系统所有的软件，包括内核</span><br><span class="line">[root@www.lqz.com ~]#  yum update -y</span><br></pre></td></tr></table></figure><h3 id="5-使用yum删除软件包"><a href="#5-使用yum删除软件包" class="headerlink" title="5.使用yum删除软件包"></a>5.使用yum删除软件包</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@www.lqz.com ~]# yum install samba -y</span><br><span class="line">[root@www.lqz.com ~]# yum erase samba -y</span><br><span class="line">[root@www.lqz.com ~]# yum remove samba -y</span><br></pre></td></tr></table></figure><h3 id="6-与yum仓库相关指令-扩展了解"><a href="#6-与yum仓库相关指令-扩展了解" class="headerlink" title="6.与yum仓库相关指令(扩展了解)"></a>6.与yum仓库相关指令(扩展了解)</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#列出yum源可用的软件仓库</span><br><span class="line">[root@www.lqz.com ~]# yum repolist</span><br><span class="line"></span><br><span class="line">#列出全部yum源可用和禁用的仓库</span><br><span class="line">[root@www.lqz.com ~]# yum repolist all</span><br><span class="line"></span><br><span class="line">#查找某个命令或文件属于那个软件包(生产常用)</span><br><span class="line">[root@www.lqz.com ~]# yum provides &#x2F;etc&#x2F;my.cnf</span><br><span class="line">[root@www.lqz.com ~]# yum provides cd</span><br></pre></td></tr></table></figure><h3 id="7-与yum缓存相关指令-扩展了解"><a href="#7-与yum缓存相关指令-扩展了解" class="headerlink" title="7.与yum缓存相关指令(扩展了解)"></a>7.与yum缓存相关指令(扩展了解)</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">#1.缓存rpm包方式一、修改yum全局配置文件</span><br><span class="line">[root@www.lqz.com ~]# vim &#x2F;etc&#x2F;yum.conf</span><br><span class="line">[main]</span><br><span class="line">cachedir&#x3D;&#x2F;var&#x2F;cache&#x2F;yum&#x2F;$basearch&#x2F;$releasever</span><br><span class="line">keepcache&#x3D;1     #启动缓存</span><br><span class="line"></span><br><span class="line">#2.缓存rpm包方式二，只下载不安装</span><br><span class="line">[root@www.lqz.com ~]# yum install -y yum-plugin-downloadonly #插件</span><br><span class="line">[root@www.lqz.com ~]# yum install httpd -y --downloadonly --downloaddir&#x3D;&#x2F;tmp</span><br><span class="line"></span><br><span class="line">#3.清除所有yum缓存的软件包以及元数据</span><br><span class="line">[root@www.lqz.com ~]# yum clean all</span><br><span class="line"></span><br><span class="line">#4.只清除缓存的软件包</span><br><span class="line">[root@www.lqz.com ~]# yum clean packages</span><br></pre></td></tr></table></figure><h3 id="8-组包相关指令，-扩展了解"><a href="#8-组包相关指令，-扩展了解" class="headerlink" title="8.组包相关指令，(扩展了解)"></a>8.组包相关指令，(扩展了解)</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[root@www.lqz.com ~]# yum groups list</span><br><span class="line">#安装一整个组的软件</span><br><span class="line">[root@lqz ~]# yum groups install Development tools </span><br><span class="line">Compatibility libraries </span><br><span class="line">Base Debugging Tools</span><br><span class="line"></span><br><span class="line">#yum删除包组</span><br><span class="line">[root@www.lqz.com ~]# yum groups remove  -y Base</span><br></pre></td></tr></table></figure><h3 id="9-历史记录指令-扩展了解"><a href="#9-历史记录指令-扩展了解" class="headerlink" title="9.历史记录指令,(扩展了解)"></a>9.历史记录指令,(扩展了解)</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#1.查看历史执行yum命令</span><br><span class="line">[root@www.lqz.com ~]# yum history</span><br><span class="line"></span><br><span class="line">#2.查询历史执行yum命令ID详细信息</span><br><span class="line">[root@www.lqz.com ~]# yum history info N</span><br><span class="line"></span><br><span class="line">#3.撤销历史执行过的yum命令</span><br><span class="line">[root@www.lqz.com ~]# yum history undo N</span><br></pre></td></tr></table></figure><p>PS: YUM还有配置文件与签名验证需要我们额外扩展了解的<a href="https://www.cnblogs.com/lqz/p/10757861.html" target="_blank" rel="noopener">请点击传送门</a></p><h2 id="5-搭建本地仓库"><a href="#5-搭建本地仓库" class="headerlink" title="5.搭建本地仓库"></a>5.搭建本地仓库</h2><h3 id="1-有的时候你的linux系统不能联网，当然就不能很便捷的使用联网的yum源了，这时候就需要你自己会利用linux系统光盘制作一个yum源。具体步骤如下："><a href="#1-有的时候你的linux系统不能联网，当然就不能很便捷的使用联网的yum源了，这时候就需要你自己会利用linux系统光盘制作一个yum源。具体步骤如下：" class="headerlink" title="1.有的时候你的linux系统不能联网，当然就不能很便捷的使用联网的yum源了，这时候就需要你自己会利用linux系统光盘制作一个yum源。具体步骤如下："></a>1.有的时候你的linux系统不能联网，当然就不能很便捷的使用联网的yum源了，这时候就需要你自己会利用linux系统光盘制作一个yum源。具体步骤如下：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">#1.挂载镜像</span><br><span class="line">[root@lqz ~]# mount &#x2F;dev&#x2F;cdrom &#x2F;mnt   </span><br><span class="line"></span><br><span class="line">#2.备份原有仓库</span><br><span class="line">[root@lqz ~]# gzip &#x2F;etc&#x2F;yum.repos.d&#x2F;</span><br><span class="line"></span><br><span class="line">#3.使用yum-config-manager命令添加本地仓库</span><br><span class="line">[root@lqz ~]# yum-config-manager --add-repo&#x3D;&quot;file:&#x2F;&#x2F;&#x2F;mnt&quot;</span><br><span class="line"></span><br><span class="line">#4.或者使用手动添加repo文件</span><br><span class="line">[root@lqz ~]# vim &#x2F;etc&#x2F;yum.repos.d&#x2F;cdrom.repo  </span><br><span class="line">[cdrom]      </span><br><span class="line">name&#x3D;This is local cdrom</span><br><span class="line">baseurl&#x3D;file:&#x2F;&#x2F;&#x2F;mnt</span><br><span class="line">enabled&#x3D;1</span><br><span class="line">gpgcheck&#x3D;0</span><br><span class="line"></span><br><span class="line">[]          #仓库名称</span><br><span class="line">name        3仓库描述信息</span><br><span class="line">baseurl     #YUM源url地址 ,可以是file:&#x2F;&#x2F; ftp:&#x2F;&#x2F; http:&#x2F;&#x2F;</span><br><span class="line">enabled     #是否使用该YUM源(0代表禁用, 1代表激活)</span><br><span class="line">gpgcheck    #是否验证软件签名(0代表禁用, 1代表激活)</span><br><span class="line"></span><br><span class="line">#5.生成缓存</span><br><span class="line">[root@lqz ~]# yum makecache</span><br></pre></td></tr></table></figure><h3 id="2-很多时候不仅仅是一台机器无法上网，而是很多机器都无法上网，但都有联网下载软件的需求，这个时候难道每台机器都挂在光盘吗-当然可以，但如果软件出现了更新怎么办"><a href="#2-很多时候不仅仅是一台机器无法上网，而是很多机器都无法上网，但都有联网下载软件的需求，这个时候难道每台机器都挂在光盘吗-当然可以，但如果软件出现了更新怎么办" class="headerlink" title="2.很多时候不仅仅是一台机器无法上网，而是很多机器都无法上网，但都有联网下载软件的需求，这个时候难道每台机器都挂在光盘吗? 当然可以，但如果软件出现了更新怎么办?"></a>2.很多时候不仅仅是一台机器无法上网，而是很多机器都无法上网，但都有联网下载软件的需求，这个时候难道每台机器都挂在光盘吗? 当然可以，但如果软件出现了更新怎么办?</h3><p><img src= "/img/loading.gif" data-src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ghu7323kkrj30fm06d3z2.jpg" alt="仓库构建"></p><p>本地光盘提供基础软件包: Base<br>yum缓存提供常用软件包: nginx, zabbix, docker</p><h4 id="1-环境准备"><a href="#1-环境准备" class="headerlink" title="1.环境准备"></a>1.环境准备</h4><table><thead><tr><th>系统</th><th>IP</th><th>角色</th></tr></thead><tbody><tr><td>centos7</td><td>10.0.0.99</td><td>yum仓库服务端</td></tr><tr><td>centos7</td><td>10.0.0.98</td><td>yum仓库客户端</td></tr></tbody></table><h4 id="2-服务端进行yum仓库的搭建准备工作"><a href="#2-服务端进行yum仓库的搭建准备工作" class="headerlink" title="2.服务端进行yum仓库的搭建准备工作"></a>2.服务端进行yum仓库的搭建准备工作</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">#1.关闭防火墙、与selinux</span><br><span class="line">[root@yum_server ~]# systemctl stop firewalld</span><br><span class="line">[root@yum_server ~]# setenforce 0</span><br><span class="line"></span><br><span class="line">#2.安装ftp服务,启动并加入开机启动</span><br><span class="line">[root@yum_server ~]# yum -y install vsftpd </span><br><span class="line">[root@yum_server ~]# systemctl start vsftpd </span><br><span class="line">[root@yum_server ~]# systemctl enable vsftpd</span><br><span class="line"></span><br><span class="line">#3.开启yum缓存功能</span><br><span class="line">[root@yum_server ~]# vim &#x2F;etc&#x2F;yum.conf</span><br><span class="line">[main] cachedir&#x3D;&#x2F;var&#x2F;cache&#x2F;yum&#x2F;$basearch&#x2F;$releasever </span><br><span class="line">keepcache&#x3D;1</span><br><span class="line">[root@yum_server ~]# yum clean all</span><br><span class="line"></span><br><span class="line">#4.提供基础base软件包</span><br><span class="line">[root@yum_server ~]# mkdir &#x2F;var&#x2F;ftp&#x2F;centos7</span><br><span class="line">[root@yum_server ~]# mount &#x2F;dev&#x2F;cdrom &#x2F;mnt</span><br><span class="line">[root@yum_server ~]# cp -rp  &#x2F;mnt&#x2F;Packages&#x2F;.rpm &#x2F;var&#x2F;ftp&#x2F;centos7&#x2F;</span><br><span class="line"></span><br><span class="line">#5.提供第三方源</span><br><span class="line">[root@yum_server ~]# mkdir &#x2F;var&#x2F;ftp&#x2F;ops</span><br><span class="line">[root@yum_server ~]# yum -y install nginx docker</span><br><span class="line"></span><br><span class="line">#6.复制已缓存的 Nginx docker 及依赖包 到自定义 YUM 仓库目录中</span><br><span class="line">[root@yum_server_69_112 ~]# find &#x2F;var&#x2F;cache&#x2F;yum&#x2F;x86_64&#x2F;7&#x2F; </span><br><span class="line">-iname &quot;.rpm&quot; -exec cp -rf &#123;&#125; &#x2F;var&#x2F;ftp&#x2F;ops ;</span><br><span class="line"></span><br><span class="line">#7.安装createrepo并创建 reopdata仓库</span><br><span class="line">[root@yum_server_ ~]# yum -y install createrepo</span><br><span class="line">[root@yum_server_ ~]# createrepo &#x2F;var&#x2F;ftp&#x2F;ops</span><br><span class="line"></span><br><span class="line">#PS: 如果此仓库每次新增软件则需要重新生成一次</span><br></pre></td></tr></table></figure><h4 id="3-客户端配置yum源指向服务端"><a href="#3-客户端配置yum源指向服务端" class="headerlink" title="3.客户端配置yum源指向服务端"></a>3.客户端配置yum源指向服务端</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">#1.客户端配置并使用 base 基础源</span><br><span class="line">[root@yum_client ~]# gzip &#x2F;etc&#x2F;yum.repos.d&#x2F;</span><br><span class="line">[root@yum_client ~]# vim &#x2F;etc&#x2F;yum.repos.d&#x2F;centos7.repo </span><br><span class="line">[centos7]</span><br><span class="line">name&#x3D;centos7_base</span><br><span class="line">baseurl&#x3D;ftp:&#x2F;&#x2F;10.0.0.99&#x2F;centos7</span><br><span class="line">gpgcheck&#x3D;0</span><br><span class="line"></span><br><span class="line">#2.客户端配置并使用 ops 源</span><br><span class="line">[root@yum_client ~]# vim &#x2F;etc&#x2F;yum.repos.d&#x2F;ops.repo </span><br><span class="line">[ops]</span><br><span class="line">name&#x3D;local ftpserver</span><br><span class="line">baseurl&#x3D;ftp:&#x2F;&#x2F;10.0.0.99&#x2F;ops</span><br><span class="line">gpgcheck&#x3D;0</span><br></pre></td></tr></table></figure><h2 id="6-源码包管理实践"><a href="#6-源码包管理实践" class="headerlink" title="6.源码包管理实践"></a>6.源码包管理实践</h2><h3 id="1-源码包是什么"><a href="#1-源码包是什么" class="headerlink" title="1.源码包是什么"></a>1.源码包是什么</h3><p>源码包指的是开发编写好的程序源代码，但并没有将其编译为一个能正常使用的工具。</p><h3 id="2-为什么要学习源码包"><a href="#2-为什么要学习源码包" class="headerlink" title="2.为什么要学习源码包"></a>2.为什么要学习源码包</h3><p>1、部分软件官网仅提供源码包，需要自行编译并安装。<br>2、部分软件在新版本有一些特性还没来得及制作成rpm包时，可以自行编译软件使用其新特性。</p><h3 id="3-源码包的优缺点"><a href="#3-源码包的优缺点" class="headerlink" title="3.源码包的优缺点"></a>3.源码包的优缺点</h3><p>1.可以自行修改源代码<br>2.可以定制需要的相关功能<br>3.新版软件优先更新源码<br>4.缺点是: 1) 相对yum安装软件会复杂很多。2) 标准化实施困难，自动化就无法落地。</p><h3 id="4-源码包如何获取"><a href="#4-源码包如何获取" class="headerlink" title="4.源码包如何获取"></a>4.源码包如何获取</h3><p>常见的软件包都可以在官网获取源码包，比如 apache、nginx、mysql等等</p><h3 id="5将源码包编译为二进制可执行文件步骤如下，简称安装三步曲"><a href="#5将源码包编译为二进制可执行文件步骤如下，简称安装三步曲" class="headerlink" title="5将源码包编译为二进制可执行文件步骤如下，简称安装三步曲"></a>5将源码包编译为二进制可执行文件步骤如下，简称安装三步曲</h3><p><img src= "/img/loading.gif" data-src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ghu73ba42sj30mi0mgtei.jpg" alt="img"><br>PS: 此方法不是百分百通用于所有源码包，建议拿到源码包解压后，进入到目录找相关的README帮助文档</p><h3 id="6-源码编译示例"><a href="#6-源码编译示例" class="headerlink" title="6.源码编译示例"></a>6.源码编译示例</h3><p>下面通过编译Nginx来深入了解下源码包编译的过程。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">#1.基础环境准备</span><br><span class="line">[root@node1 ~]# yum install -y gcc make wget </span><br><span class="line"></span><br><span class="line">#2.下载源码包</span><br><span class="line">[root@node1 ~]# wget http:&#x2F;&#x2F;nginx.org&#x2F;download&#x2F;nginx-1.15.12.tar.gz</span><br><span class="line"></span><br><span class="line">#3.解压源码包, 并进入相应目录</span><br><span class="line">[root@node1 ~]# tar xf nginx-1.15.12.tar.gz</span><br><span class="line">[root@node1 ~]# cd nginx-1.15.12</span><br><span class="line"></span><br><span class="line">#4.配置相关的选项，并生成Makefile</span><br><span class="line">[root@node1 nginx-1.15.12]# .&#x2F;configure --prefix&#x3D;&#x2F;soft&#x2F;nginx-1.12.2</span><br><span class="line"></span><br><span class="line">#5.将Makefile文件编译可执行二进制程序</span><br><span class="line">[root@node1 nginx-1.15.12]# make</span><br><span class="line"></span><br><span class="line">#6.将二进制文件拷贝至对应的目录中</span><br><span class="line">[root@node1 nginx-1.15.12]# make install</span><br></pre></td></tr></table></figure><p>源码编译报错信息处理</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">checking for C compiler ... not found .&#x2F;configure: error: C compiler cc is not found </span><br><span class="line"># yum -y install gcc gcc-c++ make</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">.&#x2F;configure: error: the HTTP rewrite module requires the PCRE library.</span><br><span class="line">You can either disable the module by using --without-http_rewrite_module</span><br><span class="line">option, or install the PCRE library into the system, or build the PCRE library</span><br><span class="line">statically from the source with nginx by using --with-pcre&#x3D;&lt;path&gt; option.</span><br><span class="line"># yum install -y pcre-devel</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">.&#x2F;configure: error: the HTTP gzip module requires the zlib library.</span><br><span class="line">You can either disable the module by using --without-</span><br><span class="line">http_gzip_module option, or install the zlib library into the</span><br><span class="line">system, or build the zlib library statically from the source with</span><br><span class="line">nginx by using --with-zlib&#x3D;&lt;path&gt; option. </span><br><span class="line"># yum -y install zlib-devel</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">.&#x2F;configure: error: SSL modules require the OpenSSL library.</span><br><span class="line">You can either do not enable the modules, or install the OpenSSL </span><br><span class="line">library into the system, or build the OpenSSL library statically</span><br><span class="line">from the source with nginx by using --with-openssl&#x3D;&lt;path&gt; option.</span><br><span class="line"># yum -y install openssl-devel</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1-RPM基本概述&quot;&gt;&lt;a href=&quot;#1-RPM基本概述&quot; class=&quot;headerlink&quot; title=&quot;1.RPM基本概述&quot;&gt;&lt;/a&gt;1.RPM基本概述&lt;/h2&gt;&lt;h3 id=&quot;1-什么是rpm&quot;&gt;&lt;a href=&quot;#1-什么是rpm&quot; class=&quot;
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>11-Linux——压缩打包</title>
    <link href="http://yoursite.com/2019/03/03/Linux%E2%80%94%E2%80%94%E5%8E%8B%E7%BC%A9%E6%89%93%E5%8C%85/"/>
    <id>http://yoursite.com/2019/03/03/Linux%E2%80%94%E2%80%94%E5%8E%8B%E7%BC%A9%E6%89%93%E5%8C%85/</id>
    <published>2019-03-03T13:40:20.000Z</published>
    <updated>2020-08-18T12:13:45.831Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-find查找概述"><a href="#1-find查找概述" class="headerlink" title="1.find查找概述"></a>1.find查找概述</h2><p><em>为什么要有文件查找，因为很多时候我们可能会忘了某个文件所在的位置，此时就需要通过find来查找。<br>find命令可以根据不同的条件来进行查找文件，例如：文件名称、文件大小、文件修改时间、属主属组、权限、等等方式。同时find命令是Linux下必须掌握的。</em></p><p><strong><em>find 命令的基本语法如下\</em></strong></p><table><thead><tr><th>命令</th><th>路径</th><th>选项</th><th>表达式</th><th>动作</th></tr></thead><tbody><tr><td>find</td><td>[path…]</td><td>[options]</td><td>[expression]</td><td>[action]</td></tr><tr><td>查找</td><td>地区</td><td>妹纸</td><td>18-25岁</td><td>约?</td></tr></tbody></table><h2 id="2-find查找示例"><a href="#2-find查找示例" class="headerlink" title="2.find查找示例"></a>2.find查找示例</h2><p><strong><em>以下列出所有find常用的选项\</em></strong></p><h3 id="1-find名称查找"><a href="#1-find名称查找" class="headerlink" title="1.find名称查找"></a><em>1.find名称查找</em></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#1.创建文件</span><br><span class="line">touch &#x2F;etc&#x2F;sysconfig&#x2F;network-scripts&#x2F;&#123;ifcfg-eth1,IFCFG-ETH1&#125;</span><br><span class="line"></span><br><span class="line">#2.查找&#x2F;etc目录下包含ifcfg-eth0名称的文件</span><br><span class="line">[root@lqz ~]# find &#x2F;etc -name &quot;ifcfg-eth1&quot;</span><br><span class="line"></span><br><span class="line">#3.-i 忽略大小写</span><br><span class="line">[root@lqz ~]# find &#x2F;etc -iname &quot;ifcfg-eth1&quot;</span><br><span class="line">#查找&#x2F;etc目录下包含ifcfg-eth名称所有文件</span><br><span class="line">[root@lqz ~]# find &#x2F;etc&#x2F; -name &quot;ifcfg-eth*&quot;</span><br><span class="line">[root@lqz ~]# find &#x2F;etc -iname &quot;ifcfg-eth*&quot;</span><br></pre></td></tr></table></figure><h3 id="2-find大小查找"><a href="#2-find大小查找" class="headerlink" title="2.find大小查找"></a><em>2.find大小查找</em></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#1.查找大于5M的文件</span><br><span class="line">[root@lqz ~]# find &#x2F;etc -size +5M</span><br><span class="line"></span><br><span class="line">#2.查找等于5M的文件</span><br><span class="line">[root@lqz ~]# find &#x2F;etc -size 5M</span><br><span class="line"></span><br><span class="line">#3.查找小于5M的文件</span><br><span class="line">[root@lqz ~]# find &#x2F;etc -size -5M</span><br></pre></td></tr></table></figure><h3 id="3-find类型查找"><a href="#3-find类型查找" class="headerlink" title="3.find类型查找"></a><em>3.find类型查找</em></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"># f 文件</span><br><span class="line">[root@lqz ~]# find &#x2F;dev -type f</span><br><span class="line"># d 目录</span><br><span class="line">[root@lqz ~]# find &#x2F;dev -type d</span><br><span class="line"># l 链接</span><br><span class="line">[root@lqz ~]# find &#x2F;dev -type l</span><br><span class="line"># b 块设备</span><br><span class="line">[root@lqz ~]# find &#x2F;dev -type b</span><br><span class="line"># c 字符设备</span><br><span class="line">[root@lqz ~]# find &#x2F;dev -type c</span><br><span class="line"># s 套接字</span><br><span class="line">[root@lqz ~]# find &#x2F;dev -type s</span><br><span class="line"># p 管道文件</span><br><span class="line">[root@lqz ~]# find &#x2F;dev -type p</span><br></pre></td></tr></table></figure><h3 id="4-find时间查找"><a href="#4-find时间查找" class="headerlink" title="4.find时间查找"></a><em>4.find时间查找</em></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">#1.创建测试文件(后期shell会讲)</span><br><span class="line">[root@lqz ~]# for i in &#123;01..28&#125;;do date -s  201904$i &amp;&amp; touch file-$i;done</span><br><span class="line"></span><br><span class="line">#2.查找7天以前的文件(不会打印当天的文件)</span><br><span class="line">[root@lqz ~]# find .&#x2F; -iname &quot;file-*&quot; -mtime +7</span><br><span class="line"></span><br><span class="line">#3.查找最近7天的文件，不建议使用(会打印当天的文件)</span><br><span class="line">[root@lqz ~]# find .&#x2F; -iname &quot;file-*&quot; -mtime -7</span><br><span class="line"></span><br><span class="line">#4.查找第7天文件(不会打印当天的文件)</span><br><span class="line">[root@lqz ~]# find .&#x2F; -iname &quot;file-*&quot; -mtime 7</span><br><span class="line"></span><br><span class="line">#5.本地文件保留最近7天的备份文件, 备份服务器保留3个月的备份文件(实际使用方案)</span><br><span class="line">find &#x2F;backup&#x2F; -iname &quot;*.bak&quot; -mtime +7 -delete</span><br><span class="line">find &#x2F;backup&#x2F; -iname &quot;*.bak&quot; -mtime +90 -delete</span><br></pre></td></tr></table></figure><h3 id="5-find用户查找"><a href="#5-find用户查找" class="headerlink" title="5.find用户查找"></a><em>5.find用户查找</em></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">#查找属主是jack</span><br><span class="line">[root@lqz ~]# find &#x2F;home -user jack</span><br><span class="line">#查找属组是admin</span><br><span class="line">[root@lqz ~]# find &#x2F;home -group admin</span><br><span class="line">#查找属主是jack, 属组是admin</span><br><span class="line">[root@lqz ~]# find &#x2F;home -user jack -group admin</span><br><span class="line">#查找属主是jack, 并且属组是admin</span><br><span class="line">[root@lqz ~]# find &#x2F;home -user jack -a -group admin</span><br><span class="line">#查找属主是jack, 或者属组是admin</span><br><span class="line">[root@lqz ~]# find &#x2F;home -user jack -o -group admin</span><br><span class="line">#查找没有属主</span><br><span class="line">[root@lqz ~]# find &#x2F;home -nouser</span><br><span class="line">#查找没有属组</span><br><span class="line">[root@lqz ~]# find &#x2F;home -nogroup</span><br><span class="line">#查找没有属主或属组</span><br><span class="line">[root@lqz ~]# find &#x2F;home -nouser -o -nogroup</span><br></pre></td></tr></table></figure><h3 id="6-find权限查找"><a href="#6-find权限查找" class="headerlink" title="6.find权限查找"></a><em>6.find权限查找</em></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">#精切匹配644权限</span><br><span class="line">[root@lqz ~]# find . -perm 644 -ls</span><br><span class="line"></span><br><span class="line">#包含444权限即可</span><br><span class="line">[root@lqz ~]# find . -perm -444  -ls</span><br><span class="line">#查找全局可写(每位权限必须包含w)</span><br><span class="line">[root@lqz ~]# find . -perm -222 -ls</span><br><span class="line">#包含set uid</span><br><span class="line">[root@lqz ~]# find  &#x2F;usr&#x2F;sbin -perm -4000 -ls</span><br><span class="line">#包含set gid</span><br><span class="line">[root@lqz ~]# find  &#x2F;usr&#x2F;sbin -perm -2000 -ls</span><br><span class="line">#包含sticky</span><br><span class="line">[root@lqz ~]# find  &#x2F;usr&#x2F;sbin -perm -1000 -ls</span><br></pre></td></tr></table></figure><p><strong><em>2.find动作处理，比如查找到一个文件后，需要对文件进行如何处理, find的默认动作是 -print\</em></strong></p><table><thead><tr><th>动作</th><th>含义</th></tr></thead><tbody><tr><td>-print</td><td>打印查找到的内容(默认)</td></tr><tr><td>-ls</td><td>以长格式显示的方式打印查找到的内容</td></tr><tr><td>-delete</td><td>删除查找到的文件(仅能删除空目录)</td></tr><tr><td>-ok</td><td>后面跟自定义 shell 命令(会提示是否操作)</td></tr><tr><td>-exec</td><td>后面跟自定义 shell 命令(标准写法 -exec ;)</td></tr></tbody></table><p><em>1.find查找后的动作命令示例</em></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">#1.使用-print打印查找到的文件</span><br><span class="line">[root@lqz ~]# find &#x2F;etc -name &quot;ifcfg*&quot;</span><br><span class="line">[root@lqz ~]# find &#x2F;etc -name &quot;ifcfg*&quot; -print</span><br><span class="line"></span><br><span class="line">#2.使用-ls打印查找到的文件，以长格式显示</span><br><span class="line">[root@lqz ~]# find &#x2F;etc -name &quot;ifcfg*&quot; -ls</span><br><span class="line"></span><br><span class="line">#3.使用-delete删除文件，但仅能删除空目录</span><br><span class="line">[root@lqz ~]# find &#x2F;etc -name &quot;ifcfg*&quot; -delete</span><br><span class="line"></span><br><span class="line">#4.使用-ok实现文件拷贝，但会提示是否拷贝</span><br><span class="line">[root@lqz ~]# find &#x2F;etc -name &quot;ifcfg*&quot; -ok cp -rvf &#123;&#125; &#x2F;tmp \;</span><br><span class="line"></span><br><span class="line">#5.使用-exec实现文件拷贝和文件删除。</span><br><span class="line">[root@lqz ~]# find &#x2F;etc -name &quot;ifcfg*&quot; -exec cp -rvf &#123;&#125; &#x2F;tmp \;</span><br><span class="line">[root@lqz ~]# find &#x2F;etc -name &quot;ifcfg*&quot; -exec rm -f &#123;&#125; \;</span><br></pre></td></tr></table></figure><p><em>2.使用find命令结合xargs</em></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#xargs将前者命令查找到的文件作为一个整体传递后者命令的输入</span><br><span class="line">[root@lqz ~]# touch file.txt</span><br><span class="line">[root@lqz ~]# find . -name &quot;file.txt&quot; |xargs rm -f</span><br><span class="line">[root@lqz ~]# find . -name &quot;file.txt&quot; |xargs -I &#123;&#125; cp -rvf &#123;&#125; &#x2F;var&#x2F;tmp</span><br></pre></td></tr></table></figure><p><em>3.find逻辑运算符</em></p><table><thead><tr><th>符号</th><th>作用</th></tr></thead><tbody><tr><td>-a</td><td>与</td></tr><tr><td>-o</td><td>或</td></tr><tr><td>-not|!</td><td>非</td></tr></tbody></table><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#1.查找当前目录下，属主不是hdfs的所有文件</span><br><span class="line">[root@lqz ~]# find . -not -user hdfs </span><br><span class="line">[root@lqz ~]# find . ! -user hdfs</span><br><span class="line">        </span><br><span class="line">#2.查找当前目录下，属主属于hdfs，且大小大于300字节的文件</span><br><span class="line">[root@lqz ~]# find . -type f -a -user hdfs -a -size +300c</span><br><span class="line">            </span><br><span class="line">#3.查找当前目录下的属主为hdfs或者以xml结尾的普通文件</span><br><span class="line">[root@lqz ~]# find . -type f -a \( -user hdfs -o -name &#39;*.xml&#39; \)</span><br></pre></td></tr></table></figure><p><em>4.find相关练习题</em></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">1.查找&#x2F;tmp目录下，属主不是root，且文件名不以f开头的文件</span><br><span class="line">2.查找&#x2F;var目录下属主为root，且属组为mail的所有文件</span><br><span class="line">3.查找&#x2F;var目录下不属于root、lp、gdm的所有文件</span><br><span class="line">4.查找&#x2F;var目录下最近一周内其内容修改过，同时属主不为root，也不是postfix的文件</span><br><span class="line">5.查找&#x2F;etc目录下大于1M且类型为普通文件的所有文件</span><br><span class="line">6.将&#x2F;etc&#x2F;中的所有目录(仅目录)复制到&#x2F;tmp下，目录结构不变</span><br><span class="line">7.将&#x2F;etc目录复制到&#x2F;var&#x2F;tmp&#x2F;,&#x2F;var&#x2F;tmp&#x2F;etc的所有目录权限777&#x2F;var&#x2F;tmp&#x2F;etc目录中所有文件权限666</span><br><span class="line">8.保留&#x2F;var&#x2F;log&#x2F;下最近7天的日志文件,其他全部删除</span><br><span class="line">9.创建touch file&#123;1..10&#125;10个文件, 保留file9,其他一次全部删除</span><br><span class="line">10.解释如下每条命令含义</span><br><span class="line">mkdir &#x2F;root&#x2F;dir1</span><br><span class="line">touch &#x2F;root&#x2F;dir1&#x2F;file&#123;1..10&#125;</span><br><span class="line">find &#x2F;root&#x2F;dir1 -type f -name &quot;file5&quot;</span><br><span class="line">find &#x2F;root&#x2F;dir1 ! -name &quot;file5&quot;</span><br><span class="line">find &#x2F;root&#x2F;dir1 -name &quot;file5&quot; -o -name &quot;file9&quot;</span><br><span class="line">find &#x2F;root&#x2F;dir1 -name &quot;file5&quot; -o -name &quot;file9&quot; -ls</span><br><span class="line">find &#x2F;root&#x2F;dir1 \( -name &quot;file5&quot; -o -name &quot;file9&quot; \) -ls</span><br><span class="line">find &#x2F;root&#x2F;dir1 \( -name &quot;file5&quot; -o -name &quot;file9&quot; \) -exec rm -rvf &#123;&#125; \;</span><br><span class="line">find &#x2F;root&#x2F;dir1  ! \( -name &quot;file4&quot; -o -name &quot;file8&quot; \) -exec rm -vf &#123;&#125;  \;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1-find查找概述&quot;&gt;&lt;a href=&quot;#1-find查找概述&quot; class=&quot;headerlink&quot; title=&quot;1.find查找概述&quot;&gt;&lt;/a&gt;1.find查找概述&lt;/h2&gt;&lt;p&gt;&lt;em&gt;为什么要有文件查找，因为很多时候我们可能会忘了某个文件所在的位置，此
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>10-Linux——文件查找</title>
    <link href="http://yoursite.com/2019/03/02/Linux%E2%80%94%E2%80%94%E6%96%87%E4%BB%B6%E6%9F%A5%E6%89%BE/"/>
    <id>http://yoursite.com/2019/03/02/Linux%E2%80%94%E2%80%94%E6%96%87%E4%BB%B6%E6%9F%A5%E6%89%BE/</id>
    <published>2019-03-02T14:19:20.000Z</published>
    <updated>2020-08-18T12:13:25.467Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-find查找概述"><a href="#1-find查找概述" class="headerlink" title="1.find查找概述"></a>1.find查找概述</h2><p><em>为什么要有文件查找，因为很多时候我们可能会忘了某个文件所在的位置，此时就需要通过find来查找。<br>find命令可以根据不同的条件来进行查找文件，例如：文件名称、文件大小、文件修改时间、属主属组、权限、等等方式。同时find命令是Linux下必须掌握的。</em></p><p><strong><em>find 命令的基本语法如下\</em></strong></p><table><thead><tr><th>命令</th><th>路径</th><th>选项</th><th>表达式</th><th>动作</th></tr></thead><tbody><tr><td>find</td><td>[path…]</td><td>[options]</td><td>[expression]</td><td>[action]</td></tr><tr><td>查找</td><td>地区</td><td>妹纸</td><td>18-25岁</td><td>约?</td></tr></tbody></table><h2 id="2-find查找示例"><a href="#2-find查找示例" class="headerlink" title="2.find查找示例"></a>2.find查找示例</h2><p><strong><em>以下列出所有find常用的选项\</em></strong></p><h3 id="1-find名称查找"><a href="#1-find名称查找" class="headerlink" title="1.find名称查找"></a><em>1.find名称查找</em></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#1.创建文件</span><br><span class="line">touch &#x2F;etc&#x2F;sysconfig&#x2F;network-scripts&#x2F;&#123;ifcfg-eth1,IFCFG-ETH1&#125;</span><br><span class="line"></span><br><span class="line">#2.查找&#x2F;etc目录下包含ifcfg-eth0名称的文件</span><br><span class="line">[root@lqz ~]# find &#x2F;etc -name &quot;ifcfg-eth1&quot;</span><br><span class="line"></span><br><span class="line">#3.-i 忽略大小写</span><br><span class="line">[root@lqz ~]# find &#x2F;etc -iname &quot;ifcfg-eth1&quot;</span><br><span class="line">#查找&#x2F;etc目录下包含ifcfg-eth名称所有文件</span><br><span class="line">[root@lqz ~]# find &#x2F;etc&#x2F; -name &quot;ifcfg-eth*&quot;</span><br><span class="line">[root@lqz ~]# find &#x2F;etc -iname &quot;ifcfg-eth*&quot;</span><br></pre></td></tr></table></figure><h3 id="2-find大小查找"><a href="#2-find大小查找" class="headerlink" title="2.find大小查找"></a><em>2.find大小查找</em></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#1.查找大于5M的文件</span><br><span class="line">[root@lqz ~]# find &#x2F;etc -size +5M</span><br><span class="line"></span><br><span class="line">#2.查找等于5M的文件</span><br><span class="line">[root@lqz ~]# find &#x2F;etc -size 5M</span><br><span class="line"></span><br><span class="line">#3.查找小于5M的文件</span><br><span class="line">[root@lqz ~]# find &#x2F;etc -size -5M</span><br></pre></td></tr></table></figure><h3 id="3-find类型查找"><a href="#3-find类型查找" class="headerlink" title="3.find类型查找"></a><em>3.find类型查找</em></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"># f 文件</span><br><span class="line">[root@lqz ~]# find &#x2F;dev -type f</span><br><span class="line"># d 目录</span><br><span class="line">[root@lqz ~]# find &#x2F;dev -type d</span><br><span class="line"># l 链接</span><br><span class="line">[root@lqz ~]# find &#x2F;dev -type l</span><br><span class="line"># b 块设备</span><br><span class="line">[root@lqz ~]# find &#x2F;dev -type b</span><br><span class="line"># c 字符设备</span><br><span class="line">[root@lqz ~]# find &#x2F;dev -type c</span><br><span class="line"># s 套接字</span><br><span class="line">[root@lqz ~]# find &#x2F;dev -type s</span><br><span class="line"># p 管道文件</span><br><span class="line">[root@lqz ~]# find &#x2F;dev -type p</span><br></pre></td></tr></table></figure><h3 id="4-find时间查找"><a href="#4-find时间查找" class="headerlink" title="4.find时间查找"></a><em>4.find时间查找</em></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">#1.创建测试文件(后期shell会讲)</span><br><span class="line">[root@lqz ~]# for i in &#123;01..28&#125;;do date -s  201904$i &amp;&amp; touch file-$i;done</span><br><span class="line"></span><br><span class="line">#2.查找7天以前的文件(不会打印当天的文件)</span><br><span class="line">[root@lqz ~]# find .&#x2F; -iname &quot;file-*&quot; -mtime +7</span><br><span class="line"></span><br><span class="line">#3.查找最近7天的文件，不建议使用(会打印当天的文件)</span><br><span class="line">[root@lqz ~]# find .&#x2F; -iname &quot;file-*&quot; -mtime -7</span><br><span class="line"></span><br><span class="line">#4.查找第7天文件(不会打印当天的文件)</span><br><span class="line">[root@lqz ~]# find .&#x2F; -iname &quot;file-*&quot; -mtime 7</span><br><span class="line"></span><br><span class="line">#5.本地文件保留最近7天的备份文件, 备份服务器保留3个月的备份文件(实际使用方案)</span><br><span class="line">find &#x2F;backup&#x2F; -iname &quot;*.bak&quot; -mtime +7 -delete</span><br><span class="line">find &#x2F;backup&#x2F; -iname &quot;*.bak&quot; -mtime +90 -delete</span><br></pre></td></tr></table></figure><h3 id="5-find用户查找"><a href="#5-find用户查找" class="headerlink" title="5.find用户查找"></a><em>5.find用户查找</em></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">#查找属主是jack</span><br><span class="line">[root@lqz ~]# find &#x2F;home -user jack</span><br><span class="line">#查找属组是admin</span><br><span class="line">[root@lqz ~]# find &#x2F;home -group admin</span><br><span class="line">#查找属主是jack, 属组是admin</span><br><span class="line">[root@lqz ~]# find &#x2F;home -user jack -group admin</span><br><span class="line">#查找属主是jack, 并且属组是admin</span><br><span class="line">[root@lqz ~]# find &#x2F;home -user jack -a -group admin</span><br><span class="line">#查找属主是jack, 或者属组是admin</span><br><span class="line">[root@lqz ~]# find &#x2F;home -user jack -o -group admin</span><br><span class="line">#查找没有属主</span><br><span class="line">[root@lqz ~]# find &#x2F;home -nouser</span><br><span class="line">#查找没有属组</span><br><span class="line">[root@lqz ~]# find &#x2F;home -nogroup</span><br><span class="line">#查找没有属主或属组</span><br><span class="line">[root@lqz ~]# find &#x2F;home -nouser -o -nogroup</span><br></pre></td></tr></table></figure><h3 id="6-find权限查找"><a href="#6-find权限查找" class="headerlink" title="6.find权限查找"></a><em>6.find权限查找</em></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">#精切匹配644权限</span><br><span class="line">[root@lqz ~]# find . -perm 644 -ls</span><br><span class="line"></span><br><span class="line">#包含444权限即可</span><br><span class="line">[root@lqz ~]# find . -perm -444  -ls</span><br><span class="line">#查找全局可写(每位权限必须包含w)</span><br><span class="line">[root@lqz ~]# find . -perm -222 -ls</span><br><span class="line">#包含set uid</span><br><span class="line">[root@lqz ~]# find  &#x2F;usr&#x2F;sbin -perm -4000 -ls</span><br><span class="line">#包含set gid</span><br><span class="line">[root@lqz ~]# find  &#x2F;usr&#x2F;sbin -perm -2000 -ls</span><br><span class="line">#包含sticky</span><br><span class="line">[root@lqz ~]# find  &#x2F;usr&#x2F;sbin -perm -1000 -ls</span><br></pre></td></tr></table></figure><p><strong><em>2.find动作处理，比如查找到一个文件后，需要对文件进行如何处理, find的默认动作是 -print\</em></strong></p><table><thead><tr><th>动作</th><th>含义</th></tr></thead><tbody><tr><td>-print</td><td>打印查找到的内容(默认)</td></tr><tr><td>-ls</td><td>以长格式显示的方式打印查找到的内容</td></tr><tr><td>-delete</td><td>删除查找到的文件(仅能删除空目录)</td></tr><tr><td>-ok</td><td>后面跟自定义 shell 命令(会提示是否操作)</td></tr><tr><td>-exec</td><td>后面跟自定义 shell 命令(标准写法 -exec ;)</td></tr></tbody></table><p><em>1.find查找后的动作命令示例</em></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">#1.使用-print打印查找到的文件</span><br><span class="line">[root@lqz ~]# find &#x2F;etc -name &quot;ifcfg*&quot;</span><br><span class="line">[root@lqz ~]# find &#x2F;etc -name &quot;ifcfg*&quot; -print</span><br><span class="line"></span><br><span class="line">#2.使用-ls打印查找到的文件，以长格式显示</span><br><span class="line">[root@lqz ~]# find &#x2F;etc -name &quot;ifcfg*&quot; -ls</span><br><span class="line"></span><br><span class="line">#3.使用-delete删除文件，但仅能删除空目录</span><br><span class="line">[root@lqz ~]# find &#x2F;etc -name &quot;ifcfg*&quot; -delete</span><br><span class="line"></span><br><span class="line">#4.使用-ok实现文件拷贝，但会提示是否拷贝</span><br><span class="line">[root@lqz ~]# find &#x2F;etc -name &quot;ifcfg*&quot; -ok cp -rvf &#123;&#125; &#x2F;tmp \;</span><br><span class="line"></span><br><span class="line">#5.使用-exec实现文件拷贝和文件删除。</span><br><span class="line">[root@lqz ~]# find &#x2F;etc -name &quot;ifcfg*&quot; -exec cp -rvf &#123;&#125; &#x2F;tmp \;</span><br><span class="line">[root@lqz ~]# find &#x2F;etc -name &quot;ifcfg*&quot; -exec rm -f &#123;&#125; \;</span><br></pre></td></tr></table></figure><p><em>2.使用find命令结合xargs</em></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#xargs将前者命令查找到的文件作为一个整体传递后者命令的输入</span><br><span class="line">[root@lqz ~]# touch file.txt</span><br><span class="line">[root@lqz ~]# find . -name &quot;file.txt&quot; |xargs rm -f</span><br><span class="line">[root@lqz ~]# find . -name &quot;file.txt&quot; |xargs -I &#123;&#125; cp -rvf &#123;&#125; &#x2F;var&#x2F;tmp</span><br></pre></td></tr></table></figure><p><em>3.find逻辑运算符</em></p><table><thead><tr><th>符号</th><th>作用</th></tr></thead><tbody><tr><td>-a</td><td>与</td></tr><tr><td>-o</td><td>或</td></tr><tr><td>-not|!</td><td>非</td></tr></tbody></table><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#1.查找当前目录下，属主不是hdfs的所有文件</span><br><span class="line">[root@lqz ~]# find . -not -user hdfs </span><br><span class="line">[root@lqz ~]# find . ! -user hdfs</span><br><span class="line">        </span><br><span class="line">#2.查找当前目录下，属主属于hdfs，且大小大于300字节的文件</span><br><span class="line">[root@lqz ~]# find . -type f -a -user hdfs -a -size +300c</span><br><span class="line">            </span><br><span class="line">#3.查找当前目录下的属主为hdfs或者以xml结尾的普通文件</span><br><span class="line">[root@lqz ~]# find . -type f -a \( -user hdfs -o -name &#39;*.xml&#39; \)</span><br></pre></td></tr></table></figure><p><em>4.find相关练习题</em></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">1.查找&#x2F;tmp目录下，属主不是root，且文件名不以f开头的文件</span><br><span class="line">2.查找&#x2F;var目录下属主为root，且属组为mail的所有文件</span><br><span class="line">3.查找&#x2F;var目录下不属于root、lp、gdm的所有文件</span><br><span class="line">4.查找&#x2F;var目录下最近一周内其内容修改过，同时属主不为root，也不是postfix的文件</span><br><span class="line">5.查找&#x2F;etc目录下大于1M且类型为普通文件的所有文件</span><br><span class="line">6.将&#x2F;etc&#x2F;中的所有目录(仅目录)复制到&#x2F;tmp下，目录结构不变</span><br><span class="line">7.将&#x2F;etc目录复制到&#x2F;var&#x2F;tmp&#x2F;,&#x2F;var&#x2F;tmp&#x2F;etc的所有目录权限777&#x2F;var&#x2F;tmp&#x2F;etc目录中所有文件权限666</span><br><span class="line">8.保留&#x2F;var&#x2F;log&#x2F;下最近7天的日志文件,其他全部删除</span><br><span class="line">9.创建touch file&#123;1..10&#125;10个文件, 保留file9,其他一次全部删除</span><br><span class="line">10.解释如下每条命令含义</span><br><span class="line">mkdir &#x2F;root&#x2F;dir1</span><br><span class="line">touch &#x2F;root&#x2F;dir1&#x2F;file&#123;1..10&#125;</span><br><span class="line">find &#x2F;root&#x2F;dir1 -type f -name &quot;file5&quot;</span><br><span class="line">find &#x2F;root&#x2F;dir1 ! -name &quot;file5&quot;</span><br><span class="line">find &#x2F;root&#x2F;dir1 -name &quot;file5&quot; -o -name &quot;file9&quot;</span><br><span class="line">find &#x2F;root&#x2F;dir1 -name &quot;file5&quot; -o -name &quot;file9&quot; -ls</span><br><span class="line">find &#x2F;root&#x2F;dir1 \( -name &quot;file5&quot; -o -name &quot;file9&quot; \) -ls</span><br><span class="line">find &#x2F;root&#x2F;dir1 \( -name &quot;file5&quot; -o -name &quot;file9&quot; \) -exec rm -rvf &#123;&#125; \;</span><br><span class="line">find &#x2F;root&#x2F;dir1  ! \( -name &quot;file4&quot; -o -name &quot;file8&quot; \) -exec rm -vf &#123;&#125;  \;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1-find查找概述&quot;&gt;&lt;a href=&quot;#1-find查找概述&quot; class=&quot;headerlink&quot; title=&quot;1.find查找概述&quot;&gt;&lt;/a&gt;1.find查找概述&lt;/h2&gt;&lt;p&gt;&lt;em&gt;为什么要有文件查找，因为很多时候我们可能会忘了某个文件所在的位置，此
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>9-Linux——输入输出</title>
    <link href="http://yoursite.com/2019/03/01/Linux%E2%80%94%E2%80%94%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/"/>
    <id>http://yoursite.com/2019/03/01/Linux%E2%80%94%E2%80%94%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/</id>
    <published>2019-03-01T14:09:27.000Z</published>
    <updated>2020-08-18T12:13:02.625Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-重定向概述"><a href="#1-重定向概述" class="headerlink" title="1.重定向概述"></a>1.重定向概述</h2><h3 id="1-什么是重定向"><a href="#1-什么是重定向" class="headerlink" title="1.什么是重定向"></a>1.什么是重定向</h3><p>将原本要输出到屏幕的数据信息，重新定向到某个指定的文件中。比如：每天凌晨定时备份数据，希望将备份数据的结果保存到某个文件中。这样第二天通过查看文件的内容就知道昨天备份的数据是成功还是失败。</p><h3 id="2-为何要使用重定向"><a href="#2-为何要使用重定向" class="headerlink" title="2.为何要使用重定向"></a>2.为何要使用重定向</h3><p>1.当屏幕输出的信息很重要，而且希望保存重要的信息时；<br>2.后台执行中的程序，不希望他干扰屏幕正常的输出结果时；<br>3.系统的例行命令, 例如定时任务的执行结果，希望可以存下来时；<br>4.一些执行命令，我们已经知道他可能出现错误信息, 想将他直接丢弃时;<br>5.错误日志与正确日志需要分别输出至不同的文件保存时;</p><h3 id="3-学习重定向的预备知识，标准输入与输出"><a href="#3-学习重定向的预备知识，标准输入与输出" class="headerlink" title="3.学习重定向的预备知识，标准输入与输出"></a>3.学习重定向的预备知识，标准输入与输出</h3><p>当运行一个程序时通常会自动打开三个标准文件，分别是标准输入、标准输出、错误输出</p><table><thead><tr><th>名称</th><th>文件描述符</th><th>作用</th></tr></thead><tbody><tr><td>标准输入（STDIN）</td><td>0</td><td>默认是键盘，也可以是文件或其他命令的输出。</td></tr><tr><td>标准输出（STDOUT）</td><td>1</td><td>默认输出到屏幕。</td></tr><tr><td>错误输出（STDERR）</td><td>2</td><td>默认输出到屏幕。</td></tr><tr><td>文件名称（filename）</td><td>3+</td><td></td></tr></tbody></table><p>进程将从标准输入中得到数据，将正常输出打印至屏幕终端，将错误的输出信息也打印至屏幕终端。<br>PS: 进程是使用文件描述符<code>(file descriptors)</code>来管理打开的文件</p><p><img src= "/img/loading.gif" data-src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ghu6zkd78jj30yc0aiq4f.jpg" alt="img"></p><p>以 cat 命令为例, cat 命令的功能是从命令行给出的文件中读取数据，并将这些数据直接送到标准输出。若使用如下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#会把文件&#x2F;etc&#x2F;passwd的内容输出显示到屏幕上</span><br><span class="line">[root@lqz ~]# cat &#x2F;etc&#x2F;passwd</span><br></pre></td></tr></table></figure><p>但如果 使用 cat 命令没有跟上输入的文件名，那么cat命令则会通过命令行标准输入中读取数据, 并将其送到标准输出。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@lqz ~]# cat</span><br><span class="line">hello   #标准输入</span><br><span class="line">hello   #标准输出</span><br><span class="line">^C</span><br><span class="line">#用户输入的每一行都立刻被cat命令输出到屏幕上。</span><br></pre></td></tr></table></figure><p>下面了解一下标准输入输出过程</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">#持续追踪查看文件内容</span><br><span class="line">[root@lqz ~]# tail -f &#x2F;etc&#x2F;passwd</span><br><span class="line">ctrl+z 将进程转到后台</span><br><span class="line"></span><br><span class="line">#查看运行的进程</span><br><span class="line">[root@lqz ~]# ps</span><br><span class="line">PID TTY          TIME CMD</span><br><span class="line">5848 pts&#x2F;1    00:00:00 bash</span><br><span class="line">6885 pts&#x2F;1    00:00:00 tail</span><br><span class="line">6888 pts&#x2F;1    00:00:00 ps</span><br><span class="line"></span><br><span class="line">#查看tail命令的pid，6885进程下的文件描述符</span><br><span class="line">[root@lqz ~]# ls -l &#x2F;proc&#x2F;6885&#x2F;fd</span><br><span class="line">total 0</span><br><span class="line">lrwx------ 1 root root 64 Dec  3 06:57 0 -&gt; &#x2F;dev&#x2F;pts&#x2F;1</span><br><span class="line">lrwx------ 1 root root 64 Dec  3 06:57 1 -&gt; &#x2F;dev&#x2F;pts&#x2F;1</span><br><span class="line">lrwx------ 1 root root 64 Dec  3 06:56 2 -&gt; &#x2F;dev&#x2F;pts&#x2F;1</span><br><span class="line">lr-x------ 1 root root 64 Dec  3 06:57 3 -&gt; &#x2F;etc&#x2F;passwd</span><br><span class="line">lr-x------ 1 root root 64 Dec  3 06:57 4 -&gt; inotify</span><br><span class="line"></span><br><span class="line">#Linux查看标准输入输出设备</span><br><span class="line">[root@lqz ~]# ls -l &#x2F;dev&#x2F;std</span><br><span class="line">lrwxrwxrwx 1 root root 15 Dec  2 22:30 &#x2F;dev&#x2F;stderr -&gt; &#x2F;proc&#x2F;self&#x2F;fd&#x2F;2</span><br><span class="line">lrwxrwxrwx 1 root root 15 Dec  2 22:30 &#x2F;dev&#x2F;stdin -&gt; &#x2F;proc&#x2F;self&#x2F;fd&#x2F;0</span><br><span class="line">lrwxrwxrwx 1 root root 15 Dec  2 22:30 &#x2F;dev&#x2F;stdout -&gt; &#x2F;proc&#x2F;self&#x2F;fd&#x2F;1</span><br></pre></td></tr></table></figure><h2 id="2-输出重定向"><a href="#2-输出重定向" class="headerlink" title="2.输出重定向"></a>2.输出重定向</h2><p>输出重定向，改变输出内容的位置。输出重定向有如下几种方式，如表格所示</p><table><thead><tr><th>类型</th><th>操作符</th><th>用途</th></tr></thead><tbody><tr><td>标准覆盖输出重定向</td><td>&gt;</td><td>将程序输出的正确结果输出到指定的文件中,会覆盖文件原有的内容</td></tr><tr><td>标准追加输出重定向</td><td>&gt;&gt;</td><td>将程序输出的正确结果以追加的方式输出到指定文件，不会覆盖原有文件</td></tr><tr><td>错误覆盖输出重定向</td><td>2&gt;</td><td>将程序的错误结果输出到执行的文件中，会覆盖文件原有的内容</td></tr><tr><td>错误追加输出重定向</td><td>2&gt;&gt;</td><td>将程序输出的错误结果以追加的方式输出到指定文件，不会覆盖原有文件</td></tr><tr><td>标准输入重定向</td><td>&lt;&lt;</td><td>将命令中接收输入的途径由默认的键盘更改为指定的文件或命令</td></tr></tbody></table><p>案例1: 标准输出重定向(每次都会覆盖文件)</p><p><img src= "/img/loading.gif" data-src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ghu6zr5e8fj30wi080t9p.jpg" alt="img"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#标准输出重定向, 先清空,后写入, 如果文件不存在则创建</span><br><span class="line">[root@lqz ~]# ifconfig eth0 &gt; abc</span><br></pre></td></tr></table></figure><p>案例2: 标准输出重定向(会往文件的尾部在添加内容)</p><p><img src= "/img/loading.gif" data-src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ghu6zuf2cij30xw07sab7.jpg" alt="img"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#标准追加输出重定向, 向配置文件末尾追加内容</span><br><span class="line">[lqz@lqz ~]$ echo &quot;This is network conf&quot; &gt;&gt; if</span><br></pre></td></tr></table></figure><p>案例3: 错误输出重定向</p><p><img src= "/img/loading.gif" data-src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ghu6zynvp1j30ve07gt9o.jpg" alt="img"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#正确输出以及错误输出重定向至一个文件</span><br><span class="line">[root@lqz ~]# useradd lqz</span><br><span class="line">[root@lqz ~]# su - lqz</span><br><span class="line"></span><br><span class="line">#将标准输出和标准错误输出重定向到不同文件</span><br><span class="line">[lqz@lqz ~]$ find &#x2F;etc -name &quot;.conf&quot; 1&gt;a 2&gt;b</span><br></pre></td></tr></table></figure><p>案例4: 正确和错误都输入到相同位置<br><img src= "/img/loading.gif" data-src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ghu7036uqqj30ty07caay.jpg" alt="img"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#将标准输出和标准错误输出重定向到同一个文件, 混合输出</span><br><span class="line">[lqz@lqz ~]$ find &#x2F;etc -name &quot;.conf&quot; &amp;&gt;ab</span><br><span class="line"></span><br><span class="line">#合并两个文件内容至一个文件</span><br><span class="line">[lqz@lqz ~]$ cat a b &gt; c</span><br></pre></td></tr></table></figure><p>案例5: 正确和错误都输入到相同位置<br><img src= "/img/loading.gif" data-src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ghu7073zxqj30ti082t9p.jpg" alt="img"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#重定向到相同的位置</span><br><span class="line">[root@lqz ~]# ls &#x2F;root &#x2F;error &gt;ab  2&gt;&amp;1</span><br></pre></td></tr></table></figure><p>案例6: 重定向到空设备/dev/null</p><p><img src= "/img/loading.gif" data-src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ghu70hz0o2j30xo0840tv.jpg" alt="img"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#将产生的任何数据放入黑洞设备，则视为丢弃。</span><br><span class="line">[root@lqz ~]# ls &#x2F;root &#x2F;error &gt;ab 2&gt;&#x2F;dev&#x2F;null</span><br><span class="line">[root@lqz ~]# ls &#x2F;root &#x2F;error &gt;ab &amp;&gt;&#x2F;dev&#x2F;null</span><br></pre></td></tr></table></figure><p>案例7: 脚本中使用重定向 (了解即可)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">[root@lqz ~]# vim ping.sh </span><br><span class="line">ping -c1 10.0.0.1</span><br><span class="line">if [ $? -eq 0 ];then</span><br><span class="line">    echo &quot;10.0.0.1 is up.&quot; </span><br><span class="line">else</span><br><span class="line">    echo &quot;10.0.0.1 is down.&quot; </span><br><span class="line">fi</span><br><span class="line">[root@lqz ~]# chmod +x ping.sh </span><br><span class="line">[root@lqz ~]# .&#x2F;ping.sh</span><br><span class="line"></span><br><span class="line">#改进后版</span><br><span class="line">[root@lqz ~]# vim ping.sh</span><br><span class="line">ping -c1 10.0.0.1 &amp;&gt;&#x2F;dev&#x2F;null</span><br><span class="line">if [ $? -eq 0 ];then</span><br><span class="line">    echo &quot;10.0.0.1 is up.&quot; </span><br><span class="line">else</span><br><span class="line">    echo &quot;10.0.0.1 is down.&quot; </span><br><span class="line">fi</span><br></pre></td></tr></table></figure><p>案例8: 脚本中使用重定向 (了解即可)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[root@lqz ~]# vim ping2.sh </span><br><span class="line">ping -c1 10.0.0.1 &amp;&gt;&#x2F;dev&#x2F;null </span><br><span class="line">if [ $? -eq 0 ];then</span><br><span class="line">    echo &quot;10.0.0.1 is up.&quot; &gt;&gt;up.txt </span><br><span class="line">else</span><br><span class="line">    echo &quot;10.0.0.1 is down.&quot; &gt;&gt;down.txt </span><br><span class="line">fi</span><br><span class="line">[root@lqz ~]# chmod +x ping2.sh </span><br><span class="line">[root@lqz ~]# .&#x2F;ping2.sh</span><br></pre></td></tr></table></figure><h2 id="3-输入重定向"><a href="#3-输入重定向" class="headerlink" title="3.输入重定向"></a>3.输入重定向</h2><p>输入重定向，即原本从键盘等上获得的输入信息，重定向由命令的输出作为输入。&lt; 等价 0&lt;</p><p>案例1: 从文件中读入输入的操作</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">#没有改变输入的方向，默认键盘</span><br><span class="line">[root@lqz ~]# mail alice </span><br><span class="line">Subject: hello</span><br><span class="line">1111 </span><br><span class="line">2222</span><br><span class="line">3333</span><br><span class="line">.   #结束</span><br><span class="line">EOT</span><br><span class="line"></span><br><span class="line">#检查是否收到邮件</span><br><span class="line">[root@lqz ~]# su - alice</span><br><span class="line">[root@lqz ~]# mail</span><br><span class="line"></span><br><span class="line">#输入重定向，来自于文件</span><br><span class="line">[root@lqz ~]# mail -s &quot;test01&quot; alice &lt; &#x2F;etc&#x2F;hosts</span><br></pre></td></tr></table></figure><p>案例2: 无法形容案例，请看实际操作</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#没有改变输入的方向，默认键盘，此时等待输入</span><br><span class="line">[root@lqz ~]# grep &#39;root&#39; </span><br><span class="line">xxx</span><br><span class="line">xxx</span><br><span class="line"></span><br><span class="line">[root@lqz ~]# grep &#39;root&#39; &lt; &#x2F;etc&#x2F;passwd</span><br><span class="line">root:x:0:0:root:&#x2F;root:&#x2F;bin&#x2F;bash</span><br></pre></td></tr></table></figure><p>案例3: 无法形容案例，请看实际操作</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@lqz ~]# dd if&#x3D;&#x2F;dev&#x2F;zero of&#x3D;&#x2F;file1.txt bs&#x3D;1M count&#x3D;20</span><br><span class="line">[root@lqz ~]# dd &lt;&#x2F;dev&#x2F;zero &gt;&#x2F;file2.txt bs&#x3D;1M count&#x3D;20</span><br></pre></td></tr></table></figure><p>案例4: mysql如何恢复备份，了解即可，不用关注。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@lqz ~]# mysql -uroot -p123 &lt; bbs.sql</span><br></pre></td></tr></table></figure><p>案例5: 利用重定向建立多行数据的文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">#手动执行 shell 命令</span><br><span class="line">[root@lqz ~]# echo &quot;111&quot; &gt; file1.txt </span><br><span class="line">[root@lqz ~]# cat file1.txt</span><br><span class="line">111</span><br><span class="line">[root@lqz ~]# cat &gt;file2.txt</span><br><span class="line">111</span><br><span class="line">222</span><br><span class="line">333</span><br><span class="line">^D</span><br><span class="line"></span><br><span class="line">[root@lqz ~]# cat &gt;&gt;file3.txt</span><br><span class="line">aaa</span><br><span class="line">bbb</span><br><span class="line">ccc</span><br><span class="line">^D</span><br></pre></td></tr></table></figure><p>案例6: 脚本中打印菜单的一种使用方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">[root@lqz ~]# vim vm.sh</span><br><span class="line">cat &lt;&lt;-EOF</span><br><span class="line">+------------------- --- ---- --- ---- --- --- ---- --- --+ ||</span><br><span class="line">| &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; | </span><br><span class="line">| 虚拟机基本管理 v5.0 |</span><br><span class="line">| by lqz |</span><br><span class="line">| &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; | </span><br><span class="line">| 1. 安装 KVM |</span><br><span class="line">| 2. 安装或重置 CentOS-6.9 | </span><br><span class="line">| 3. 安装或重置 CentOS-7.4 | </span><br><span class="line">| 5. 安装或重置 Windows-7  | </span><br><span class="line">| 6. 删除所有虚拟机 |</span><br><span class="line">| q. 退出管理程序 |</span><br><span class="line">+------------------- --- ---- --- ---- --- --- ---- --- --+ </span><br><span class="line">EOF</span><br></pre></td></tr></table></figure><p>案例7: 两条命令同时重定向</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[root@lqz ~]# ls; date &amp;&gt;&#x2F;dev&#x2F;null</span><br><span class="line">[root@lqz ~]# ls &amp;&gt;&#x2F;dev&#x2F;null; date &amp;&gt;&#x2F;dev&#x2F;null</span><br><span class="line">[root@lqz ~]# (ls; date) &amp;&gt;&#x2F;dev&#x2F;null</span><br><span class="line"></span><br><span class="line">#后台执行</span><br><span class="line">[root@lqz ~]# (while :; do date; sleep 2; done) &amp;</span><br><span class="line">[1] 6378</span><br><span class="line">[root@lqz ~]# (while :; do date; sleep 2; done) &amp;&gt;date.txt &amp;</span><br><span class="line">[root@lqz ~]# jobs</span><br><span class="line">[1]+ 运行中 ( while :; do date; sleep 2;</span><br><span class="line">done ) &amp;&gt;&#x2F;date.txt &amp;</span><br></pre></td></tr></table></figure><p>扩展点: subshell 了解即可</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@lqz ~]# cd &#x2F;boot; ls</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;subshell 中执行</span><br><span class="line">[root@lqz ~]# (cd &#x2F;boot; ls)</span><br><span class="line"></span><br><span class="line">#如果不希望某些命令的执行对当前 shell 环境产生影响，请在subshell中执行</span><br></pre></td></tr></table></figure><h2 id="4-进程管道技术"><a href="#4-进程管道技术" class="headerlink" title="4.进程管道技术"></a>4.进程管道技术</h2><h3 id="1-什么是管道"><a href="#1-什么是管道" class="headerlink" title="1.什么是管道"></a>1.什么是管道</h3><p>管道操作符号 “|” ，主要用来连接左右两个命令, 将左侧的命令的标准输出, 交给右侧命令的标准输入<br>PS: 无法传递标准错误输出至后者命令</p><h3 id="2-管道流程示意图"><a href="#2-管道流程示意图" class="headerlink" title="2.管道流程示意图"></a>2.管道流程示意图</h3><p><img src= "/img/loading.gif" data-src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ghu70of8auj30wk07kdgh.jpg" alt="img"><br>格式: <code>cmd1 | cmd2 [...|cmdn]</code></p><h3 id="3-管道使用案例"><a href="#3-管道使用案例" class="headerlink" title="3.管道使用案例"></a>3.管道使用案例</h3><p>案例1: 将/etc/passwd 中的用户按 UID 大小排序</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@lqz ~]# sort -t&quot;:&quot; -k3 -n &#x2F;etc&#x2F;passwd</span><br><span class="line">[root@lqz ~]# sort -t&quot;:&quot; -k3 -n &#x2F;etc&#x2F;passwd -r</span><br><span class="line">[root@lqz ~]# sort -t&quot;:&quot; -k3 -n &#x2F;etc&#x2F;passwd |head</span><br></pre></td></tr></table></figure><p>案例2: 统计当前/etc/passwd 中用户使用的 shell 类型</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#思路:取出第七列(shell) | 排序(把相同归类)| 去重</span><br><span class="line">[root@lqz ~]# awk -F: &#39;&#123;print $7&#125;&#39; &#x2F;etc&#x2F;passwd</span><br><span class="line">[root@lqz ~]# awk -F: &#39;&#123;print $7&#125;&#39; &#x2F;etc&#x2F;passwd |sort</span><br><span class="line">[root@lqz ~]# awk -F: &#39;&#123;print $7&#125;&#39; &#x2F;etc&#x2F;passwd |sort |uniq</span><br><span class="line">[root@lqz ~]# awk -F: &#39;&#123;print $7&#125;&#39; &#x2F;etc&#x2F;passwd |sort |uniq -c</span><br></pre></td></tr></table></figure><p>案例4: 统计网站的访问情况 top 20</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#思路: 打印所有访问的连接 | 过滤访问网站的连接 | 打印用户的 IP | 排序 | 去重</span><br><span class="line"></span><br><span class="line">[root@lqz ~]# yum -y install httpd</span><br><span class="line">[root@lqz ~]# systemctl start httpd</span><br><span class="line">[root@lqz ~]# systemctl stop firewalld</span><br><span class="line"></span><br><span class="line">[root@lqz ~]# ss -an |grep :80 |awk -F&quot;:&quot; &#39;&#123;print $8&#125;&#39; |sort |uniq -c</span><br><span class="line">[root@lqz ~]# ss -an |grep :80 |awk -F&quot;:&quot; &#39;&#123;print $8&#125;&#39; |sort |uniq -c |sort -k1 -rn |head -n 20</span><br></pre></td></tr></table></figure><p>案例5: 打印当前所有 IP</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@lqz ~]# ip addr |grep &#39;inet &#39; |awk &#39;&#123;print $2&#125;&#39; |awk -F&quot;&#x2F;&quot; &#39;&#123;print $1&#125;&#39;</span><br><span class="line">127.0.0.1</span><br><span class="line">192.168.69.112</span><br></pre></td></tr></table></figure><p>案例6: 打印根分区已用空间的百分比(仅打印数字)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@lqz ~]# df |grep &#39;&#x2F;$&#39; |awk &#39;&#123;print $5&#125;&#39; |awk -F&quot;%&quot; &#39;&#123;print $1&#125;&#39;</span><br></pre></td></tr></table></figure><p>PS: 管道命令符能让大家能进一步掌握命令之间的搭配使用方法，进一步提高命令输出值的处理效率。</p><h3 id="4-管道中的tee技术"><a href="#4-管道中的tee技术" class="headerlink" title="4.管道中的tee技术"></a>4.管道中的tee技术</h3><p><img src= "/img/loading.gif" data-src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ghu70t1ulej30y00ayaba.jpg" alt="img"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#选项: -a追加</span><br><span class="line">[root@lqz ~]# ip addr |grep &#39;inet &#39; |tee ip.txt |awk -F&quot;&#x2F;&quot; &#39;&#123;print $1&#125;&#39; |awk &#39;&#123;print $2&#125;&#39;</span><br><span class="line">127.0.0.1</span><br><span class="line">10.0.0.100</span><br><span class="line"></span><br><span class="line">[root@lqz ~]# cat ip.txt</span><br><span class="line">inet 127.0.0.1&#x2F;8 scope host lo</span><br><span class="line">inet 10.0.0.100&#x2F;24 brd 192.168.69.255 scope global ens32</span><br></pre></td></tr></table></figure><p>重定向与 tee 有他们在使用过程中有什么区别</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@lqz ~]# date &gt; date.txt    #直接将内容写入date.txt文件中</span><br><span class="line">[root@lqz ~]# date |tee date.txt #命令执行会输出至屏幕，但会同时保存一份至date.txt文件中</span><br></pre></td></tr></table></figure><p>5.xargs参数传递，主要让一些不支持管道的命令可以使用管道技术</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># which cat|xargs ls- l</span><br><span class="line"># ls |xargs rm -fv</span><br><span class="line"># ls |xargs cp -rvt &#x2F;tmp&#x2F; -或-&gt; ls | xargs -I &#123;&#125; cp -rv &#123;&#125; &#x2F;tmp&#x2F;</span><br><span class="line"># ls |xargs mv -t &#x2F;tmp&#x2F;   -或-&gt; ls | xargs -I &#123;&#125;  mv &#123;&#125; &#x2F;tmp</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1-重定向概述&quot;&gt;&lt;a href=&quot;#1-重定向概述&quot; class=&quot;headerlink&quot; title=&quot;1.重定向概述&quot;&gt;&lt;/a&gt;1.重定向概述&lt;/h2&gt;&lt;h3 id=&quot;1-什么是重定向&quot;&gt;&lt;a href=&quot;#1-什么是重定向&quot; class=&quot;headerli
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>8-Linux——ACL控制</title>
    <link href="http://yoursite.com/2019/02/27/Linux%E2%80%94%E2%80%94ACL%E6%8E%A7%E5%88%B6/"/>
    <id>http://yoursite.com/2019/02/27/Linux%E2%80%94%E2%80%94ACL%E6%8E%A7%E5%88%B6/</id>
    <published>2019-02-27T14:12:27.000Z</published>
    <updated>2020-08-18T12:12:35.219Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-ACL访问控制概述"><a href="#1-ACL访问控制概述" class="headerlink" title="1.ACL访问控制概述"></a>1.ACL访问控制概述</h2><p>上一章节我们学习了基础权限<code>UGO</code>、特殊权限，但所有的权限是针对某一类用户设置的, 如果希望对文件进行自定义权限控制，就需要用到文件的访问控制列表<code>ACL</code></p><blockquote><p>UGO设置基本权限: 只能一个用户，一个组和其他人<br>ACL设置基本权限： r、w、x<br>设定<code>acl</code>只能是<code>root</code>管理员用户. 相关命令: <code>getfacl</code> , <code>setfacl</code></p></blockquote><p><code>acl</code>基本使用方式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;环境准备</span><br><span class="line">[root@lqz ~]# cp &#x2F;etc&#x2F;passwd &#x2F;root&#x2F;passwd</span><br><span class="line">&#x2F;&#x2F;文件在没有设定acl, 看到的和传统权限是一样</span><br><span class="line">[root@lqz ~]# ll passwd</span><br><span class="line">-rw-r--r-- 1 root root 0 10-26 13:59 &#x2F;home&#x2F;test.txt</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;使用getacl查看权限</span><br><span class="line">[root@lqz ~]# getfacl passwd </span><br><span class="line"># file: passwd</span><br><span class="line"># owner: root</span><br><span class="line"># group: root</span><br><span class="line">user::rw-   &#x2F;&#x2F;文件owner权限</span><br><span class="line">group::r--  &#x2F;&#x2F;文件拥有组权限</span><br><span class="line">other::r--  &#x2F;&#x2F;其他人权限</span><br></pre></td></tr></table></figure><h3 id="1-设定acl权限案例如下"><a href="#1-设定acl权限案例如下" class="headerlink" title="1.设定acl权限案例如下"></a>1.设定<code>acl</code>权限案例如下</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">-rw-r--r-- 1 root root 1380 Feb 27 11:25 passwd</span><br><span class="line"></span><br><span class="line">alice 拥有读写权限    rw</span><br><span class="line">bgx  没有任何权限     -</span><br><span class="line">jack 组拥有读权限     r</span><br><span class="line">匿名用户拥有读写权限  rw</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;建立相关用户</span><br><span class="line">[root@lqz ~]# useradd alice</span><br><span class="line">[root@lqz ~]# useradd bgx</span><br><span class="line">[root@lqz ~]# useradd jack</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;增加用户 alice 权限</span><br><span class="line">[root@lqz ~]# setfacl -m u:alice:rw passwd</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;增加用户 bgx 权限</span><br><span class="line">[root@lqz ~]# setfacl -m u:bgx:- passwd</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;增加匿名用户权限</span><br><span class="line">[root@lqz ~]# setfacl -m o::rw passwd</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;增加组权限</span><br><span class="line">[root@lqz ~]# setfacl -m g:jack:r passwd</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">注意: 如果用户同时属于不同的两个组，并且两个组设定了acl访问控制</span><br><span class="line">    1.根据acl访问控制优先级进行匹配规则</span><br><span class="line">    2.如有用户拥有多个组的权限不同的权限，优先使用最高权限（模糊匹配）</span><br></pre></td></tr></table></figure><h3 id="2-查看acl权限"><a href="#2-查看acl权限" class="headerlink" title="2.查看acl权限"></a>2.查看<code>acl</code>权限</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[root@lqz ~]# ll passwd</span><br><span class="line">-rw-rw-rw-+ 1 root root 1531 Jan 26 07:52 passwd</span><br><span class="line"></span><br><span class="line">[root@lqz ~]# getfacl passwd</span><br><span class="line"># file: passwd</span><br><span class="line"># owner: root</span><br><span class="line"># group: root</span><br><span class="line">user::rw-</span><br><span class="line">user:bgx:---</span><br><span class="line">user:alice:rw-</span><br><span class="line">group::r--</span><br><span class="line">group:jack:r--</span><br><span class="line">mask::rw-</span><br><span class="line">other::rw-</span><br></pre></td></tr></table></figure><h3 id="3-移除acl权限"><a href="#3-移除acl权限" class="headerlink" title="3.移除acl权限"></a>3.移除<code>acl</code>权限</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;移除jack组的acl权限</span><br><span class="line">[root@lqz ~]# setfacl -x g:jack passwd</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;移除bgx用户的acl权限</span><br><span class="line">[root@lqz ~]# setfacl -x u:bgx passwd</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;移除文件和目录所有acl权限</span><br><span class="line">[root@lqz ~]# setfacl -b passwd</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;移除默认的acl</span><br><span class="line">[root@lqz ~]# setfacl -k dir</span><br></pre></td></tr></table></figure><h3 id="4-查看acl帮助"><a href="#4-查看acl帮助" class="headerlink" title="4.查看acl帮助"></a>4.查看<code>acl</code>帮助</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;EXAMPLES 示例文档</span><br><span class="line">[root@lqz ~]# man setfacl</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;复制 file1 的 ACL 权限给 file2</span><br><span class="line">[root@lqz ~]# setfacl -m u:alice:rw,u:bgx:r,g:jack:rw file1</span><br><span class="line">[root@lqz ~]# getfacl file1 |setfacl --set-file&#x3D;- file2</span><br></pre></td></tr></table></figure><h2 id="2-ACL高级特性MASK"><a href="#2-ACL高级特性MASK" class="headerlink" title="2.ACL高级特性MASK"></a>2.ACL高级特性MASK</h2><p><code>mask</code>用于临时降低用户或组的权限，但不包括文件的所有者和其他人。<br><code>mask</code>最主要的作用是用来决定用户的最高权限。</p><blockquote><p><code>mask</code>默认不会对匿名用户降低权限，所以为了便于管理文件的访问控制，建议匿名用户的权限置为空</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;临时降低用户或组权限</span><br><span class="line">[root@lqz ~]# setfacl -m mask::rw filename</span><br></pre></td></tr></table></figure><blockquote><p>小结<br>1.<code>mask</code>会影响哪些用户，除了所有者和其他人。<br>2.<code>mask</code>权限决定了用户访问文件时的最高权限。(如何影响)<br>3.<code>mask</code>用于临时降低用户访问文件的权限。(mask做什么)<br>4.任何重新设置<code>acl</code>访问控制会清理<code>mask</code>所设定的权限。</p></blockquote><h2 id="3-ACL高级特性Default"><a href="#3-ACL高级特性Default" class="headerlink" title="3.ACL高级特性Default"></a>3.ACL高级特性Default</h2><p>default: 继承(默认)</p><p><code>alice</code>能够对<code>/opt</code>目录以及以后在<code>/opt</code>目录下新建的文件有读、写、执行权限</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;赋予 alice 对&#x2F;home 读写执行权限 </span><br><span class="line">[root@lqz ~]## setfacl -R -m u:alice:rwX &#x2F;opt</span><br><span class="line">&#x2F;&#x2F;赋予 alice 对以后在&#x2F;home 下新建的文件有读写执行权限(使 alice 的权限继承) </span><br><span class="line">[root@lqz ~]## setfacl -m d:u:alice:rwX &#x2F;opt</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;检查对应的权限</span><br><span class="line">[root@linux-node1 ~]# getfacl &#x2F;opt&#x2F;</span><br><span class="line">getfacl: Removing leading &#39;&#x2F;&#39; from absolute path names</span><br><span class="line"># file: opt&#x2F;</span><br><span class="line"># owner: root</span><br><span class="line"># group: bgx</span><br><span class="line">user::rwx</span><br><span class="line">user:alice:rwx</span><br><span class="line">group::rwx</span><br><span class="line">mask::rwx</span><br><span class="line">other::rwx</span><br><span class="line">default:user::rwx</span><br><span class="line">default:user:alice:rwx</span><br><span class="line">default:group::rwx</span><br><span class="line">default:mask::rwx</span><br><span class="line">default:other::rwx</span><br></pre></td></tr></table></figure><h2 id="4-ACL访问控制实践案例"><a href="#4-ACL访问控制实践案例" class="headerlink" title="4.ACL访问控制实践案例"></a>4.ACL访问控制实践案例</h2><p>案例1: 将新建文件的属性修改<code>tom:admin</code>, 权限默认为644<br>要求: <code>tom</code>对该文件有所有的权限, <code>mary</code>可以读写该文件, <code>admin</code>组可以读写执行该文件, <code>jack</code>只读该文件, 其他人一律不能访问该文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;实验前, 建立几个普通用户</span><br><span class="line">[root@lqz ~]# useradd tom</span><br><span class="line">[root@lqz ~]# useradd bean</span><br><span class="line">[root@lqz ~]# useradd mary</span><br><span class="line">[root@lqz ~]# useradd jack</span><br><span class="line">[root@lqz ~]# useradd sutdent</span><br><span class="line">[root@lqz ~]# groupadd admin</span><br><span class="line">[root@lqz ~]# gpasswd -a mary admin</span><br><span class="line">[root@lqz ~]# gpasswd -a bean admin</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;检查用户属性</span><br><span class="line">[root@linux-node1 ~]# id tom</span><br><span class="line">uid&#x3D;1004(tom) gid&#x3D;1004(tom) groups&#x3D;1004(tom)</span><br><span class="line">[root@linux-node1 ~]# id mary</span><br><span class="line">uid&#x3D;1006(mary) gid&#x3D;1006(mary) groups&#x3D;1006(mary),1007(admin)</span><br><span class="line">[root@linux-node1 ~]# id bean</span><br><span class="line">uid&#x3D;1005(bean) gid&#x3D;1005(bean) groups&#x3D;1005(bean),1007(admin)</span><br><span class="line">[root@linux-node1 ~]# id jack</span><br><span class="line">uid&#x3D;1002(jack) gid&#x3D;1002(jack) groups&#x3D;1002(jack)</span><br><span class="line">[root@linux-node1 ~]# id sutdent</span><br><span class="line">uid&#x3D;1007(sutdent) gid&#x3D;1008(sutdent) groups&#x3D;1008(sutdent)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;准备相关文件</span><br><span class="line">[root@linux-node1 ~]# cp &#x2F;etc&#x2F;passwd &#x2F;root&#x2F;</span><br><span class="line">[root@linux-node1 ~]# chown tom:admin passwd</span><br><span class="line">[root@linux-node1 ~]# chmod 644 passwd</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;检查设定前的acl列表</span><br><span class="line">[root@linux-node1 ~]# getfacl passwd</span><br><span class="line"># file: passwd</span><br><span class="line"># owner: tom</span><br><span class="line"># group: admin</span><br><span class="line">user::rw-</span><br><span class="line">group::r--</span><br><span class="line">other::r--</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;设定acl权限</span><br><span class="line">[root@linux-node1 ~]# setfacl -m u::rwx,u:mary:rw,u:jack:r,g:admin:rwx,o::- passwd</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;检查acl权限</span><br><span class="line">[root@linux-node1 ~]# getfacl passwd</span><br><span class="line"># file: passwd</span><br><span class="line"># owner: tom</span><br><span class="line"># group: admin</span><br><span class="line">user::rwx</span><br><span class="line">user:jack:r--</span><br><span class="line">user:mary:rw-</span><br><span class="line">group::r--</span><br><span class="line">group:admin:rwx</span><br><span class="line">mask::rwx</span><br><span class="line">other::---</span><br></pre></td></tr></table></figure><blockquote><p>acl的控制规则是从上往下匹配<br>1.<code>tom</code>由于是文件的拥有者，所以直接按照<code>user::rwx</code>指定的权限去操作<br>2.<code>mary</code>用户从上往下寻找匹配规则，发现<code>user:mary:rw-</code>能够精确匹配<code>mary</code>用户，尽管<code>mary</code>属于<code>admin</code>组，同时<code>admin</code>组有<code>rwx</code>的权限，但是由于<code>mary</code>用户的规则在前面，所有优先生效。<br>3.<code>bean</code>由于找不到精确匹配的规则，而<code>bean</code>是属于<code>admin</code>组，根据文件的定义，该文件是属于<code>admin</code>组，所以<code>bean</code>的权限是按照<code>group:admin:rwx</code>的权限去操作。<br>4.<code>jack</code>用户从上往下寻找匹配规则，发现<code>user:jack:r--</code>能够精确匹配<code>jack</code>用户。<br>5.<code>student</code>用户找不到精确匹配的<code>user</code>定义规则, 也找不到相关组的定义规则，最后属于<code>other</code>。</p></blockquote><p>案例2: <code>lab acl setup</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">controller组成员有:student</span><br><span class="line">sodor组成员有:thomas,james</span><br><span class="line"></span><br><span class="line">目录: &#x2F;shares&#x2F;steamies</span><br><span class="line">文件: &#x2F;shares&#x2F;steamies&#x2F;file</span><br><span class="line">脚本: &#x2F;shares&#x2F;steamies&#x2F;test.sh</span><br><span class="line"></span><br><span class="line">controller属于该目录的所属组, 新建文件必须属于controller组</span><br><span class="line">sodor组的成员对该目录拥有rwx权限</span><br><span class="line">sodor组成员james对该目录及子目录(包括以后新建立的文件)没有任何权限</span><br></pre></td></tr></table></figure><p>实际操作</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;准备用户</span><br><span class="line">[root@linux-node1 ~]# groupadd controller</span><br><span class="line">[root@linux-node1 ~]# groupadd sodor</span><br><span class="line">[root@linux-node1 ~]# useradd student -G controller</span><br><span class="line">[root@linux-node1 ~]# useradd thomas -G sodor</span><br><span class="line">[root@linux-node1 ~]# useradd james -G sodor</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;准备目录</span><br><span class="line">[root@linux-node1 ~]# mkdir &#x2F;shares&#x2F;steamies -p</span><br><span class="line">[root@linux-node1 ~]# echo &quot;file&quot; &gt;&gt; &#x2F;shares&#x2F;steamies&#x2F;file</span><br><span class="line">[root@linux-node1 ~]# echo &quot;echo 123&quot; &gt;&gt; &#x2F;shares&#x2F;steamies&#x2F;test.sh</span><br><span class="line">[root@linux-node1 ~]# chmod 755 &#x2F;shares&#x2F;steamies&#x2F;test.sh</span><br><span class="line">[root@linux-node1 ~]# chown -R  :controller &#x2F;shares&#x2F;steamies&#x2F;</span><br><span class="line">[root@linux-node1 ~]# chmod g+s &#x2F;shares&#x2F;steamies&#x2F;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;设定权限(X表示,如果原本有执行权限就保留,如果没有则不添加)</span><br><span class="line">[root@linux-node1 ~]# setfacl -R -m g:sodor:rwX,u:james:- &#x2F;shares&#x2F;steamies&#x2F;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;设定继承规则</span><br><span class="line">[root@linux-node1 ~]# setfacl -R -m d:g:sodor:rwX,d:u:james:- &#x2F;shares&#x2F;steamies&#x2F;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[root@linux-node1 steamies]# getfacl &#x2F;shares&#x2F;steamies&#x2F;</span><br><span class="line">getfacl: Removing leading &#39;&#x2F;&#39; from absolute path names</span><br><span class="line"># file: shares&#x2F;steamies&#x2F;</span><br><span class="line"># owner: root</span><br><span class="line"># group: controller</span><br><span class="line"># flags: -s-</span><br><span class="line">user::rwx</span><br><span class="line">user:james:---</span><br><span class="line">group::r-x</span><br><span class="line">group:sodor:rwx</span><br><span class="line">mask::rwx</span><br><span class="line">other::r-x</span><br><span class="line">default:user::rwx</span><br><span class="line">default:group::r-x</span><br><span class="line">default:group:sodor:rwx</span><br><span class="line">default:mask::rwx</span><br><span class="line">default:other::r-x</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1-ACL访问控制概述&quot;&gt;&lt;a href=&quot;#1-ACL访问控制概述&quot; class=&quot;headerlink&quot; title=&quot;1.ACL访问控制概述&quot;&gt;&lt;/a&gt;1.ACL访问控制概述&lt;/h2&gt;&lt;p&gt;上一章节我们学习了基础权限&lt;code&gt;UGO&lt;/code&gt;、特殊权限
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>7-Linux——特殊权限</title>
    <link href="http://yoursite.com/2019/02/26/Linux%E2%80%94%E2%80%94%E7%89%B9%E6%AE%8A%E6%9D%83%E9%99%90/"/>
    <id>http://yoursite.com/2019/02/26/Linux%E2%80%94%E2%80%94%E7%89%B9%E6%AE%8A%E6%9D%83%E9%99%90/</id>
    <published>2019-02-26T13:18:20.000Z</published>
    <updated>2020-08-18T12:12:09.023Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-特殊权限概述"><a href="#1-特殊权限概述" class="headerlink" title="1.特殊权限概述"></a>1.特殊权限概述</h2><p>前面我们已经学习过 r（读）、w（写）、 x（执行）这三种普通权限，但是我们在査询系统文件权限时会发现出现了一些其他权限字母，比如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@bgx ~]# ll &#x2F;usr&#x2F;bin&#x2F;passwd</span><br><span class="line">-rwsr-xr-x. 1 root root 27832 Jun 10  2014 &#x2F;usr&#x2F;bin&#x2F;passwd</span><br></pre></td></tr></table></figure><p>在属主本来应该是 x（执行）权限的位置出现了一个小写s，这是什么权限？我们把这种权限称作 SetUID 权限，也叫作 SUID 的特殊权限。这种权限有什么作用呢？或者说能干啥？别急，先往下看…..</p><h2 id="2-特殊权限SUID"><a href="#2-特殊权限SUID" class="headerlink" title="2.特殊权限SUID"></a>2.特殊权限SUID</h2><h3 id="1-问题抛出"><a href="#1-问题抛出" class="headerlink" title="1.问题抛出"></a>1.问题抛出</h3><p>在 Linux 系统中，每个普通用户都可以更改自己的密码，这是合理的设置。问题是，普通用户的信息保存在 /etc/passwd 文件中，用户的密码在 /etc/shadow 文件中，也就是说，普通用户在更改自己的密码时修改了 /etc/shadow 文件中的加密密码，但是文件权限显示，普通用户对这两个文件其实都是没有写权限的，那为什么普通用户可以修改自己的权限呢？……(难道学了个假的权限)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@bgx ~]# ll &#x2F;etc&#x2F;passwd</span><br><span class="line">-rw-r--r-- 1 root root 6209 Apr 13 03:26 &#x2F;etc&#x2F;passwd</span><br><span class="line">[root@bgx ~]# ll &#x2F;etc&#x2F;shadow</span><br><span class="line">---------- 1 root root 11409 Apr 13 03:26 &#x2F;etc&#x2F;shadow</span><br></pre></td></tr></table></figure><h3 id="2-解决方案"><a href="#2-解决方案" class="headerlink" title="2.解决方案"></a>2.解决方案</h3><p>其实，普通用户可以修改自己的密码在于 passwd 命令。该命令拥有特殊权限 SetUID，也就是在属主的权限位的执行权限上是 s。可以这样来理解它：当一个具有执行权限的文件设置 SetUID 权限后，用户在执行这个文件时将以文件所有者的身份来执行。</p><p>PS: 当普通用户使用 passwd 命令更改自己的密码时，实际上是在用 passwd 命令所有者 root 的身份在执行 passwd 命令，root 当然可以将密码写入 /etc/shadow 文件，所以普通用户也可以修改 /etc/shadow 文件，命令执行完成后，该身份也随之消失。</p><h3 id="3-示例演示"><a href="#3-示例演示" class="headerlink" title="3.示例演示"></a>3.示例演示</h3><p>举个例子，有一个用户 lamp，她可以修改自己的权限，因为 passwd 命令拥有 SetUID 权限；但是她不能査看 /etc/shadow 文件的内容，因为査看文件的命令（如 cat）没有 SetUID 权限。命令如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#自己可以修改自己的密码，从而改变&#x2F;etc&#x2F;shadow中的数据</span><br><span class="line">[lamp@bgx ~]$ passwd</span><br><span class="line"></span><br><span class="line">#但无法使用cat命令查看&#x2F;etc&#x2F;shadow</span><br><span class="line">[lamp@bgx ~]$ cat &#x2F;etc&#x2F;shadow</span><br><span class="line">cat: &#x2F;etc&#x2F;shadow: Permission denied</span><br></pre></td></tr></table></figure><p>我们画一张示意图来理解上述过程<br><img src= "/img/loading.gif" data-src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ghu6ydk5lvj30go06ljs0.jpg" alt="img"></p><h3 id="4-例子解释"><a href="#4-例子解释" class="headerlink" title="4.例子解释"></a>4.例子解释</h3><p>passwd 是系统命令，可以执行，所以可以赋予 SetUID 权限。<br>lamp 用户对 passwd 命令拥有 x（执行）权限。<br>lamp 用户在执行 passwd 命令的过程中，会暂时切换为 root 身份，所以可以修改 /etc/shadow 文件。<br>命令结束，lamp 用户切换回自己的身份。<br>PS: cat命令没有 SetUID权限，所以使用 lamp 用户身份去访问 /etc/shadow 文件，当然没有相应权限了。<br>F: 但如果将passwd命令的suid去掉会发生什么？？？</p><p>2.suid授权方法4000 权限字符s(S),用户位置上的x位上设置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># chmod 4755 passwd</span><br><span class="line"># chmod  u+s  passwd</span><br></pre></td></tr></table></figure><p>3.suid的作用<br>1.让普通用户对可执行的二进制文件，临时拥有二进制文件的所属主权限。<br>2.如果设置的二进制文件没有执行权限,那么suid的权限显示就是大S。<br>3.特殊权限suid仅对二进制可执行程序有效，其他文件或目录则无效。<br>注意: suid极度危险，不信可以尝试对vim或rm进行设定SetUID。</p><h2 id="3-特殊权限SGID"><a href="#3-特殊权限SGID" class="headerlink" title="3.特殊权限SGID"></a>3.特殊权限SGID</h2><p>将目录设置为sgid后，如果在该目录下创建文件，都将与该目录的所属组保持一致，演示如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">#1.建立测试目录</span><br><span class="line">[root@bgx ~]# cd &#x2F;tmp&#x2F; &amp;&amp; mkdir dtest</span><br><span class="line"></span><br><span class="line">#2.给测试目录赋予SetGID权限，检查SetGID是否生效</span><br><span class="line">[root@bgx tmp]# chmod g+s dtest&#x2F; &amp;&amp; ll -d dtest&#x2F;</span><br><span class="line">drwxr-sr-x 2 root root 6 Apr 13 05:21 dtest&#x2F;</span><br><span class="line"></span><br><span class="line">#3.给测试目录赋予777权限，让普通用户可以写</span><br><span class="line">[root@bgx tmp]# chmod 777 dtest&#x2F;</span><br><span class="line"></span><br><span class="line">#4.切换成普通用户lamp，并进入该目录</span><br><span class="line">[root@bgx tmp]# su - lamp</span><br><span class="line">[lamp@bgx ~]$ cd &#x2F;tmp&#x2F;dtest&#x2F;</span><br><span class="line"></span><br><span class="line">#5.普通用户创建测试文件，检查文件的信息</span><br><span class="line">[lamp@bgx dtest]$ touch lamp_test</span><br><span class="line">[lamp@bgx dtest]$ ll</span><br><span class="line">-rw-rw-r-- 1 lamp root 0 Apr 13 05:21 lamp_test</span><br></pre></td></tr></table></figure><h3 id="2-sgid授权方法-2000权限字符s-S-，取决于属组位置上的x"><a href="#2-sgid授权方法-2000权限字符s-S-，取决于属组位置上的x" class="headerlink" title="2.sgid授权方法: 2000权限字符s(S)，取决于属组位置上的x"></a>2.sgid授权方法: 2000权限字符s(S)，取决于属组位置上的x</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># chmod 2755  directory </span><br><span class="line"># chmod  g+s  directory</span><br></pre></td></tr></table></figure><h3 id="3-sgid作用"><a href="#3-sgid作用" class="headerlink" title="3.sgid作用"></a>3.sgid作用</h3><p>1.针对用户组权限位修改，用户创建的目录或文件所属组和该目录的所属组一致。<br>2.当某个目录设置了sgid后，在该目录中新建的文件不在是创建该文件的默认所属组<br>3.使用sgid可以使得多个用户之间共享一个目录的所有文件变得简单。</p><h2 id="4-特殊权限SBIT"><a href="#4-特殊权限SBIT" class="headerlink" title="4.特殊权限SBIT"></a>4.特殊权限SBIT</h2><p>Sticky(SI TI KI)粘滞位目前只对目录有效，作用如下：<br>普通用户对该目录拥有 w 和 x 权限，即普通用户可以在此目录中拥有写入权限。如果没有粘滞位，那么普通用户拥有 w 权限，就可以删除此目录下的所有文件，包括其他用户建立的文件。但是一旦被赋予了粘滞位，除了 root 可以删除所有文件，普通用户就算拥有 w 权限，也只能删除自己建立的文件，而不能删除其他用户建立的文件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@bgx tmp]# ll -d &#x2F;tmp&#x2F;</span><br><span class="line">drwxrwxrwt. 12 root root 4096 Apr 13 05:32 &#x2F;tmp&#x2F;</span><br></pre></td></tr></table></figure><h3 id="2-sticky授权方法，1000-权限字符t-T-其他用户位的x位上设置。"><a href="#2-sticky授权方法，1000-权限字符t-T-其他用户位的x位上设置。" class="headerlink" title="2.sticky授权方法，1000 权限字符t(T),其他用户位的x位上设置。"></a>2.sticky授权方法，1000 权限字符t(T),其他用户位的x位上设置。</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># chmod 1755  &#x2F;tmp</span><br><span class="line"># chmod o+t &#x2F;tmp</span><br></pre></td></tr></table></figure><h3 id="3-sticky作用"><a href="#3-sticky作用" class="headerlink" title="3.sticky作用"></a>3.sticky作用</h3><p>1.让多个用户都具有写权限的目录，并让每个用户只能删自己的文件。<br>2.特殊sticky目录表现在others的x位，用小t表示，如果没有执行权限是T<br>3.一个目录即使它的权限为”777”如果是设置了粘滞位，除了目录的属主和”root”用户有权限删除，除此之外其他用户都不允许删除该目录。</p><h2 id="5-权限属性chattr"><a href="#5-权限属性chattr" class="headerlink" title="5.权限属性chattr"></a>5.权限属性chattr</h2><p>chatrr 只有 root 用户可以使用，用来修改文件系统的权限属性，建立凌驾于 rwx 基础权限之上的授权。<br>chatrr 命令格式：[root@bgx ~]# chattr [+-=] [选项] 文件或目录名</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">#选项: + 增加权限 -减少权限 &#x3D;等于某个权限</span><br><span class="line"># a：让文件或目录仅可追加内容</span><br><span class="line"># i：不得任意更动文件或目录</span><br><span class="line"></span><br><span class="line">#1.创建文件并设置属性</span><br><span class="line">[root@lqz ~]# touch file_a file_i</span><br><span class="line">[root@lqz ~]# lsattr file_a file_i</span><br><span class="line">---------------- file_a</span><br><span class="line">---------------- file_i</span><br><span class="line"></span><br><span class="line">#2.使用chattr设置属性，lsattr查看权限限制</span><br><span class="line">[root@lqz ~]# chattr +a file_a</span><br><span class="line">[root@lqz ~]# chattr +i file_i</span><br><span class="line">[root@lqz ~]# lsattr file_a file_i</span><br><span class="line">-----a---------- file_a</span><br><span class="line">----i----------- file_i</span><br><span class="line"></span><br><span class="line">#3.a权限，无法写入和删除文件，但可以追加数据，适合&#x2F;etc&#x2F;passwd这样的文件</span><br><span class="line">[root@lqz ~]# echo &quot;aa&quot; &gt; file_a</span><br><span class="line">bash: file_a: Operation not permitted</span><br><span class="line">[root@lqz ~]# rm -f file_a</span><br><span class="line">rm: cannot remove ‘file_a’: Operation not permitted</span><br><span class="line">[root@lqz ~]# echo &quot;aa&quot; &gt;&gt; file_a</span><br><span class="line"></span><br><span class="line">#5.i权限, 无法写入，无法删除，适合不需要更改的重要文件加锁</span><br><span class="line">[root@lqz ~]# echo &quot;i&quot; &gt; file_i</span><br><span class="line">bash: file_i: Permission denied</span><br><span class="line">[root@lqz ~]# echo &quot;i&quot; &gt;&gt; file_i</span><br><span class="line">bash: file_i: Permission denied</span><br><span class="line">[root@lqz ~]# rm -f  file_i</span><br><span class="line">rm: cannot remove ‘file_i’: Operation not permitted</span><br><span class="line"></span><br><span class="line">#6.解除限制</span><br><span class="line">[root@tianyun ~]# chattr -a file100 </span><br><span class="line">[root@tianyun ~]# chattr -i file200</span><br></pre></td></tr></table></figure><h2 id="6-进程掩码umask"><a href="#6-进程掩码umask" class="headerlink" title="6.进程掩码umask"></a>6.进程掩码umask</h2><h3 id="1-umask是什么"><a href="#1-umask是什么" class="headerlink" title="1.umask是什么?"></a>1.umask是什么?</h3><p>当我们登录系统之后创建一个文件总是有一个默认权限的，比如: 目录755、文件644、那么这个权限是怎么来的呢？这就是umask干的事情。umask设置了用户创建文件的默认权限。</p><h3 id="2-umask是如何改变创建新文件的权限"><a href="#2-umask是如何改变创建新文件的权限" class="headerlink" title="2.umask是如何改变创建新文件的权限"></a>2.umask是如何改变创建新文件的权限</h3><p>系统默认umask为022，那么当我们创建一个目录时，正常情况下目录的权限应该是777，但umask表示要减去的值，所以新目录文件的权限应该是777 - 022 =755。至于文件的权限也依次类推666 - 022 =644。</p><h3 id="3-umask涉及哪些配置文件"><a href="#3-umask涉及哪些配置文件" class="headerlink" title="3.umask涉及哪些配置文件"></a>3.umask涉及哪些配置文件</h3><p>umask涉及到的相关文件/etc/bashrc /etc/profile ~/.bashrc ~/.bash_profile<br>shell (vim,touch) –umask–&gt; 会影响创建的新文件或目录权限<br>vsftpd服务如果修改–umask–&gt; 会影响ftp服务中新创建文件或创建目录权限<br>useradd如果修改umask–&gt; 会影响用户HOME家目录权限</p><h3 id="4-umask演示示例"><a href="#4-umask演示示例" class="headerlink" title="4.umask演示示例"></a>4.umask演示示例</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">#1.假设umask值为：022（所有位为偶数）</span><br><span class="line">#文件的起始权限值</span><br><span class="line">6 6 6  -  0 2 2  &#x3D; 6 4 4 </span><br><span class="line"></span><br><span class="line">#2.假设umask值为：045（其他用户组位为奇数）</span><br><span class="line">#计算出来的权限。由于umask的最后一位数字是5，所以，在其他用户组位再加1。</span><br><span class="line">6 6 6  -   0 4 5 &#x3D; 6 2 1</span><br><span class="line"></span><br><span class="line">#3.默认目录权限计算方法</span><br><span class="line">7 7 7  -  0 2 2 &#x3D; 7 5 5</span><br><span class="line"> </span><br><span class="line">#umask所有位全为偶数时</span><br><span class="line"># umask 044</span><br><span class="line"># mkdir d044   目录权限为733</span><br><span class="line"># touch f044   文件权限为622</span><br><span class="line"></span><br><span class="line">#umask部分位为奇数时</span><br><span class="line"># umask 023</span><br><span class="line"># mkdir d023   目录权限为754</span><br><span class="line"># touch f023   文件权限为644</span><br><span class="line"></span><br><span class="line">#umask值的所有位为奇数时</span><br><span class="line"># umask 035</span><br><span class="line"># mkdir d035   目录权限为742</span><br><span class="line"># touch f035   文件权限为642</span><br></pre></td></tr></table></figure><p>示例1: 在 shell 进程中创建文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#查看当前用户的umask权限</span><br><span class="line">[root@lqz ~]# umask</span><br><span class="line">0022</span><br><span class="line">[root@lqz ~]# touch file0022</span><br><span class="line">[root@lqz ~]# mkdir dir0022</span><br><span class="line">[root@lqz ~]# ll -d file0022  dir0022&#x2F;</span><br><span class="line">drwxr-xr-x 2 root root 6 Jan 24 09:02 dir0022&#x2F;</span><br><span class="line">-rw-r--r-- 1 root root 0 Jan 24 09:02 file0022</span><br></pre></td></tr></table></figure><p>示例2: 修改 shell umask 值(临时生效)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@lqz ~]# umask 000</span><br><span class="line">[root@lqz ~]# mkdir dir000</span><br><span class="line">[root@lqz ~]# touch file000</span><br><span class="line">[root@lqz ~]# ll -d dir000 file000</span><br><span class="line">drwxrwxrwx 2 root root 6 Jan 24 09:04 dir000</span><br><span class="line">-rw-rw-rw- 1 root root 0 Jan 24 09:04 file000</span><br></pre></td></tr></table></figure><p>示例3: 通过 umask 决定新建用户 HOME 目录的权限</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[root@lqz ~]# vim &#x2F;etc&#x2F;login.defs</span><br><span class="line">UMASK 077</span><br><span class="line">[root@lqz ~]# useradd dba</span><br><span class="line">[root@lqz ~]# ll -d &#x2F;home&#x2F;dba&#x2F;</span><br><span class="line">drwx------. 4 dba dba 4096 3 月 11 19:50 &#x2F;home&#x2F;dba&#x2F;</span><br><span class="line"></span><br><span class="line">[root@tianyun ~]# vim &#x2F;etc&#x2F;login.defs</span><br><span class="line">UMASK 000</span><br><span class="line">[root@lqz ~]# useradd sa</span><br><span class="line">[root@lqz ~]# ll -d &#x2F;home&#x2F;sa&#x2F;</span><br><span class="line">drwxrwxrwx. 4 sa sa 4096 3 月 11 19:53 &#x2F;home&#x2F;sa&#x2F;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1-特殊权限概述&quot;&gt;&lt;a href=&quot;#1-特殊权限概述&quot; class=&quot;headerlink&quot; title=&quot;1.特殊权限概述&quot;&gt;&lt;/a&gt;1.特殊权限概述&lt;/h2&gt;&lt;p&gt;前面我们已经学习过 r（读）、w（写）、 x（执行）这三种普通权限，但是我们在査询系统文件权
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>6-Linux——基本权限</title>
    <link href="http://yoursite.com/2019/02/25/Linux%E2%80%94%E2%80%94%E5%9F%BA%E6%9C%AC%E6%9D%83%E9%99%90/"/>
    <id>http://yoursite.com/2019/02/25/Linux%E2%80%94%E2%80%94%E5%9F%BA%E6%9C%AC%E6%9D%83%E9%99%90/</id>
    <published>2019-02-25T13:32:03.000Z</published>
    <updated>2020-08-18T12:11:46.103Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-权限基本概述"><a href="#1-权限基本概述" class="headerlink" title="1.权限基本概述"></a>1.权限基本概述</h2><h3 id="1-什么是权限？"><a href="#1-什么是权限？" class="headerlink" title="1.什么是权限？"></a>1.什么是权限？</h3><p>我们可以把它理解为操作系统对用户能够执行的功能所设立的限制，主要用于约束用户能对系统所做的操作，以及内容访问的范围，或者说，权限是指某个特定的用户具有特定的系统资源使用权力。</p><h3 id="2-为什么要有权限？"><a href="#2-为什么要有权限？" class="headerlink" title="2.为什么要有权限？"></a>2.为什么要有权限？</h3><p>因为系统中不可能只存在一个root用户，一定会存在多个用户，为了保护每个登陆用户的隐私和工作环境，所以就有了权限。(比如三个租客合租同一个房子，a租客要使用b租客的肥皂，那这个事情？？)</p><h3 id="3-权限与用户之间的关系？"><a href="#3-权限与用户之间的关系？" class="headerlink" title="3.权限与用户之间的关系？"></a>3.权限与用户之间的关系？</h3><p>在Linux系统中，针对文件定义了三种身份，分别是属主(owner)、属组(group)、其他人(others)，每一种身份又对应三种权限，分别是可读(readable)、可写(writable)、可执行(excutable)。</p><p><img src= "/img/loading.gif" data-src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ghu6xvd061j30l208lwfe.jpg" alt="img"><br>用户对文件资源，有三种角色ugo，当一个用户访问文件流程如下</p><p>1) 判断用户是否为文件所有者，如果是则按所有者的权限进行访问<br>2) 判断用户是否为文件所有组成员，如果是则按组的权限进行访问<br>3) 如果不是所有者，也不是该文件所属组，则按匿名权限进行访问</p><h3 id="4-权限中的rwx分别代表什么含义？"><a href="#4-权限中的rwx分别代表什么含义？" class="headerlink" title="4.权限中的rwx分别代表什么含义？"></a>4.权限中的rwx分别代表什么含义？</h3><p>当我们使用ls -l查看一个文件的详细属性时，能看到每个文件都有一个9位基本权限位，比如: <code>rwxr-xr-x</code>其中每三位字符为一组，分别表示属主权限位，属组权限位，匿名权限位。<br>linux中基本权限位则是使用这9位字符来表示，主要控制文件属主(User)、属组(Group)、其他用户(Other)</p><table><thead><tr><th>字母</th><th>含义</th><th>对应权限</th></tr></thead><tbody><tr><td>r(read)</td><td>读取权限</td><td>4</td></tr><tr><td>w(write)</td><td>写入权限</td><td>2</td></tr><tr><td>x(execute)</td><td>执行权限</td><td>1</td></tr><tr><td>-(没有权限)</td><td>没有权限</td><td>0</td></tr></tbody></table><p>PS: 如果权限位不可读、不可写、不可执行，则全部使用-作为占位符表示。</p><h2 id="2-权限设置示例"><a href="#2-权限设置示例" class="headerlink" title="2.权限设置示例"></a>2.权限设置示例</h2><p>文件示例: rwxrw-r– alice hr file1.txt<br>Q1: alice对file1文件拥有什么权限?<br>Q2: jack 对 file1.txt 文件有什么权限? 前提:jack 属于 hr 组<br>Q3: tom 对 file1.txt 文件有什么权限?</p><h3 id="1-为什么要设定权限，我们又如何修改一个文件的权限"><a href="#1-为什么要设定权限，我们又如何修改一个文件的权限" class="headerlink" title="1.为什么要设定权限，我们又如何修改一个文件的权限?"></a>1.为什么要设定权限，我们又如何修改一个文件的权限?</h3><p>Q1: 为什么要设定权限，可以赋于某个用户或组 – 能够以何种方式 – 访问某个文件<br>Q2: Linux下使用chmod命令来变更权限，root用户可以变更所有文件的权限，而普通用户仅能变更属于自己的文件。</p><h3 id="2-使用chmod设定权限示例"><a href="#2-使用chmod设定权限示例" class="headerlink" title="2.使用chmod设定权限示例"></a>2.使用chmod设定权限示例</h3><p>方式一: ugo</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@bgx ~]# touch file                    #创建文件</span><br><span class="line">[root@bgx ~]# chmod a&#x3D;rwx file              #给所有人添加读写执行权限</span><br><span class="line">[root@bgx ~]# chmod a&#x3D;-rwx file             #取消所有的权限</span><br><span class="line">[root@bgx ~]# chmod u&#x3D;rwx,g&#x3D;rw,o&#x3D;- file     #属主读写执行，属组读写，其他人无权限</span><br><span class="line">[root@bgx ~]# chmod ug&#x3D;rwx,o&#x3D;r file         #属主属组读写执行，其他人读权限</span><br><span class="line">[root@bgx ~]# ll file</span><br><span class="line">-rwxrw-r-- 1 root root 0 Apr 13 03:29 file</span><br></pre></td></tr></table></figure><p>方式二、number</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">#选项:  -R递归修改</span><br><span class="line">[root@bgx ~]# touch file</span><br><span class="line">[root@bgx ~]# chmod 644 file</span><br><span class="line">[root@bgx ~]# chmod 600 file</span><br><span class="line">[root@bgx ~]# ll file</span><br><span class="line">-rw------- 1 root root 0 Apr 13 03:29 file</span><br><span class="line"></span><br><span class="line">#针对目录设定权限</span><br><span class="line">[root@bgx ~]# mkdir dir</span><br><span class="line">[root@bgx ~]# chmod 777 dir&#x2F;    #修改目录允许所有人访问</span><br><span class="line">[root@bgx ~]# chmod -R 755 dir&#x2F; #修改目录及子目录权限</span><br><span class="line">[root@bgx ~]# ll -d dir&#x2F;</span><br><span class="line">drwxr-xr-x 2 root root 6 Apr 13 03:34 dir&#x2F;</span><br></pre></td></tr></table></figure><h3 id="3-权限设置案例"><a href="#3-权限设置案例" class="headerlink" title="3.权限设置案例"></a>3.权限设置案例</h3><p>针对 hr 部门的访问目录/home/hr 设置权限，要求如下:<br>1.root 用户和 hr 组的员工可以读、写、执行<br>2.其他用户没有任何权限</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[root@bgx ~]# groupadd hr</span><br><span class="line">[root@bgx ~]# useradd hr01 -G hr</span><br><span class="line">[root@bgx ~]# useradd hr02 -G hr</span><br><span class="line">[root@bgx ~]# mkdir &#x2F;home&#x2F;hr</span><br><span class="line">[root@bgx ~]# chgrp hr &#x2F;home&#x2F;hr</span><br><span class="line">[root@bgx ~]# chmod 770 &#x2F;home&#x2F;hr</span><br><span class="line">[root@bgx ~]# ll -d &#x2F;home&#x2F;hr</span><br><span class="line">drwxrwx--- 2 root hr 6 Apr 13 03:26 &#x2F;home&#x2F;hr</span><br></pre></td></tr></table></figure><h2 id="3-权限设置案例-1"><a href="#3-权限设置案例-1" class="headerlink" title="3.权限设置案例"></a>3.权限设置案例</h2><p>在Linux中权限对文件和对目录的影响是有不同区别的。</p><table><thead><tr><th>权限</th><th>对文件的影响</th><th>对目录的影响</th></tr></thead><tbody><tr><td>读取权限（r）</td><td>具有读取阅读文件内容权限</td><td>具有浏览目录及子目录</td></tr><tr><td>写入权限（w）</td><td>具有新增、修改文件内容的权限</td><td>具有增加和删除目录内文件</td></tr><tr><td>执行权限（x）</td><td>具有执行文件的权限</td><td>具有访问目录的内容(取决于目录中文件权限)</td></tr></tbody></table><p>文件权限实验案例:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">#1.新建文件，并添加内容至文件中，默认文件匿名用户仅有读权限</span><br><span class="line">[root@lqz ~]# echo &quot;date&quot; &gt; filename</span><br><span class="line">[root@lqz ~]# ll filename</span><br><span class="line">-rw-r--r-- 1 root root 5 Jan 24 08:24 filename</span><br><span class="line"></span><br><span class="line">#2.切换bgx普通用户</span><br><span class="line">[root@lqz ~]# su - bgx</span><br><span class="line"></span><br><span class="line">#3.对文件拥有读取的权限，但bgx用户对文件没有执行和删除的权限</span><br><span class="line">[bgx@lqz ~]$ cat  &#x2F;root&#x2F;filename</span><br><span class="line">date</span><br><span class="line"></span><br><span class="line">#4.使用root增加x执行权限</span><br><span class="line">[root@lqz ~]# chmod o+x &#x2F;root&#x2F;filename</span><br><span class="line">[root@lqz ~]# ll &#x2F;root&#x2F;filename</span><br><span class="line">-rw-r--r-x 1 root root 5 Jan 24 08:24 &#x2F;root&#x2F;filename</span><br><span class="line"></span><br><span class="line">#5.测试x权限是否真的能执行该文件</span><br><span class="line">[bgx@lqz ~]$ &#x2F;root&#x2F;filename</span><br><span class="line">Wed Jan 24 08:28:34 EST 2018</span><br><span class="line"></span><br><span class="line">#6.增加w执行权限</span><br><span class="line">[root@lqz ~]# chmod o+w &#x2F;root&#x2F;filename</span><br><span class="line">[root@lqz ~]# ll &#x2F;root&#x2F;filename</span><br><span class="line">-rw-r--rwx 1 root root 5 Jan 24 08:24 &#x2F;root&#x2F;filename</span><br><span class="line"></span><br><span class="line">#7.测试执行权限</span><br><span class="line">[bgx@lqz ~]$ vim &#x2F;root&#x2F;filename</span><br></pre></td></tr></table></figure><p>PS: 总结rwx对文件的影响<br>读取权限（r）具有读取阅读文件内容权限<br>1.只能使用查看类命令cat、head、tail、less、more</p><p>写入权限（w）具有新增、修改文件内容的权限<br>1.使用vim编辑会提示权限拒绝, 但可强制保存,会覆盖文件的所有内容<br>2.使用echo命令重定向的方式可以往文件内写入数据,&gt;&gt;可以进行追加<br>3.不能删除文件,因为删除文件看的不是文件的属性,需要看上级目录是否有w的权限</p><p>执行权限（x）具有执行文件的权限<br>1.执行权限什么用都没有<br>2.如果普通用户需要执行文件,需要配合r权限</p><p>目录权限实验案例:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">#示例1: 创建目录，并在该目录下创建文件，匿名用户对目录没有w权限，对文件有777权限 </span><br><span class="line">[root@lqz ~]# mkdir &#x2F;dirname</span><br><span class="line">[root@lqz ~]# echo &quot;test&quot; &gt;&gt; &#x2F;dirname&#x2F;filename</span><br><span class="line">[root@lqz ~]# chmod 777 &#x2F;dirname&#x2F;filename</span><br><span class="line"></span><br><span class="line">#普通用户验证权限，能正常查看，但无法删除[奇怪]</span><br><span class="line">[bgx@lqz ~]$ cat &#x2F;dirname&#x2F;filename</span><br><span class="line">test</span><br><span class="line">[bgx@lqz ~]$ rm -f &#x2F;dirname&#x2F;filename</span><br><span class="line">rm: cannot remove ‘&#x2F;dirname&#x2F;filename’: Permission denied</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#示例2: 设置目录777权限，相当于匿名用户对目录有w权限，对文件没有任何权限</span><br><span class="line">[root@lqz ~]# chmod 777 &#x2F;dirname&#x2F;</span><br><span class="line">[root@lqz ~]# chmod 000 &#x2F;dirname&#x2F;filename</span><br><span class="line"></span><br><span class="line">#普通用户验证权限</span><br><span class="line">[bgx@lqz ~]$ cat &#x2F;dirname&#x2F;filename</span><br><span class="line">cat: &#x2F;dirname&#x2F;filename: Permission denied</span><br><span class="line">[bgx@lqz ~]$ rm -f &#x2F;dirname&#x2F;filename</span><br><span class="line">[bgx@lqz ~]$ touch &#x2F;dirname&#x2F;filename_2</span><br></pre></td></tr></table></figure><p>PS: 总结rwx对目录的影响<br>读取权限（r），如果目录只有r权限: 具有浏览目录及子目录权限<br>1.可以使用ls命令浏览目录及子目录， 但同时也会提示权限拒绝<br>2.使用ls -l命令浏览目录及子目录，文件属性会带问号，并且只能看到文件名<br>总结: 目录只有r权限，仅仅只能浏览内的文件名，无其他操作权限</p><p>写入权限（w），如果目录只有w权限: 具有增加、删除或修改目录内文件名权限(需要x权限配合)<br>PS: 如果目录有w权限, 可以在目录内创建文件, 删除文件(跟文件本身权限无关)<br>不能进入目录、不能复制目录、不能删除目录、不能移动目录</p><p>执行权限（x），如果目录只有x权限<br>1.只能进入目录<br>2.不能浏览、复制、移动、删除</p><p>Linux权限总结与注意事项<br>文件r权限, 只给用户查看,无其他操作<br>文件rw权限, 可以查看和编辑文件内容<br>文件rx权限, 允许查看和执行文件、但不能修改文件—–&gt;PASS<br>文件rwx权限, 能读,能写,能执行,但不能删除,因为删除需要看上级目录的权限有没有w—–&gt;PASS<br>目录rx权限, 允许浏览目录内文件以及子目录、并允许在目录内新建文件, 不允许创建、删除文件和目录<br>目录wx权限, 能进入目录,能删除内容,能写入内容,但就是无法使用ls cat这样的命令—–&gt;PASS<br>目录rw权限, 能看,能写,但无法进入目录—–&gt;PASS<br>PS: 文件的 x权限小心给予，目录的 w权限小心给予。<br>PS: 文件通常设定的权限是644,目录设定的权限是755<br>PS: 控制目录权限755, 如果有普通用户需要操作目录里面的文件，在来看文件的权限</p><h2 id="4-属主属组设置"><a href="#4-属主属组设置" class="headerlink" title="4.属主属组设置"></a>4.属主属组设置</h2><p>变更文件属主和属组的意义？<br>比如: 我现在手里有多套房，希望出售其中的A房进行变现，那么我会考虑将A房过户给金主，过户成功后A房就属于金主了，那么此时A房的拥有者就属于金主而不再属于我。<br><img src= "/img/loading.gif" data-src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ghu6y1texfj30mc0g4dhf.jpg" alt="img"></p><p>在Linux中如何变更一个文件或者一个资源的属主和属组呢，可以使用chown、chgrp命令实现。<br>chown能设置属主和属组，chgrp仅能设置属组。（所以用哪个你懂的）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">#chown 更改属主以及属组 -R：递归修改</span><br><span class="line"></span><br><span class="line">#准备环境，创建文件和目录</span><br><span class="line">[root@bgx ~]# mkdir dir&#x2F;test1 &amp;&amp; touch dir&#x2F;file</span><br><span class="line"></span><br><span class="line">#示例1: 修改所属主为bin</span><br><span class="line">[root@bgx ~]# chown bin dir&#x2F;</span><br><span class="line"></span><br><span class="line">#示例2: 修改所属组为adm</span><br><span class="line">[root@bgx ~]# chown .adm dir&#x2F;</span><br><span class="line"></span><br><span class="line">#示例3: 递归修改目录及目录下的所有文件属主和属组</span><br><span class="line">[root@bgx ~]# chown -R root.root dir&#x2F;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1-权限基本概述&quot;&gt;&lt;a href=&quot;#1-权限基本概述&quot; class=&quot;headerlink&quot; title=&quot;1.权限基本概述&quot;&gt;&lt;/a&gt;1.权限基本概述&lt;/h2&gt;&lt;h3 id=&quot;1-什么是权限？&quot;&gt;&lt;a href=&quot;#1-什么是权限？&quot; class=&quot;head
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>5-Linux——用户管理</title>
    <link href="http://yoursite.com/2019/02/24/Linux%E2%80%94%E2%80%94%E7%94%A8%E6%88%B7%E7%AE%A1%E7%90%86/"/>
    <id>http://yoursite.com/2019/02/24/Linux%E2%80%94%E2%80%94%E7%94%A8%E6%88%B7%E7%AE%A1%E7%90%86/</id>
    <published>2019-02-24T13:35:03.000Z</published>
    <updated>2020-08-18T12:11:23.242Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-用户基本概述"><a href="#1-用户基本概述" class="headerlink" title="1.用户基本概述"></a>1.用户基本概述</h2><h3 id="1-什么是用户"><a href="#1-什么是用户" class="headerlink" title="1.什么是用户?"></a>1.什么是用户?</h3><p>用户指的是能够正常登录Linux或Windows系统(可以理解为你租了房子，能够正常入驻)<br>F:那Linux与Windows系统的用户有什么区别? Q:本质都是登陆系统，只不过Linux支持多个用户同时登陆。<br>F:难道Windows就不算多用户操作系统吗? Q:其实不是，在Windows系统中可以创建多个用户，但不允许同一时刻多个用户登陆系统，但Linux系统则允许同一时刻多个用户同时登陆，登陆后相互之间操作并不影响。</p><p><img src= "/img/loading.gif" data-src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ghu6wgkghqj30ks0amwga.jpg" alt="img"></p><h3 id="2-Linux下的用户有什么用，或者说我们为什么要创建用户？"><a href="#2-Linux下的用户有什么用，或者说我们为什么要创建用户？" class="headerlink" title="2.Linux下的用户有什么用，或者说我们为什么要创建用户？"></a>2.Linux下的用户有什么用，或者说我们为什么要创建用户？</h3><p>1.系统上的每一个进程(运行的程序)，都需要一个特定的用户运行<br>2.通常在公司是使用普通用户管理服务器，因为root权限过大，容易造成故障。</p><h3 id="3-如何查看系统中所存在的用户"><a href="#3-如何查看系统中所存在的用户" class="headerlink" title="3.如何查看系统中所存在的用户"></a>3.如何查看系统中所存在的用户</h3><h4 id="1-查看当前登录的用户信息"><a href="#1-查看当前登录的用户信息" class="headerlink" title="1.查看当前登录的用户信息"></a>1.查看当前登录的用户信息</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@bgx ~]# id    #查看当前所登陆的用户信息</span><br><span class="line">uid&#x3D;0(root) gid&#x3D;0(root) groups&#x3D;0(root)</span><br><span class="line">[root@bgx ~]# id oldboy #查看其它用户的信息</span><br><span class="line">uid&#x3D;1000(oldboy) gid&#x3D;1000(oldboy) groups&#x3D;1000(oldboy)</span><br></pre></td></tr></table></figure><h4 id="2-每一个进程都会由一个用户身份运行"><a href="#2-每一个进程都会由一个用户身份运行" class="headerlink" title="2.每一个进程都会由一个用户身份运行"></a>2.每一个进程都会由一个用户身份运行</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@bgx ~]# ps aux|less #简单使用一下，不用理解</span><br><span class="line">root      33782  0.0  0.0      0     0 ?        R    02:46   0:00 [kworker&#x2F;u256:0]</span><br><span class="line">root      35637  0.0  0.0      0     0 ?        R    05:11   0:03 [kworker&#x2F;0:2]</span><br></pre></td></tr></table></figure><h3 id="4-那我们的用户存在哪呢"><a href="#4-那我们的用户存在哪呢" class="headerlink" title="4.那我们的用户存在哪呢?"></a>4.那我们的用户存在哪呢?</h3><p>Linux系统会将用户的信息存放在/etc/passwd，记录了用户的信息，但没有密码信息，密码被存放在/etc/shadow中。也就是说这两个文件非常的重要，不要轻易删除与修改。</p><p>1./etc/passwd 配置文件解释如下图，或者man 5 passwd<br><img src= "/img/loading.gif" data-src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ghu6wlblblj310e08e41c.jpg" alt="img"><br>2./etc/shadow 配置文件解释如下图，或者man 5 shadow<br><a href="https://www.cnblogs.com/lqz/p/10679004.html" target="_blank" rel="noopener">PS: 使用change修改密码过期时间示例</a><br><img src= "/img/loading.gif" data-src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ghu6wqmkm2j310k0ggwm9.jpg" alt="img"></p><p>4.最后我们需要了解下系统对用户的一个约定？(约定娶你，就真的会娶吗？)</p><table><thead><tr><th>用户UID</th><th>系统中约定的含义</th></tr></thead><tbody><tr><td>0</td><td>超级管理员，最高权限，有着极强的破坏能力</td></tr><tr><td>1~200</td><td>系统用户，用来运行系统自带的进程，默认已创建</td></tr><tr><td>201~999</td><td>系统用户，用来运行用户安装的程序，所以此类用户无需登录系统</td></tr><tr><td>1000+</td><td>普通用户，正常可以登陆系统的用户，权限比较小，能执行的任务有限</td></tr></tbody></table><p>PS:在CentOS7系统之前, UID1-499用于系统用户, 而UID 500+则用于普通用户</p><h2 id="2-用户相关命令"><a href="#2-用户相关命令" class="headerlink" title="2.用户相关命令"></a>2.用户相关命令</h2><p>下面我们就围绕着用户的创建、变更、删除等来讲讲涉及到的命令: useradd、usermod、userdel</p><h3 id="1-使用useradd命令新增用户，注意-adduser命令软链接指向useradd命令"><a href="#1-使用useradd命令新增用户，注意-adduser命令软链接指向useradd命令" class="headerlink" title="1.使用useradd命令新增用户，注意: adduser命令软链接指向useradd命令"></a>1.使用useradd命令新增用户，注意: adduser命令软链接指向useradd命令</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">#选项</span><br><span class="line"># -u 指定要创建用户的UID,不允许冲突</span><br><span class="line"># -g 指定要创建用户默认组</span><br><span class="line"># -G 指定要创建用户附加组,逗号隔开可添加多个附加组</span><br><span class="line"># -d 指定要创建用户家目录</span><br><span class="line"># -s 指定要创建用户的bash shell</span><br><span class="line"># -c 指定要创建用户注释信息</span><br><span class="line"># -M 给创建的用户不创建家目录</span><br><span class="line"># -r 创建系统账户，默认无家目录</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#1.创建bgx用户，UID5001,基本组students，附加组sa 注释信息:2019 new student,登陆shell:&#x2F;bin&#x2F;bash</span><br><span class="line">[root@bgx ~]# groupadd sa</span><br><span class="line">[root@bgx ~]# groupadd students</span><br><span class="line">[root@bgx ~]# useradd -u 5001 -g students -G sa -c &quot;2019 new student&quot; -s &#x2F;bin&#x2F;bash bgx</span><br><span class="line"></span><br><span class="line">#2.创建mysql系统用户，-M不建立用户家目录 -s指定nologin使其用户无法登陆系统</span><br><span class="line">[root@bgx ~]# useradd mysql -M -s &#x2F;sbin&#x2F;nologin</span><br><span class="line">[root@bgx ~]# useradd -r dba -s &#x2F;sbin&#x2F;nologin</span><br></pre></td></tr></table></figure><h3 id="2-如何使用usermod命令修改用户信息"><a href="#2-如何使用usermod命令修改用户信息" class="headerlink" title="2.如何使用usermod命令修改用户信息"></a>2.如何使用usermod命令修改用户信息</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">#选项</span><br><span class="line"># -u 指定要修改用户的UID</span><br><span class="line"># -g 指定要修改用户基本组</span><br><span class="line"># -G 指定要修改用户附加组，使用逗号隔开多个附加组, 覆盖原有的附加组</span><br><span class="line"># -d 指定要修改用户家目录</span><br><span class="line"># -s 指定要修改用户的bash shell</span><br><span class="line"># -c 指定要修改用户注释信息</span><br><span class="line"># -l 指定要修改用户的登陆名</span><br><span class="line"># -L 指定要锁定的用户</span><br><span class="line"># -U 指定要解锁的用户</span><br><span class="line"></span><br><span class="line">#1.检查此前创建的用户信息</span><br><span class="line">[root@bgx ~]# grep &quot;bgx&quot; &#x2F;etc&#x2F;passwd</span><br><span class="line">bgx:x:5001:503:2019 new student:&#x2F;home&#x2F;bgx:&#x2F;bin&#x2F;bash</span><br><span class="line"></span><br><span class="line">#2.修改bgx用户uid、gid，附加组</span><br><span class="line">[root@bgx ~]# groupadd -g 5008 network_sa</span><br><span class="line">[root@bgx ~]# groupadd -g 5009 devops</span><br><span class="line">[root@bgx ~]# usermod -u 6001 -g5008 -a -G 5009 bgx</span><br><span class="line"></span><br><span class="line">#3.修改bgx用户的注释信息, 用户家目录, 登录shell, 登录名</span><br><span class="line">[root@bgx ~]# usermod -c &quot;2019 new student&quot; -md &#x2F;bgx -s &#x2F;bin&#x2F;sh -l change_bgx bgx</span><br><span class="line"></span><br><span class="line">#检查是否修改成功</span><br><span class="line">[root@bgx ~]# grep &quot;bgx&quot; &#x2F;etc&#x2F;passwd</span><br><span class="line">bgx_lqz:x:6001:5008:2019 new student:&#x2F;bgx:&#x2F;bin&#x2F;sh</span><br><span class="line">[root@bgx ~]# id change_bgx</span><br><span class="line">uid&#x3D;6001(change_bgx) gid&#x3D;5008(network_sa) groups&#x3D;5008(network_sa),503(sa),5009(devops)</span><br><span class="line">[root@bgx ~]# ll -d &#x2F;bgx</span><br><span class="line">drwx------. 2 bgx_lqz network_sa 4096 2014-09-23 00:13 &#x2F;bgx</span><br><span class="line"></span><br><span class="line">#4.锁定用户[扩展]</span><br><span class="line">[root@bgx ~]# echo &quot;123&quot; |passwd --stdin change_bgx</span><br><span class="line">[root@bgx ~]# usermod -L change_bgx  #锁定后会无法登陆系统</span><br><span class="line"></span><br><span class="line">#5.解锁用户[扩展]</span><br><span class="line">[root@bgx ~]# usermod -U change_bgx</span><br></pre></td></tr></table></figure><p>PS: 当然还有很多命令可以查看用户的信息，以下简单列举一些，但都是我们常用，所以了解即可</p><p>1) 使用finger命名查询用户信息以及登录信息，示例: finger UserName<br>2) 使用chfn命令修改用户信息，示例: chfn UserName<br>3) 使用chsh命令修改用户登录Bash Shell，示例: chsh UserName<br>4) 使用who、whoami、w检查用户登陆情况</p><h3 id="3-使用userdel命令删除账户"><a href="#3-使用userdel命令删除账户" class="headerlink" title="3.使用userdel命令删除账户"></a>3.使用userdel命令删除账户</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#选项 -r 删除用户同时删除它的家目录</span><br><span class="line"></span><br><span class="line">#1.删除user1用户，但不删除用户家目录和 mail spool</span><br><span class="line">[root@bgx ~]# userdel user1</span><br><span class="line"></span><br><span class="line">#2.-r参数可以连同用户家目录一起删除(慎用)</span><br><span class="line">[root@bgx ~]# userdel -r user1</span><br></pre></td></tr></table></figure><h2 id="3-用户扩展知识"><a href="#3-用户扩展知识" class="headerlink" title="3.用户扩展知识"></a>3.用户扩展知识</h2><h3 id="1-前面我们学习如何创建、修改、删除用户，接下来了解下用户的创建流程？"><a href="#1-前面我们学习如何创建、修改、删除用户，接下来了解下用户的创建流程？" class="headerlink" title="1.前面我们学习如何创建、修改、删除用户，接下来了解下用户的创建流程？"></a>1.前面我们学习如何创建、修改、删除用户，接下来了解下用户的创建流程？</h3><p>1.useradd创建用户时，系统会以/etc/login.defs、/etc/defaults/useradd两个配置文件作为参照物，如果在创建用户时指定了参数则会覆盖/etc/login.defs、/etc/defaults/useradd文件默认配置，如未指定则使用默认。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">[root@bgx ~]# grep -Ev &quot;^#|^$&quot; &#x2F;etc&#x2F;login.defs</span><br><span class="line">MAIL_DIR    &#x2F;var&#x2F;spool&#x2F;mail</span><br><span class="line">PASS_MAX_DAYS   99999</span><br><span class="line">PASS_MIN_DAYS   0</span><br><span class="line">PASS_MIN_LEN    5</span><br><span class="line">PASS_WARN_AGE   7</span><br><span class="line">UID_MIN                  1000</span><br><span class="line">UID_MAX                 60000</span><br><span class="line">SYS_UID_MIN               201</span><br><span class="line">SYS_UID_MAX               999</span><br><span class="line">GID_MIN                  1000</span><br><span class="line">GID_MAX                 60000</span><br><span class="line">SYS_GID_MIN               201</span><br><span class="line">SYS_GID_MAX               999</span><br><span class="line">CREATE_HOME yes</span><br><span class="line">UMASK           077</span><br><span class="line">USERGROUPS_ENAB yes</span><br><span class="line">ENCRYPT_METHOD SHA512</span><br><span class="line"></span><br><span class="line">[root@bgx ~]# cat &#x2F;etc&#x2F;default&#x2F;useradd</span><br><span class="line">GROUP&#x3D;100</span><br><span class="line">HOME&#x3D;&#x2F;home      #把用户的家目录建在&#x2F;home中。</span><br><span class="line">INACTIVE&#x3D;-1     #是否启用账号过期停权,-1表示不启用。</span><br><span class="line">EXPIRE&#x3D;         #账号终止日期,不设置表示不启用。</span><br><span class="line">SHELL&#x3D;&#x2F;bin&#x2F;bash #新用户默认所有的shell类型。</span><br><span class="line">SKEL&#x3D;&#x2F;etc&#x2F;skel  #配置新用户家目录的默认文件存放路径。</span><br><span class="line">CREATE_MAIL_SPOOL&#x3D;yes   #创建mail文件。</span><br></pre></td></tr></table></figure><h3 id="2-当使用useradd创建用户时，创建的用户家目录下会存在-bash-环境变量相关的文件，这些环境变量文件默认从-etc-skel目录中拷贝。这个默认拷贝环境变量位置是由-etc-defaults-useradd配置文件中定义的。"><a href="#2-当使用useradd创建用户时，创建的用户家目录下会存在-bash-环境变量相关的文件，这些环境变量文件默认从-etc-skel目录中拷贝。这个默认拷贝环境变量位置是由-etc-defaults-useradd配置文件中定义的。" class="headerlink" title="2.当使用useradd创建用户时，创建的用户家目录下会存在 .bash_ 环境变量相关的文件，这些环境变量文件默认从/etc/skel目录中拷贝。这个默认拷贝环境变量位置是由/etc/defaults/useradd配置文件中定义的。"></a>2.当使用useradd创建用户时，创建的用户家目录下会存在 .bash_ 环境变量相关的文件，这些环境变量文件默认从/etc/skel目录中拷贝。这个默认拷贝环境变量位置是由/etc/defaults/useradd配置文件中定义的。</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#故障案例，在当前用户家目录执行了rm -rf .，下次登录系统时出现-bash-4.1$，如何解决！</span><br><span class="line">-bash-4.1$ cp -a &#x2F;etc&#x2F;skel&#x2F;.bash .&#x2F;</span><br><span class="line">-bash-4.1$ exit</span><br><span class="line">[root@bgx ~]#   #重新连接即可恢复</span><br></pre></td></tr></table></figure><p>2.如何为新用户设定密码，又如何变更用户密码<br>创建用户后，如需要使用该用户登陆系统则需要为用户设定密码，设定密码使用passwd命令。建议密码复杂度高一些、长度大于10、出现各种特殊字符、无任何规律(不要出现名字，电话，生日等)<br>PS: 注意事项<br>1.普通用户只允许变更自己的密码，无法修改其他人密码，并且密码长度必须8位字符<br>2.管理员用户允许修改任何人的密码，无论密码长度多长或多短。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">#1.使用passwd命令修改用户密码</span><br><span class="line"># passwd        #给当前用户修改密码</span><br><span class="line"># passwd root   #给root用户修改密码</span><br><span class="line"># passwd oldboy #给oldboy用户修改密码，普通用户只能自己修改自己</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#2.验证如下几项指标</span><br><span class="line"># passwd                #root管理员用户登陆，修改root用户密码</span><br><span class="line"># passwd lqz     #root用户登陆，修改其他用户的密码</span><br><span class="line">$ passwd root           #普通用户修改root管理员密码</span><br><span class="line"># echo &quot;123&quot; | passwd --stdin lqz    #非交互式修改密码</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#3.系统内置变量生成随机字符串</span><br><span class="line">[root@bgx ~]# echo $RANDOM|md5sum|cut -c 1-10</span><br><span class="line">d09fe9b1xs</span><br><span class="line">[root@bgx ~]# echo $(echo $RANDOM|md5sum |cut -c 5-14) |tee pass.txt| passwd --stdin lqz</span><br><span class="line"></span><br><span class="line">#4.mkpasswd生成随机字符串, -l设定密码长度,-d数子,-c小写字母,-C大写字母,-s特殊字符</span><br><span class="line">[root@bgx ~]# yum install -y expect   &#x2F;&#x2F;需要安装扩展包</span><br><span class="line">[root@bgx ~]# mkpasswd -l 10 -d 2 -c 2 -C 2 -s 4</span><br><span class="line">|K&amp;13bR)i&#x2F;</span><br></pre></td></tr></table></figure><p>PS: 推荐密码保存套件工具，支持windows、MacOS、Iphone以及浏览器插件<a href="https://www.lastpass.com/zh" target="_blank" rel="noopener">Lastpass官方网站</a></p><h2 id="3-用户组的管理"><a href="#3-用户组的管理" class="headerlink" title="3.用户组的管理"></a>3.用户组的管理</h2><h3 id="1-什么是用户组？"><a href="#1-什么是用户组？" class="headerlink" title="1.什么是用户组？"></a>1.什么是用户组？</h3><p>其实就是一种逻辑层面的定义，逻辑上将多个用户归纳至一个组，当我们对组操作，其实就相当于对组中的所有用户操作。</p><h3 id="2-对于用户来说，组有几种类别？"><a href="#2-对于用户来说，组有几种类别？" class="headerlink" title="2.对于用户来说，组有几种类别？"></a>2.对于用户来说，组有几种类别？</h3><p>基本组，用户只能有一个基本组，创建时可通过-g指定，如未指定则创建一个默认的组(与用户同名)<br>附加组，基本组不能满足授权要求，创建附加组，将用户加入该组，用户可以属于多个附加组<br><img src= "/img/loading.gif" data-src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ghu6wxg1rqj31dg0csjwp.jpg" alt="img"></p><h3 id="3-那组的信息保存在哪呢？"><a href="#3-那组的信息保存在哪呢？" class="headerlink" title="3.那组的信息保存在哪呢？"></a>3.那组的信息保存在哪呢？</h3><p>组账户信息保存在/etc/group和/etc/gshadow两个文件中。重点关注group</p><p>1./etc/group 配置文件解释如下图<br><img src= "/img/loading.gif" data-src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ghu6x17g22j30nq086jth.jpg" alt="img"><br>2./etc/gshadow 配置文件解释如下图<br><img src= "/img/loading.gif" data-src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ghu6x4hi4ej30oo09eq51.jpg" alt="img"><br>1.使用groupadd命令新增组，groupadd [-g GID] groupname</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">#创建基本组, 不指定gid</span><br><span class="line">[root@bgx ~]# groupadd no_gid</span><br><span class="line">[root@bgx ~]# tail -n1 &#x2F;etc&#x2F;group</span><br><span class="line">no_gid:x:1000:</span><br><span class="line"></span><br><span class="line">#创建基本组, 指定gid为5555</span><br><span class="line">[root@bgx ~]# groupadd -g 5555 yes_gid</span><br><span class="line">[root@bgx ~]# tail -n1 &#x2F;etc&#x2F;group</span><br><span class="line">yes_gid:x:5555:</span><br><span class="line"></span><br><span class="line">#创建系统组，gid从201-999</span><br><span class="line">[root@bgx ~]# groupadd -r sys_group</span><br><span class="line">[root@bgx ~]# tail -n1 &#x2F;etc&#x2F;group</span><br><span class="line">sys_group:x:990:</span><br></pre></td></tr></table></figure><p>2.使用groupmod命令新增组</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#-g 修改组gid</span><br><span class="line">[root@bgx ~]# groupmod -g 1111 no_gid</span><br><span class="line">[root@bgx ~]# tail -1 &#x2F;etc&#x2F;group</span><br><span class="line">no_gid:x:1111:</span><br><span class="line"></span><br><span class="line">#-n 修改组名称</span><br><span class="line">[root@bgx ~]# groupmod -n active_group yes_gid</span><br><span class="line">[root@bgx ~]# tail -1 &#x2F;etc&#x2F;group</span><br><span class="line">active_group:x:5555:</span><br></pre></td></tr></table></figure><p>3.groupdel删除组，删除时需要注意，如果用户存在基本组则无法直接删除该组，如果删除用户则会移除默认的私有组，而不会移除基本组。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">#删除组</span><br><span class="line">[root@bgx ~]# groupdel active_group</span><br><span class="line"></span><br><span class="line">#删除用户附加组</span><br><span class="line">[root@bgx ~]# id lqz</span><br><span class="line">uid&#x3D;1069(lqz) gid&#x3D;5005(lqz) groups&#x3D;5005(lqz),5004(devops)</span><br><span class="line">[root@bgx ~]# groupdel devops</span><br><span class="line">[root@bgx ~]# id lqz</span><br><span class="line">uid&#x3D;1069(lqz) gid&#x3D;5005(lqz) groups&#x3D;5005(lqz)</span><br><span class="line"></span><br><span class="line">#无法删除用户基本组</span><br><span class="line">[root@bgx ~]# groupdel network_sa</span><br><span class="line">groupdel: cannot remove the primary group of user &#39;bgx_lqz&#39;</span><br><span class="line">#只有删除用户或者用户变更基本后,方可删除该组</span><br></pre></td></tr></table></figure><p>4.使用gpasswd设置组密码[扩展，可以不会]</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@bgx ~]# groupadd devops</span><br><span class="line">[root@bgx ~]# gpasswd devops</span><br><span class="line">Changing the password for group devops</span><br><span class="line">New Password:</span><br><span class="line">Re-enter new password:</span><br></pre></td></tr></table></figure><p>5.使用newgrp命令切换基本组身份[扩展，可以不会]</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">#1.检查账户信息</span><br><span class="line">[root@bgx ~]# useradd lqz</span><br><span class="line">[root@bgx ~]# id lqz</span><br><span class="line">uid&#x3D;1069(lqz) gid&#x3D;5005(lqz) groups&#x3D;5005(lqz)</span><br><span class="line"></span><br><span class="line">#2.切换普通用户</span><br><span class="line">[root@bgx ~]# su - lqz</span><br><span class="line"></span><br><span class="line">#3.创建新文件,查看文件的属主和属组</span><br><span class="line">[lqz@bgx ~]$ touch file_roots</span><br><span class="line">[lqz@bgx ~]$ ll</span><br><span class="line">-rw-rw-r-- 1 lqz lqz 0 Jun 13 10:06 file_roots</span><br><span class="line"></span><br><span class="line">#4.使用newgrp切换到devops组</span><br><span class="line">[lqz@bgx ~]$ newgrp devops</span><br><span class="line">Password:</span><br><span class="line"></span><br><span class="line">#5.创建文件，检查属主和属组</span><br><span class="line">[lqz@bgx ~]$ touch file_test</span><br><span class="line">[lqz@bgx ~]$ ll</span><br><span class="line">-rw-rw-r-- 1 lqz lqz 0 Jun 13 10:06 file_roots</span><br><span class="line">-rw-r--r-- 1 lqz devops     0 Jun 13 10:08 file_test</span><br></pre></td></tr></table></figure><h2 id="4-用户如何提权"><a href="#4-用户如何提权" class="headerlink" title="4.用户如何提权"></a>4.用户如何提权</h2><p>往往公司的服务器对外都是禁止root用户直接登录，所以我们通常使用的都是普通用户，那么问题来了？<br>当我们使用普通用户执行/sbin目录下的命令时，会发现没有权限运行，这种情况下我们无法正常的管理服务器，那如何才能不使用root用户直接登录系统，同时又保证普通用户能完成日常工作？<br>PS: 我们可以使用如下两种方式: su、sudo<br>1.su切换用户，使用普通用户登录，然后使用su命令切换到root。优点:简单 缺点:需要知道root密码<br>2.sudo提权，当需要使用root权限时进行提权，而无需切换至root用户，优点:安全、方便 缺点:复杂</p><h3 id="1-su身份切换"><a href="#1-su身份切换" class="headerlink" title="1.su身份切换"></a>1.su身份切换</h3><p>在使用su切换前，我们需要了解一些预备知识，比如shell分类、环境变量配置文件有哪些</p><p>1.Linux Shell主要分为如下几类<br>交互式shell，等待用户输入执行的命令(终端操作,需要不断提示)<br>非交互式shell，执行shell脚本, 脚本执行结束后shell自动退出<br>登陆shell，需要输入用户名和密码才能进入Shell，日常接触的最多的一种<br>非登陆shell，不需要输入用户和密码就能进入Shell,比如运行bash会开启一个新的会话窗口</p><p>2.bash shell配置文件介绍(文件主要保存用户的工作环境)<br>个人配置文件：~/.bash_profile ~/.bashrc 。全局配置文件：/etc/profile /etc/profile.d/.sh /etc/bashrc<br>profile类文件, 设定环境变量, 登陆前运行的脚本和命令。bashrc 类文件, 设定本地变量, 定义命令别名<br>PS: 如果全局配置和个人配置产生冲突，以个人配置为准。</p><p>3.登陆系统后，环境变量配置文件的应用顺序是?<br>登录式shell配置文件执行顺序: /etc/profile-&gt;/etc/profile.d/.sh-&gt;<del>/.bash_profile-&gt;</del>/.bashrc-&gt;/etc/bashrc<br>非登陆式shell配置文件执行顺序: ~/.bashrc-&gt;/etc/bashrc-&gt;/etc/profile.d/.sh<br>PS: 验证使用echo在每行添加一个输出即可</p><p>4.说了这么多预备知识，那这些和su命令切换用户有什么关系?<br>su - username属于登陆式shell，su username属于非登陆式shell，区别在于加载的环境变量不一样。<br>普通用户<code>su -</code>可以直接切换至root用户，但需要输入root用户的密码。<br>超级管理员root用户使用<code>su - username</code>切换普通用户不需要输入任何密码。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">#1.普通用户使用su切换root</span><br><span class="line">[lqz@node1 ~]$ su</span><br><span class="line">密码：         #输入root的密码</span><br><span class="line">[root@node1 lqz]# pwd</span><br><span class="line">&#x2F;home&#x2F;lqz</span><br><span class="line"></span><br><span class="line">#2.普通用户使用su -切换到root，会加载root的环境变量</span><br><span class="line">[lqz@node1 ~]$ su -</span><br><span class="line">密码：</span><br><span class="line">[root@node1 ~]# pwd</span><br><span class="line">&#x2F;root</span><br><span class="line"></span><br><span class="line">#3.以某个用户的身份执行某个服务，使用命令su -c username</span><br><span class="line">[root@bgx ~]# su - lqz -c &#39;ifconfig&#39;</span><br><span class="line">[root@bgx ~]# su - lqz -c &#39;ls ~&#39;</span><br></pre></td></tr></table></figure><h3 id="2-sudo提权"><a href="#2-sudo提权" class="headerlink" title="2.sudo提权"></a>2.sudo提权</h3><p>su命令在切换用户身份时，如果每个普通用户都能拿到root用户的密码，当其中某个用户不小心泄漏了root的密码，那系统会变得非常不安全。为了改进这个问题，从而产生了sudo这个命令。</p><p>其实sudo就相当于给某个普通用户埋下了浩克(hulk)的种子，当需要执行一些高级操作时，进行发怒，但正常情况下还是普通人，还是会受到限制。<br><img src= "/img/loading.gif" data-src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ghu6xayyl7j30n00j0771.jpg" alt="img"></p><p>1.如何快速埋下hulk的种子呢？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#1.快速配置sudo方式[先睹为快]</span><br><span class="line">[root@node1 ~]# usermod bgx -G wheel</span><br><span class="line">[root@node1 ~]$ sudo tail -f &#x2F;var&#x2F;log&#x2F;secure    #sudo审计日志</span><br><span class="line"></span><br><span class="line">#2.一般正常配置sudo方式</span><br><span class="line">[root@www ~]# #visudo &#x3D;&gt; vim &#x2F;etc&#x2F;sudoers</span><br><span class="line">#1.用户名  2.主机名&#x3D;(角色名）       4.命令名</span><br><span class="line">bgx       ALL&#x3D;(ALL)         &#x2F;usr&#x2F;bin&#x2F;yum,&#x2F;usr&#x2F;sbin&#x2F;useradd   #允许使用sudo执行命令</span><br><span class="line">oldboy   ALL&#x3D;(ALL)          NOPASSWD:&#x2F;bin&#x2F;cp, &#x2F;bin&#x2F;rm   #NOPASSWD不需要使用密码</span><br></pre></td></tr></table></figure><p>2.埋下了hulk种子后又如何提权使用呢？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">#1.切换普通用户</span><br><span class="line">[root@bgx ~]# su - lqz</span><br><span class="line"></span><br><span class="line">#2.检查普通用户能提权的命令</span><br><span class="line">[lqz@lqz ~]$ sudo -l</span><br><span class="line">User lqz may run the following commands on this host:</span><br><span class="line">    (ALL) ALL</span><br><span class="line"></span><br><span class="line">#3.普通用户正常情况下是无法删除opt目录的</span><br><span class="line">[lqz@lqz ~]$ rm -rf &#x2F;opt&#x2F;</span><br><span class="line">rm: cannot remove &#96;&#x2F;opt: Permission denied</span><br><span class="line"></span><br><span class="line">#4.使用sudo提权，需要输入普通用户的密码。</span><br><span class="line">[lqz@lqz ~]$ sudo rm -rf &#x2F;opt</span><br></pre></td></tr></table></figure><h3 id="3-提升的权限太大，能否有办法限制仅开启某个命令的使用权限？其他命令不允许？"><a href="#3-提升的权限太大，能否有办法限制仅开启某个命令的使用权限？其他命令不允许？" class="headerlink" title="3.提升的权限太大，能否有办法限制仅开启某个命令的使用权限？其他命令不允许？"></a>3.提升的权限太大，能否有办法限制仅开启某个命令的使用权限？其他命令不允许？</h3><p>第一种方式:使用sudo中自带的别名操作,将多个用户定义成一个组,这个组只有sudo认可</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">[root@bgx ~]# visudo  #也可以使用vi &#x2F;etc&#x2F;sudoers来配置</span><br><span class="line"># 1.使用sudo定义分组,这个系统group没什么关系</span><br><span class="line">User_Alias OPS &#x3D; oldboy,alex</span><br><span class="line">User_Alias DEV &#x3D; bgx,py</span><br><span class="line"></span><br><span class="line"># 2.定义可执行的命令组,便于后续调用</span><br><span class="line">Cmnd_Alias NETWORKING &#x3D; &#x2F;sbin&#x2F;ifconfig, &#x2F;bin&#x2F;ping</span><br><span class="line">Cmnd_Alias SOFTWARE &#x3D; &#x2F;bin&#x2F;rpm, &#x2F;usr&#x2F;bin&#x2F;yum</span><br><span class="line">Cmnd_Alias SERVICES &#x3D; &#x2F;sbin&#x2F;service, &#x2F;usr&#x2F;bin&#x2F;systemctl start</span><br><span class="line">Cmnd_Alias STORAGE &#x3D; &#x2F;bin&#x2F;mount, &#x2F;bin&#x2F;umount</span><br><span class="line">Cmnd_Alias DELEGATING &#x3D; &#x2F;bin&#x2F;chown, &#x2F;bin&#x2F;chmod, &#x2F;bin&#x2F;chgrp</span><br><span class="line">Cmnd_Alias PROCESSES &#x3D; &#x2F;bin&#x2F;nice, &#x2F;bin&#x2F;kill, &#x2F;usr&#x2F;bin&#x2F;kill, &#x2F;usr&#x2F;bin&#x2F;killall</span><br><span class="line"></span><br><span class="line"># 3.使用sudo开始分配权限</span><br><span class="line">OPS  ALL&#x3D;(ALL) NETWORKING,SOFTWARE,SERVICES,STORAGE,DELEGATING,PROCESSES</span><br><span class="line">DEV  ALL&#x3D;(ALL) SOFTWARE,PROCESSES</span><br><span class="line"></span><br><span class="line">#4.登陆对应的用户使用 sudo -l 验证权限</span><br></pre></td></tr></table></figure><p>第二种方式:使用groupadd添加组,然后给组分配sudo的权限,如果有新用户加入,直接将用户添加到该组.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">#1.添加两个真实的系统组,  group_dev group_op</span><br><span class="line">[root@www ~]# groupadd group_dev</span><br><span class="line">[root@www ~]# groupadd group_op</span><br><span class="line"></span><br><span class="line">#2.添加两个用户,      group_dev(user_a  user_b)   group_op(user_c  user_d)</span><br><span class="line">[root@www ~]# useradd user_a -G group_dev</span><br><span class="line">[root@www ~]# useradd user_b -G group_dev</span><br><span class="line">[root@www ~]# useradd user_c -G group_op</span><br><span class="line">[root@www ~]# useradd user_d -G group_op</span><br><span class="line"></span><br><span class="line">#3.记得添加密码</span><br><span class="line">[root@www ~]# echo &quot;1&quot; | passwd --stdin user_a</span><br><span class="line">[root@www ~]# echo &quot;1&quot; | passwd --stdin user_b</span><br><span class="line">[root@www ~]# echo &quot;1&quot; | passwd --stdin user_c</span><br><span class="line">[root@www ~]# echo &quot;1&quot; | passwd --stdin user_d</span><br><span class="line"></span><br><span class="line">#4.在sudo中配置规则</span><br><span class="line">[root@www ~]# visudo</span><br><span class="line">    Cmnd_Alias NETWORKING &#x3D; &#x2F;sbin&#x2F;ifconfig, &#x2F;bin&#x2F;ping</span><br><span class="line">    Cmnd_Alias SOFTWARE &#x3D; &#x2F;bin&#x2F;rpm, &#x2F;usr&#x2F;bin&#x2F;yum</span><br><span class="line">    Cmnd_Alias SERVICES &#x3D; &#x2F;sbin&#x2F;service, &#x2F;usr&#x2F;bin&#x2F;systemctl start</span><br><span class="line">    Cmnd_Alias STORAGE &#x3D; &#x2F;bin&#x2F;mount, &#x2F;bin&#x2F;umount</span><br><span class="line">    Cmnd_Alias DELEGATING &#x3D; &#x2F;bin&#x2F;chown, &#x2F;bin&#x2F;chmod, &#x2F;bin&#x2F;chgrp</span><br><span class="line">    Cmnd_Alias PROCESSES &#x3D; &#x2F;bin&#x2F;nice, &#x2F;bin&#x2F;kill, &#x2F;usr&#x2F;bin&#x2F;kill, &#x2F;usr&#x2F;bin&#x2F;killall</span><br><span class="line"></span><br><span class="line">    %group_dev ALL&#x3D;(ALL) SOFTWARE</span><br><span class="line">    %group_op ALL&#x3D;(ALL) SOFTWARE,PROCESSES</span><br><span class="line"></span><br><span class="line">#5.检查sudo是否配置有错</span><br><span class="line">[root@www ~]# visudo -c</span><br><span class="line">&#x2F;etc&#x2F;sudoers: parsed OK</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#6.检查user_a,和user_d的sudo权限</span><br><span class="line">[user_a@www.oldboyedu.com ~]$ sudo -l</span><br><span class="line">User user_a may run the following commands on www:</span><br><span class="line">    (ALL) &#x2F;bin&#x2F;rpm, &#x2F;usr&#x2F;bin&#x2F;yum</span><br><span class="line"></span><br><span class="line">[user_d@www.oldboyedu.com ~]$ sudo -l</span><br><span class="line">User user_d may run the following commands on www:</span><br><span class="line">    (ALL) &#x2F;bin&#x2F;rpm, &#x2F;usr&#x2F;bin&#x2F;yum, &#x2F;bin&#x2F;nice, &#x2F;bin&#x2F;kill, &#x2F;usr&#x2F;bin&#x2F;kill, &#x2F;usr&#x2F;bin&#x2F;killall</span><br></pre></td></tr></table></figure><h3 id="4-sudo命令的执行流程"><a href="#4-sudo命令的执行流程" class="headerlink" title="4.sudo命令的执行流程:"></a>4.sudo命令的执行流程:</h3><p>1) 普通用户执行sudo命令时, 会检查/var/db/sudo是否存在时间戳缓存<br>2) 如果存在则不需要输入密码, 否则需要输入用户与密码<br>3) 输入密码会检测是否该用户是否拥有该权限<br>4) 如果有则执行，否则报错退出</p><p><img src= "/img/loading.gif" data-src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ghu6xgqe06j30bc0jpmz3.jpg" alt="img"></p><p><a href="https://www.jianshu.com/p/d172a92475f1" target="_blank" rel="noopener">sudo不支持系统内置命令</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1-用户基本概述&quot;&gt;&lt;a href=&quot;#1-用户基本概述&quot; class=&quot;headerlink&quot; title=&quot;1.用户基本概述&quot;&gt;&lt;/a&gt;1.用户基本概述&lt;/h2&gt;&lt;h3 id=&quot;1-什么是用户&quot;&gt;&lt;a href=&quot;#1-什么是用户&quot; class=&quot;header
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>4-Linux——文件编辑</title>
    <link href="http://yoursite.com/2019/02/23/Linux%E2%80%94%E2%80%94%E6%96%87%E4%BB%B6%E7%BC%96%E8%BE%91/"/>
    <id>http://yoursite.com/2019/02/23/Linux%E2%80%94%E2%80%94%E6%96%87%E4%BB%B6%E7%BC%96%E8%BE%91/</id>
    <published>2019-02-23T13:30:21.000Z</published>
    <updated>2020-08-18T12:10:59.640Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-VIM基本概述"><a href="#1-VIM基本概述" class="headerlink" title="1.VIM基本概述"></a>1.VIM基本概述</h2><h3 id="1-什么是VIM"><a href="#1-什么是VIM" class="headerlink" title="1.什么是VIM?"></a>1.什么是VIM?</h3><p>vi和vim是Linux下的一个文本编辑工具。(可以理解为windows的记事本，或word文档)</p><h3 id="2-为什么要使用VIM"><a href="#2-为什么要使用VIM" class="headerlink" title="2.为什么要使用VIM?"></a>2.为什么要使用VIM?</h3><p>因为Linux系统一切皆为文件，而我们工作最多的就是修改某个服务的配置(其实就是修改文件内容)。<br>也就是说如果没有vi/vim，我们很多工作都无法完成。PS: vim是学习linux最重要的命令之一</p><h3 id="3-VI与VIM有什么区别"><a href="#3-VI与VIM有什么区别" class="headerlink" title="3.VI与VIM有什么区别?"></a>3.VI与VIM有什么区别?</h3><p>vi和vim都是文本编辑器，只不过vim是vi的增强版，比vi多了语法高亮显示，其他编辑功能几乎无差，所以使用vi还是vim取决个人习惯。(相当于windows系统下的文本编辑软件“记事本”与”notepad++”的区别)<br>PS：因为前期最小化安装CentOS系统，所以默认情况下没有vim命令，但可以使用yum install vim -y安装</p><h3 id="4-如何使用VIM编辑器"><a href="#4-如何使用VIM编辑器" class="headerlink" title="4.如何使用VIM编辑器?"></a>4.如何使用VIM编辑器?</h3><p>在使用VIM之前，我们需要先介绍下VIM的三种模式: 普通模式、编辑模式、命令模式，每种模式分别支持多种不同的快捷键，要想高效率地操作文本，就必须先搞清这三种模式的操作区别以及模式之间的切换方法。<br><img src= "/img/loading.gif" data-src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ghu6w4k7z4j30pu0bujt6.jpg" alt="img"></p><h3 id="5-VIM模式三种模式介绍"><a href="#5-VIM模式三种模式介绍" class="headerlink" title="5.VIM模式三种模式介绍"></a>5.VIM模式三种模式介绍</h3><p>1.普通模式: 主要是控制光标移动，可对文本进行复制、粘贴、删除等工作。<br>使用vim filename 编辑一个文件时，一进入该文件就是普通模式了。<br>在这个模式下，可以进行光标移动、复制、删除、粘贴操作。</p><p>2.编辑模式: 主要进行文本内容编辑和修改<br>从普通模式进入编辑模式，只需你按一个键即可（i, I, a, A, o, O）<br>当进入编辑模式时，会在屏幕的最下一行会出现 “INSERT”标记<br>从编辑模式回到普通模式只需要按键盘左上方的 ESC 键即可。</p><p>3.末行模式: 主要用于保存或退出文本。<br>在普通模式下，输入 “:” 或者 “/“ 即可进入命令模式。<br>在命令该模式下，可进行的操作有，显示行号、搜索、替换、保存、退出。</p><p>小结: vim编辑打开文件整体流程如下:<br>1.默认打开文件处于普通模式<br>2.从普通模式切换至编辑模式需要使用a、i、o<br>3.编辑模式修改完毕后需要先使用ECS返回普通模式<br>4.在普通模式输入”:”或”/“进入命令模式，可实现文件的保存与退出。<br>PS: 在vim中，无法直接从编辑模式切换到命令模式。</p><h2 id="2-VIM模式使用"><a href="#2-VIM模式使用" class="headerlink" title="2.VIM模式使用"></a>2.VIM模式使用</h2><h3 id="1-普通模式"><a href="#1-普通模式" class="headerlink" title="1.普通模式"></a>1.普通模式</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">#1.命令光标跳转</span><br><span class="line">G       #光标跳转至末端</span><br><span class="line">gg      #光标跳转至顶端</span><br><span class="line">Ngg     #光标跳转至当前文件内的N行</span><br><span class="line">$       #光标跳转至当前光标所在行的尾部</span><br><span class="line">^|0     #光标跳转至当前光标所在行的首部</span><br><span class="line"></span><br><span class="line">#2.文件内容较多</span><br><span class="line">ctrl+f  #往下翻页(行比较多)</span><br><span class="line">ctrl+b  #往上翻页</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#3.复制与粘贴</span><br><span class="line">yy      #复制当前光标所在的行</span><br><span class="line">5yy     #复制当前光标以及光标向下4行</span><br><span class="line"> </span><br><span class="line">p(小写)   #粘贴至当前光标下一行   </span><br><span class="line">P(大写)   #粘贴至当前光标上一行</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#4.删除、剪贴、撤销  </span><br><span class="line">dd      #删除当前光标所在的行   </span><br><span class="line">4dd     #删除当前光标所在的行以及往下的3行</span><br><span class="line">dG      #删除当前光标以后的所有行</span><br><span class="line">D       #删除当前光标及光标以后的内容  </span><br><span class="line">x       #删除当前光标标记往后的字符</span><br><span class="line">X       #删除当前光标标记往前的字符</span><br><span class="line">dd &amp; p  #剪贴、先删除dd(number dd)，后粘贴p</span><br><span class="line">u       #撤销上一次的操作</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#5.替换</span><br><span class="line">r       #替换当前光标标记的单个字符</span><br><span class="line">R       #进入REPLACE模式, 连续替换，ESC结束</span><br></pre></td></tr></table></figure><h3 id="2-编辑模式-从普通模式进入到编辑模式"><a href="#2-编辑模式-从普通模式进入到编辑模式" class="headerlink" title="2.编辑模式(从普通模式进入到编辑模式)"></a>2.编辑模式(从普通模式进入到编辑模式)</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">i   #进入编辑模式，光标不做任何操作</span><br><span class="line">a   #进入编辑模式，将当前光标往后一位</span><br><span class="line">o   #进入编辑模式，并在当前光标下添加一行空白内容</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">I   #进入编辑模式，并且光标会跳转至本行的头部</span><br><span class="line">A   #进入编辑模式，将光标移动至本行的尾部</span><br><span class="line">O   #进入编辑模式，并在当前光标上添加一行空白内容</span><br></pre></td></tr></table></figure><h3 id="3-命令模式，主要用于搜索-保存-退出文件。"><a href="#3-命令模式，主要用于搜索-保存-退出文件。" class="headerlink" title="3.命令模式，主要用于搜索, 保存, 退出文件。"></a>3.命令模式，主要用于搜索, 保存, 退出文件。</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">#1.文件保存与退出</span><br><span class="line">:w      保存当前状态</span><br><span class="line">:w!     强制保存当前状态</span><br><span class="line">:q      退出当前文档(文档必须保存才能退出)</span><br><span class="line">:q!     强制退出文档不会修改当前内容</span><br><span class="line">:wq     先保存，在退出</span><br><span class="line">:wq!    强制保存并退出</span><br><span class="line">:x      先保存，在退出</span><br><span class="line">ZZ      保存退出, shfit+zz</span><br><span class="line">:number 跳转至对应的行号</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#2.文件内容查找</span><br><span class="line">&#x2F;string #需要搜索的内容（查找）</span><br><span class="line">n       #按搜索到的内容依次往下进行查找</span><br><span class="line">N       #按搜索到的内容依次往上进行查找</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#3.文件内容替换</span><br><span class="line">:1,5s#sbin#test#g   #替换1-5行中包含sbin的内容为test</span><br><span class="line">:%s#sbin#test#g     #替换整个文本文件中包含sbin的替换为test</span><br><span class="line">:%s#sbin#test#gc    #替换内容时时提示是否需要替换</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#4.文件内容另存</span><br><span class="line">:w &#x2F;root&#x2F;test.txt  #将所有内容另存为&#x2F;root&#x2F;test.txt文件中</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#5.文件内容读入</span><br><span class="line">:r  &#x2F;etc&#x2F;hosts  #读入&#x2F;etc&#x2F;hosts文件至当前光标下面</span><br><span class="line">:5r &#x2F;etc&#x2F;hosts  #指定插入&#x2F;etc&#x2F;hosts文件至当前文件的第五行下面</span><br></pre></td></tr></table></figure><h3 id="4-视图模式-从普通模式进入视图模式-，主要进行批量操作"><a href="#4-视图模式-从普通模式进入视图模式-，主要进行批量操作" class="headerlink" title="4.视图模式(从普通模式进入视图模式)，主要进行批量操作"></a>4.视图模式(从普通模式进入视图模式)，主要进行批量操作</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ctrl+v  进入可视块模式，选中需要注释的行</span><br><span class="line">    1.插入:按shift+i进入编辑模式,输入#,结束按ESC键</span><br><span class="line">    2.删除:选中内容后，按x或者d键删除</span><br><span class="line">    3.替换:选中需要替换的内容, 按下r键,然后输入替换后的内容</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">shift+v 进入可视行模式，选中整行内容</span><br><span class="line">    1.复制:选中行内容后按y键及可复制。</span><br><span class="line">    2.删除:选中行内容后按d键删除。</span><br></pre></td></tr></table></figure><h2 id="3-VIM扩展知识"><a href="#3-VIM扩展知识" class="headerlink" title="3.VIM扩展知识"></a>3.VIM扩展知识</h2><h3 id="1-环境变量临时生效"><a href="#1-环境变量临时生效" class="headerlink" title="1.环境变量临时生效"></a>1.环境变量临时生效</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">:set nu             #显示行号</span><br><span class="line">:set ic             #忽略大小写, 在搜索的时候有用</span><br><span class="line">:set ai             #自动缩进</span><br><span class="line">:set list           #显示制表符(空行、tab键)</span><br><span class="line">:set no[nu|ic|ai…]  #取消临时设定的变量</span><br></pre></td></tr></table></figure><h3 id="2-环境变量永久生效。-vimrc-个人环境变量-优先级高-etc-vimrc-全局环境变量"><a href="#2-环境变量永久生效。-vimrc-个人环境变量-优先级高-etc-vimrc-全局环境变量" class="headerlink" title="2.环境变量永久生效。~/.vimrc 个人环境变量(优先级高) /etc/vimrc 全局环境变量"></a>2.环境变量永久生效。~/.vimrc 个人环境变量(优先级高) /etc/vimrc 全局环境变量</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># vim  ~&#x2F;.vimrc #当下次再打开文件自动显示行号并忽略大小写</span><br><span class="line">set nu</span><br><span class="line">set ic</span><br><span class="line"></span><br><span class="line">#如果个人vim环境没有配置, 则使用全局vim环境变量配置。</span><br><span class="line">#如果个人vim环境和全局环境变量产生冲突, 优先使用个人vim环境变量。</span><br></pre></td></tr></table></figure><h3 id="3-如何同时编辑多个文件"><a href="#3-如何同时编辑多个文件" class="headerlink" title="3.如何同时编辑多个文件"></a>3.如何同时编辑多个文件</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">vim -o file1 file2  #水平分割</span><br><span class="line">vim -O file1 file2  #垂直分割</span><br><span class="line"></span><br><span class="line">#ctrl+ww 文件间切换</span><br></pre></td></tr></table></figure><h3 id="4-相同文件之间差异对比，通常用于对比修改前后差异"><a href="#4-相同文件之间差异对比，通常用于对比修改前后差异" class="headerlink" title="4.相同文件之间差异对比，通常用于对比修改前后差异"></a>4.相同文件之间差异对比，通常用于对比修改前后差异</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># diff      #文件对比   </span><br><span class="line"># vimdiff   #以vim方式打开两个文件对比，高亮显示不同的内容</span><br></pre></td></tr></table></figure><h3 id="5-如果VIM非正常退出-（ctrl-z）挂起或强制退出终端没关闭VIM后"><a href="#5-如果VIM非正常退出-（ctrl-z）挂起或强制退出终端没关闭VIM后" class="headerlink" title="5.如果VIM非正常退出 （ctrl+z）挂起或强制退出终端没关闭VIM后"></a>5.如果VIM非正常退出 （ctrl+z）挂起或强制退出终端没关闭VIM后</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#假设打开filename文件被以外关闭，需要删除同文件名的.swp文件即可解决</span><br><span class="line"># rm -f .filename.swp</span><br></pre></td></tr></table></figure><h2 id="4-VIM练习示例"><a href="#4-VIM练习示例" class="headerlink" title="4.VIM练习示例"></a>4.VIM练习示例</h2><p>1.将/etc/passwd 复制到/root/目录下，并重命名为test.txt<br>2.用vim打开test.txt并显示行号<br>3.分别向下、向右、向左、向右移动5个字符，分别向下、向上翻两页<br>4.把光标移动到第10行，让光标移动到行末，再移动到行首，移动到test.txt文件的最后一行，移动到文件的首行<br>5.搜索文件中出现的 root 并数一下一共出现多少个,不区分大小写搜索<br>6.把从第一行到第三行出现的root 替换成–od–，然后还原上一步操作<br>8.把整个文件中所有的root替换成–od–<br>9.把光标移动到20行，删除本行，还原上一步操作<br>10.删除第19行，还原上一步操作<br>11.删除从5行到10行的所有内容，还原上一步操作<br>12.复制2行并粘贴到11行下面，还原上一步操作（按两次u）<br>13.复制从11行到15行的内容并粘贴到8行上面，还原上一步操作（按两次u）<br>14.把13行到18行的内容移动文件的尾部，还原上一步操作（按两次u）<br>15.光标移动到首行，把/sbin/nologin改成/bin/bash<br>16.在第一行下面插入新的一行，并输入”# Hello!”<br>17.保存文档并退出</p><p>2.练习示例2-文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">[root@www ~]# cat proxy.conf</span><br><span class="line">server &#123;</span><br><span class="line">    Listen 8080;</span><br><span class="line">    Server_Name vim.OldboyEDU.com;</span><br><span class="line">    location &#x2F; &#123;</span><br><span class="line">        proxy_pass http:&#x2F;&#x2F;127.0.0.1:8080;</span><br><span class="line">        proxy_set_header Host $http_host;</span><br><span class="line">        proxy_set_header X-Forward-for;</span><br><span class="line">        proxy_intercept_errors on;</span><br><span class="line">        proxy_next_upstream error timeout;</span><br><span class="line">        proxy_next_upstream_timeout 3s;</span><br><span class="line">        proxy_next_upstream_tries 2;</span><br><span class="line">        error_page 500 502 403 404 &#x3D; &#x2F;proxy_error.html;</span><br><span class="line">    &#125;</span><br><span class="line">    location &#x3D; &#x2F;proxy_error.html &#123;</span><br><span class="line">        root &#x2F;code&#x2F;proxy;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2.练习示例2-题目<br>1.使用vim打开proxy.conf文件<br>2.修改Listen为listen小写，并将8080修改为80<br>3.修改ServerName为server_name小写。<br>4.修改vim.OldboyEDU.com为vim.oldboy.com<br>5.在server_name行下插入一行 root /code;<br>5.复制5-14行的内容，然后将其粘贴到14行下面<br>6.删除与proxy_set_header相关的两行全部删除<br>7.如上操作完成后，在13-20行前面加上#号<br>8.删除21-23的行，然后保存当前文件</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1-VIM基本概述&quot;&gt;&lt;a href=&quot;#1-VIM基本概述&quot; class=&quot;headerlink&quot; title=&quot;1.VIM基本概述&quot;&gt;&lt;/a&gt;1.VIM基本概述&lt;/h2&gt;&lt;h3 id=&quot;1-什么是VIM&quot;&gt;&lt;a href=&quot;#1-什么是VIM&quot; class=&quot;
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>3-Linux——文件管理</title>
    <link href="http://yoursite.com/2019/02/22/Linux%E2%80%94%E2%80%94%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86/"/>
    <id>http://yoursite.com/2019/02/22/Linux%E2%80%94%E2%80%94%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86/</id>
    <published>2019-02-22T13:24:21.000Z</published>
    <updated>2020-08-18T12:10:34.870Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-文件管理概述"><a href="#1-文件管理概述" class="headerlink" title="1.文件管理概述"></a>1.文件管理概述</h2><h3 id="1-Bash-Shell对文件进行管理"><a href="#1-Bash-Shell对文件进行管理" class="headerlink" title="1.Bash Shell对文件进行管理"></a>1.Bash Shell对文件进行管理</h3><p>谈到Linux文件管理，首先我们需要了解的就是，我们要对文件做些什么事情？<br>其实无非就是对一个文件进行、创建、复制、移动、查看、编辑、压缩、查找、删除、等等<br>例如 : 当我们想修改系统的主机名称，是否应该知道文件在哪，才能去做对应的修改？</p><h3 id="2-内容摘要"><a href="#2-内容摘要" class="headerlink" title="2.内容摘要"></a>2.内容摘要</h3><p>系统目录结构<br>文件路径定位<br>文件管理命令<br>文件类型file<br>链接文件ln<br>文件编辑vim</p><h2 id="2-系统目录结构"><a href="#2-系统目录结构" class="headerlink" title="2.系统目录结构"></a>2.系统目录结构</h2><p>几乎所有的计算机操作系统都是使用目录结构组织文件。具体来说就是在一个目录中存放子目录和文件, 而在子目录中又会进一步存放子目录和文件，以此类推形成一个树状的文件结构，由于其结构很像一棵树的分支, 所以该结构又被称为“目录树”。<br>Windows: 以多根的方式组织文件 C: D:<br>Linux:以单根的方式组织文件 /</p><p>如下图为Centos7的目录结构<br><img src= "/img/loading.gif" data-src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ghu6u9uuiej30zq0cq76d.jpg" alt="img"></p><h3 id="1-存放命令相关的目录"><a href="#1-存放命令相关的目录" class="headerlink" title="1.存放命令相关的目录"></a>1.存放命令相关的目录</h3><p>/bin， 普通用户使用的命令 /bin/ls, /bin/date<br>/sbin，管理员使用的命令 /sbin/service,poweroff,useradd…</p><p>只要看到bin路径，就应该意识到放的是可执行文件</p><p><img src= "/img/loading.gif" data-src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ghu6uf0dtpj30qe08u40d.jpg" alt="img"></p><h3 id="2-存放用户相关数据的家目录，比如-windows不同的用户登陆系统显示的桌面背景不一样"><a href="#2-存放用户相关数据的家目录，比如-windows不同的用户登陆系统显示的桌面背景不一样" class="headerlink" title="2.存放用户相关数据的家目录，比如:windows不同的用户登陆系统显示的桌面背景不一样"></a>2.存放用户相关数据的家目录，比如:windows不同的用户登陆系统显示的桌面背景不一样</h3><p>/home，普通用户的家目录, 默认为/home/username</p><p>环境变量的东西不要删，删掉试一下</p><p>/root，超级管理员root的家目录, 普通用户无权操作<br><img src= "/img/loading.gif" data-src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ghu6ujtk42j30qe08u75r.jpg" alt="img"></p><h3 id="3-系统文件目录"><a href="#3-系统文件目录" class="headerlink" title="3.系统文件目录"></a>3.系统文件目录</h3><p>/usr，相当于C:Windows<br>/usr/local，软件安装的目录，相当于C:Program<br>/usr/bin/，普通用户使用的应用程序(重要)<br>/usr/sbin，管理员使用的应用程序(重要)<br>/usr/lib，库文件Glibc 32bit<br>/usr/lib64，库文件Glibc 64bit</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"># 1 </span><br><span class="line">df -h #df -h查看系统中文件的使用情况</span><br><span class="line">Size 分割区总容量</span><br><span class="line">Used 已使用的大小</span><br><span class="line">Avail 剩下的大小</span><br><span class="line">Use% 使用的百分比</span><br><span class="line">Mounted on 路径地址</span><br><span class="line"># 2</span><br><span class="line">du -sh * 查看当前目录下各个文件及目录占用空间大小</span><br><span class="line">du -sh &#x2F;usr&#x2F;</span><br><span class="line"># 3 标准是实现自动化的基础</span><br><span class="line">不通主机的相同的软件，都放在相同路径下，便于管理，实现自动化</span><br><span class="line">现在一般安装的软件，不放在&#x2F;usr&#x2F;local下了</span><br><span class="line"></span><br><span class="line"># 4 总共有一千来个命令</span><br><span class="line">ls &#x2F;usr&#x2F;bin&#x2F; | wc -l</span><br><span class="line">ls &#x2F;usr&#x2F;sbin&#x2F; | wc -l</span><br><span class="line"></span><br><span class="line"># 5 查看命令依赖那些库文件</span><br><span class="line">ldd &#x2F;bin&#x2F;ls</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ghu6uos4f8j30qe08umyy.jpg" alt="img"></p><h3 id="4-启动目录"><a href="#4-启动目录" class="headerlink" title="4.启动目录"></a>4.启动目录</h3><p>/boot 存放的系统启动相关的文件，例如:kernel，grub(引导装载程序)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ls &#x2F;boot</span><br><span class="line"># linux内核</span><br><span class="line"># 启动机器时可以选择的启动模式</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ghu6utvbtfj310y0majyw.jpg" alt="img"></p><h3 id="5-配置文件目录"><a href="#5-配置文件目录" class="headerlink" title="5.配置文件目录"></a>5.配置文件目录</h3><p>/etc，极其重要，后续所有服务的配置都在这个目录中<br>/etc/sysconfig/network-script/ifcfg-，网络配置文件<br>/etc/hostname，系统主机名配置文件,主机名很重要，有些特殊服务要依赖主机名，没有主机名会报错起不来；修改了要重启：reboot<br>/etc/resolv.conf，dns客户端配置文件,域名解析服务器，一般我们不配置，因为网卡的配置好了，会覆盖掉它，网卡的优先级高<br>/etc/hosts，本地域名解析配置文件，域名解析，先找自己的hosts，再去域名解析</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># 1 </span><br><span class="line">&#x2F;etc&#x2F;hosts 对应windows C:windows&#x2F;system32&#x2F;drivers&#x2F;etc&#x2F;hosts,黑客钓鱼网站</span><br><span class="line"># 2 测试修改</span><br><span class="line">yum install httpd -y</span><br><span class="line">systemctl stop firewalld</span><br><span class="line">echo &quot;lqz NB&quot; &gt;&#x2F;var&#x2F;www&#x2F;html&#x2F;index.html</span><br><span class="line">systemctl start httpd</span><br></pre></td></tr></table></figure><h3 id="6-可变的目录与临时目录"><a href="#6-可变的目录与临时目录" class="headerlink" title="6.可变的目录与临时目录"></a>6.可变的目录与临时目录</h3><p>/var，存放一些变化文件，比如/var/log/下的日志文件,登陆日志<br>/var/tmp，进程产生的临时文件<br>/tmp，系统临时目录(类似于公共厕所)，谁都可以使用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 1 查看登陆日志</span><br><span class="line">cat &#x2F;var&#x2F;log&#x2F;secure #查看登陆时间</span><br><span class="line"># 2 进程产生的临时文件（360清理垃圾，就是会清理）</span><br></pre></td></tr></table></figure><h3 id="7-设备目录文件"><a href="#7-设备目录文件" class="headerlink" title="7.设备目录文件"></a>7.设备目录文件</h3><p>/dev，存放设备文件，比如硬盘，硬盘分区，光驱，等等<br>/dev/sd 硬盘设备<br>/dev/null，黑洞设备，只进不出。类似于垃圾回收站<br>/dev/random，生成随机数的设备<br>/dev/zero，能远远不断的产生数据，类似于取款机，随时随地取钱</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"># 1 sda sdb sdc sda1 sdb4</span><br><span class="line">linux中磁盘文件叫sd，第一个硬盘叫a，第二个叫b，sda1表示第一个磁盘的第一个分区，sdb4：第二个硬盘的第四个分区（服务可以插很多硬盘）</span><br><span class="line"># 2 &#x2F;dev&#x2F;null </span><br><span class="line">ls &gt;&#x2F;dev&#x2F;null</span><br><span class="line"># 3 &#x2F;dev&#x2F;random 生成随机数</span><br><span class="line">echo $RANDOM</span><br><span class="line">echo lqz_$RANDOM</span><br><span class="line">批量创建随机用户，批量设置密码</span><br><span class="line"># 4 源源不断取数据</span><br><span class="line">dd if&#x3D;&#x2F;dev&#x2F;zero of&#x3D;&#x2F;opt&#x2F;test.txt bs&#x3D;1M count&#x3D;1024</span><br><span class="line">&#39;&#39;&#39;</span><br><span class="line">dd：用指定大小的块拷贝一个文件，并在拷贝的同时进行指定的转换。</span><br><span class="line">if&#x3D;文件名：输入文件名，缺省为标准输入。即指定源文件。&lt; if&#x3D;input file &gt;</span><br><span class="line">of&#x3D;文件名：输出文件名，缺省为标准输出。即指定目的文件。&lt; of&#x3D;output file &gt;</span><br><span class="line"> bs&#x3D;bytes：同时设置读入&#x2F;输出的块大小为bytes个字节。</span><br><span class="line"> count&#x3D;blocks：仅拷贝blocks个块，块大小等于ibs指定的字节数。</span><br><span class="line">&#39;&#39;&#39;</span><br><span class="line"></span><br><span class="line">ll &#x2F;opt&#x2F;test.txt</span><br><span class="line">ll -h &#x2F;opt&#x2F;test.txt</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ghu6uzedkyj30t60a2421.jpg" alt="img"></p><h3 id="8-虚拟的文件系统-如对应的进程停止则-proc下对应目录则会被删除"><a href="#8-虚拟的文件系统-如对应的进程停止则-proc下对应目录则会被删除" class="headerlink" title="8.虚拟的文件系统(如对应的进程停止则/proc下对应目录则会被删除)"></a>8.虚拟的文件系统(如对应的进程停止则/proc下对应目录则会被删除)</h3><p>/proc，反映系统当前进程的实时状态 :process<br>PS：类似于小汽车的仪表板，能够看到汽车是否有故障，或者是否缺油了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ls &#x2F;proc # 可以看到很多id号，pid号，进程号，唯一</span><br><span class="line">ls 进程id号的文件夹</span><br><span class="line">如果进程被关闭，id号的文件夹就没了</span><br><span class="line">id号每次启动都不唯一，只有一个进程唯一，systemd 是进程号1的进程，所有进程都是基于它派生出来的</span><br></pre></td></tr></table></figure><h3 id="9-其他"><a href="#9-其他" class="headerlink" title="9 其他"></a>9 其他</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">#1 media:提供设备的挂载点，媒体文件</span><br><span class="line"># linux 新增了盘符，需要手动挂载</span><br><span class="line"># 把光盘里的数据，挂载到media目录</span><br><span class="line">mount  &#x2F;dev&#x2F;cdrom &#x2F;media&#x2F;</span><br><span class="line"></span><br><span class="line"># 2 mnt：提供设备的挂载点（同上）</span><br><span class="line"></span><br><span class="line"># 3 opt：第三方工具，第三方软件默认安装的(mysql...)</span><br><span class="line"></span><br><span class="line"># run :下有pid，log结尾的文件</span><br><span class="line">ls &#x2F;run</span><br><span class="line">cat sshd.pid  # 进程运行的pid号,放在文件中</span><br><span class="line">ps aux |grep sshd</span><br><span class="line"></span><br><span class="line"># .lock文件的作用,锁机制</span><br><span class="line"># 假设现在执行</span><br><span class="line">yum install tree</span><br><span class="line"># 再开一个窗口执行相同命令</span><br><span class="line">yum install tree</span><br><span class="line">&#39;&#39;&#39;</span><br><span class="line">Another app is currently holding the yum lock; waiting for it to exit...</span><br><span class="line">  The other application is: yum</span><br><span class="line">    Memory :  71 M RSS (470 MB VSZ)</span><br><span class="line">    Started: Tue Aug 18 00:26:31 2020 - 00:24 ago</span><br><span class="line">    State  : Sleeping, pid: 6191</span><br><span class="line">&#39;&#39;&#39;</span><br><span class="line">cat &#x2F;run&#x2F;yum.pid</span><br></pre></td></tr></table></figure><h3 id="10-PS-在Linux7系统中"><a href="#10-PS-在Linux7系统中" class="headerlink" title="10.PS: 在Linux7系统中,"></a>10.PS: 在Linux7系统中,</h3><p>/bin, /sbin, /lib, /lib64都以软链接的形式链接到/usr/目录下</p><p>/bin –&gt; /usr/bin<br>/sbin –&gt; /usr/sbin<br>lib -&gt; usr/lib<br>lib64 -&gt; usr/lib64</p><h2 id="3-文件路径定位"><a href="#3-文件路径定位" class="headerlink" title="3.文件路径定位"></a>3.文件路径定位</h2><p>在我们开始操作文件前，首先需要对文件进行定位，比如:<br>你要在哪创建什么文件? 你要将文件复制到什么地方? 或者你要删除的文件在什么地方?<br>那什么是定位: 比如/etc/hostname，整个文件中包含文件名称以及文件所在的位置，我们将这个叫做路径，那么路径就是对文件进行定位的一种方式。例:如下图的message所在的路径是?<br><img src= "/img/loading.gif" data-src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ghu6v5mzj6j315u0h80v3.jpg" alt="img"><br>提问FQ: /home/oldboy/file 和/home/oldgirl/file是否是同一个文件?</p><h3 id="1-每个目录下都有一个-和-的目录是干啥的"><a href="#1-每个目录下都有一个-和-的目录是干啥的" class="headerlink" title="1.每个目录下都有一个.和..的目录是干啥的?"></a>1.每个目录下都有一个.和..的目录是干啥的?</h3><p>一个点代表当的是当前目录, 两个点代表的是当前目录的上层目录。<br>假设当前目录在<code>/usr/</code>下, 那么它的上层(/)目录用<code>../</code>表示, 而<code>/usr/</code>的下层(local)目录则用<code>./local</code>表示。</p><h3 id="2-那什么是绝对路径，什么又是相对路径呢"><a href="#2-那什么是绝对路径，什么又是相对路径呢" class="headerlink" title="2.那什么是绝对路径，什么又是相对路径呢?"></a>2.那什么是绝对路径，什么又是相对路径呢?</h3><p>绝对路径: 只要从/开始的路径，比如/home/alice/file<br>相对路径: 相对于当前目录来说，比如 a.txt ./a.txt ../bob/a.mp3 [加入: 此时在目录/home/alice]<br>小结: 所谓的(.)和(..)目录实际上属于相对路径的一种表示形式。</p><h3 id="3-绝对路径与相对路径示例"><a href="#3-绝对路径与相对路径示例" class="headerlink" title="3.绝对路径与相对路径示例"></a>3.绝对路径与相对路径示例</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#绝对路径</span><br><span class="line">[root@bgx &#x2F;]# useradd alice</span><br><span class="line">[root@bgx &#x2F;]# touch &#x2F;home&#x2F;alice&#x2F;file1</span><br><span class="line">[root@bgx &#x2F;]# touch ~&#x2F;file2</span><br><span class="line">[root@bgx &#x2F;]# touch ~alice&#x2F;file3</span><br><span class="line"></span><br><span class="line">#相对路径</span><br><span class="line">[root@bgx &#x2F;]# mkdir abc</span><br><span class="line">[root@bgx &#x2F;]# touch ..&#x2F;file3</span><br><span class="line">[root@bgx &#x2F;]# touch file4</span><br><span class="line">[root@bgx &#x2F;]# touch abc&#x2F;file5</span><br></pre></td></tr></table></figure><p>cd改变目录，常见的使用方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># cd 绝对路径 cd &#x2F;etc&#x2F;hostname</span><br><span class="line"># cd 相对路径 cd test&#x2F;abc cd . cd ..</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># cd      #切换目录，例: cd &#x2F;etc</span><br><span class="line"># cd -    #切换回上一次所在的目录</span><br><span class="line"># cd ~    #切换回当前用户的家目录,注意:root和普通用户是否有所不同吗？</span><br><span class="line"># cd .    #代表当前目录，一般在拷贝、移动等情况下使用 cp &#x2F;etc&#x2F;hostname .&#x2F;</span><br><span class="line"># cd ..   #切换回当前目录的上级目录</span><br></pre></td></tr></table></figure><h2 id="4-系统文件管理"><a href="#4-系统文件管理" class="headerlink" title="4.系统文件管理"></a>4.系统文件管理</h2><h3 id="1-文件管理之-创建-复制-移动-删除"><a href="#1-文件管理之-创建-复制-移动-删除" class="headerlink" title="1.文件管理之: 创建/复制/移动/删除"></a>1.文件管理之: 创建/复制/移动/删除</h3><p>创建</p><h4 id="1-文件创建命令touch"><a href="#1-文件创建命令touch" class="headerlink" title="1.文件创建命令touch"></a>1.文件创建命令touch</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># touch file                    #无则创建,有则修改时间</span><br><span class="line"># touch file2 file3</span><br><span class="line"># touch &#x2F;home&#x2F;od&#x2F;file4 file5</span><br><span class="line"># touch file&#123;a,b,c&#125;             #&#123;&#125;集合，等价 touch a b c</span><br><span class="line"># touch file&#123;1..10&#125;</span><br><span class="line"># touch file&#123;a..z&#125;</span><br></pre></td></tr></table></figure><h4 id="2-目录创建命令mkdir"><a href="#2-目录创建命令mkdir" class="headerlink" title="2.目录创建命令mkdir"></a>2.目录创建命令mkdir</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 选项：-v 显示详细信息  -p 递归创建目录</span><br><span class="line"># mkdir dir1</span><br><span class="line"># mkdir &#x2F;home&#x2F;od&#x2F;dir1 &#x2F;home&#x2F;od&#x2F;dir2</span><br><span class="line"># mkdir -v &#x2F;home&#x2F;od&#x2F;&#123;dir3,dir4&#125; </span><br><span class="line"># mkdir -pv &#x2F;home&#x2F;od&#x2F;dir5&#x2F;dir6</span><br><span class="line"># mkdir -pv &#x2F;home&#x2F;&#123;od&#x2F;&#123;diu,but&#125;,boy&#125;</span><br></pre></td></tr></table></figure><h4 id="3-以树状显示目录结构命令tree"><a href="#3-以树状显示目录结构命令tree" class="headerlink" title="3.以树状显示目录结构命令tree"></a>3.以树状显示目录结构命令tree</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># 选项: -L: 显示目录树的层级</span><br><span class="line"># tree &#x2F;home&#x2F;od&#x2F;    #显示当前目录下的结构</span><br><span class="line">&#x2F;home&#x2F;od&#x2F;</span><br><span class="line">├── but</span><br><span class="line">├── dir1</span><br><span class="line">├── dir2</span><br><span class="line">├── dir3</span><br><span class="line">├── dir4</span><br><span class="line">├── dir5</span><br><span class="line">│   └── dir6</span><br><span class="line">└── diu</span><br></pre></td></tr></table></figure><p>cp复制</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#选项： -v:详细显示命令执行的操作 -r: 递归处理目录与子目录 -p: 保留源文件或目录的属性</span><br><span class="line"></span><br><span class="line"># cp file &#x2F;tmp&#x2F;file_copy</span><br><span class="line"># cp name &#x2F;tmp&#x2F;name         #不修改名称</span><br><span class="line"># cp file &#x2F;tmp&#x2F;             #不修改名称</span><br><span class="line"># cp -p file &#x2F;tmp&#x2F;file_p    #-p保持原文件或目录的属性</span><br><span class="line"># cp -r  &#x2F;etc&#x2F; &#x2F;tmp&#x2F;        #复制目录需要使用-r参数, 递归复制</span><br><span class="line"># cp -rv &#x2F;etc&#x2F;hosts &#x2F;etc&#x2F;hostname &#x2F;tmp  #拷贝多个文件至一个目录</span><br><span class="line"># cp -rv &#x2F;etc&#x2F;&#123;hosts,hosts.bak&#125;</span><br><span class="line"># cp -rv &#x2F;etc&#x2F;hosts&#123;,-org&#125;</span><br></pre></td></tr></table></figure><p>mv移动</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># mv file file1             #原地移动算改名</span><br><span class="line"># mv file1 &#x2F;tmp&#x2F;            #移动文件至tmp目录</span><br><span class="line"># mv &#x2F;tmp&#x2F;file1 .&#x2F;          #移动tmp目录的文件至当前目录</span><br><span class="line"># mv dir&#x2F; &#x2F;tmp&#x2F;             #移动目录至&#x2F;tmp目录下</span><br><span class="line"></span><br><span class="line"># touch file&#123;1..3&#125;</span><br><span class="line"># mv file1 file2 file3 &#x2F;opt&#x2F;    #移动多个文件或至同一个目录</span><br><span class="line"></span><br><span class="line"># mkdir dir&#123;1..3&#125;</span><br><span class="line"># mv dir1&#x2F; dir2&#x2F; dir3&#x2F; &#x2F;opt     #移动多个目录至同一个目录</span><br></pre></td></tr></table></figure><p>rm删除</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">#选项：-r: 递归 -f: 强制删除 -v: 详细过程</span><br><span class="line"># rm  file.txt      #删除文件, 默认rm存在alias别名，rm -i所以会提醒是否删除文件</span><br><span class="line"># rm -f file.txt    #删除文件, 不提醒</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># rm -r dir&#x2F;        #递归删除目录，会提示</span><br><span class="line"># rm -rf dir&#x2F;       #强制删除目录,不提醒(慎用)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#1.rm删除示例</span><br><span class="line"># mkdir &#x2F;home&#x2F;dir10</span><br><span class="line"># touch &#x2F;home&#x2F;dir10&#x2F;&#123;file2,file3,.file4&#125;</span><br><span class="line"># rm -f &#x2F;home&#x2F;dir10&#x2F;  &#x2F;&#x2F;不包括隐藏文件 </span><br><span class="line"># ls &#x2F;home&#x2F;dir10&#x2F; -a</span><br><span class="line">. .. .file4</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#2.rm删除示例2</span><br><span class="line"># touch file&#123;1..10&#125;</span><br><span class="line"># touch &#123;1..10&#125;.pdf</span><br><span class="line"># rm -rf file </span><br><span class="line"># rm -rf .pdf</span><br></pre></td></tr></table></figure><h3 id="2-文件管理之：查看文件内容-cat-tac-less-more-head-tail-tailf-grep-…"><a href="#2-文件管理之：查看文件内容-cat-tac-less-more-head-tail-tailf-grep-…" class="headerlink" title="2.文件管理之：查看文件内容(cat tac less more head tail tailf grep …)"></a>2.文件管理之：查看文件内容(cat tac less more head tail tailf grep …)</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">#------cat</span><br><span class="line"># cp &#x2F;etc&#x2F;passwd .&#x2F;pass</span><br><span class="line"># cat pass      #正常查看文件方式</span><br><span class="line"># cat -n pass   #-n显示文件有多少行</span><br><span class="line"># cat -A pass   #查看文件的特殊符号,比如文件中存在tab键</span><br><span class="line"># tac pass      #倒序查看文件</span><br><span class="line">cat &gt;&gt; test2.txt &lt;&lt;EOF</span><br><span class="line">ads</span><br><span class="line">adf</span><br><span class="line">EOF</span><br><span class="line"></span><br><span class="line">#------less、more</span><br><span class="line"># less &#x2F;etc&#x2F;services    #使用光标上下翻动，空格进行翻页，q退出</span><br><span class="line"># more &#x2F;etc&#x2F;services    #使用回车上下翻动，空格进行翻页，q退出(有百分比)</span><br><span class="line"></span><br><span class="line">#------head</span><br><span class="line"># head pass     #查看头部内容，默认前十行</span><br><span class="line"># head -n5 pass #查看头部5行，使用-n指定</span><br><span class="line"># ps aux | head -5 # 只看头部5个进程</span><br><span class="line"></span><br><span class="line">#------tail</span><br><span class="line"># tail pass  # 查看文件尾部，默认10行</span><br><span class="line"># tail -20 &#x2F;var&#x2F;log&#x2F;secure  # 查看文件尾部20行</span><br><span class="line"># tail -f &#x2F;var&#x2F;log&#x2F;messages #-f动态查看文件尾部的变化</span><br><span class="line"># tailf &#x2F;var&#x2F;log&#x2F;messages   #查看文件尾部的变化</span><br><span class="line"># ps aux | tail -2</span><br><span class="line"></span><br><span class="line">#------grep过滤文件内容</span><br><span class="line"># grep &quot;^root&quot; pass     #匹配以root开头的行</span><br><span class="line"># grep &quot;bash$&quot; pass     #匹配以bash结尾的行</span><br><span class="line"># grep -i &quot;ftp&quot; pass    #忽略大小写匹配</span><br><span class="line"># grep  -Ei &quot;sync$|ftp&quot; pass    #匹配文件中包含sync结尾或ftp字符串</span><br><span class="line"># grep -n -A 2 &quot;Failed&quot; &#x2F;var&#x2F;log&#x2F;secure #匹配&#x2F;var&#x2F;log&#x2F;secure文件中Failed字符串,并打印它的下2行</span><br><span class="line"># grep -n -B 2 &quot;Failed&quot; &#x2F;var&#x2F;log&#x2F;secure #匹配&#x2F;var&#x2F;log&#x2F;secure文件中Failed字符串,并打印它的上2行</span><br><span class="line"># grep -n -C 2 &quot;Failed&quot; &#x2F;var&#x2F;log&#x2F;secure #匹配&#x2F;var&#x2F;log&#x2F;secure文件中Failed字符串,并打印它的上下2行</span><br></pre></td></tr></table></figure><h3 id="3-文件管理之：联网下载文件-wget、curl-、文件上传与下载-rz、sz"><a href="#3-文件管理之：联网下载文件-wget、curl-、文件上传与下载-rz、sz" class="headerlink" title="3.文件管理之：联网下载文件(wget、curl)、文件上传与下载(rz、sz)"></a>3.文件管理之：联网下载文件(wget、curl)、文件上传与下载(rz、sz)</h3><p>wget、curl联网下载文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#选项: -O: 指定下载地址</span><br><span class="line"># wget -O &#x2F;etc&#x2F;yum.repos.d&#x2F;CentOS-Base.repo http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;repo&#x2F;Centos-7.repo</span><br><span class="line"></span><br><span class="line">#选项: -o: 指定下载地址</span><br><span class="line"># curl -o &#x2F;etc&#x2F;yum.repos.d&#x2F;CentOS-Base.repo http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;repo&#x2F;Centos-7.repo</span><br></pre></td></tr></table></figure><p>rzsz上传下载文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># yum install lrzsz -y  #不安装软件则无法执行该命令</span><br><span class="line"></span><br><span class="line"># rz            #只能上传文件文件上传</span><br><span class="line"># sz &#x2F;path&#x2F;file #只能下载文件</span><br></pre></td></tr></table></figure><h3 id="4-文件管理之：文件或命令查找-locate、which、whereis、find"><a href="#4-文件管理之：文件或命令查找-locate、which、whereis、find" class="headerlink" title="4.文件管理之：文件或命令查找(locate、which、whereis、find)"></a>4.文件管理之：文件或命令查找(locate、which、whereis、find)</h3><p>文件查找</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># locate &#x2F;etc&#x2F;sh       #搜索etc目录下所有以sh开头的文件</span><br><span class="line"># locate -i &#x2F;etc&#x2F;sh    #搜索etc目录下，所有以sh开头的文件，忽略大小写</span><br></pre></td></tr></table></figure><p>命令查找</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># which ls  #查找ls命令的绝对路径</span><br><span class="line"></span><br><span class="line"># whereis ls       &#x2F;&#x2F;查找命令的路径、帮助手册、等</span><br><span class="line"># whereis -b ls    &#x2F;&#x2F;仅显示命令所在的路径</span><br><span class="line"></span><br><span class="line"># type -a ls        #查看命令的绝对路径(包括别名)</span><br></pre></td></tr></table></figure><h3 id="5-文件管理之：字符处理命令-sort、uniq、cut、sed、awk、wc、"><a href="#5-文件管理之：字符处理命令-sort、uniq、cut、sed、awk、wc、" class="headerlink" title="5.文件管理之：字符处理命令(sort、uniq、cut、sed、awk、wc、)"></a>5.文件管理之：字符处理命令(sort、uniq、cut、sed、awk、wc、)</h3><p>sort排序</p><p>在有些情况下，需要对应一个无序的文本文件进行数据的排序，这时就需要使用sort进行排序了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">sort [OPTION]... [FILE]...</span><br><span class="line"># -r：倒序 -n：按数字排序 -t：指定分隔符(默认空格) -k：指定第几列, 指定几列几字符（指定1,1  3.1,3.3）</span><br><span class="line"></span><br><span class="line">#1.首先创建一个文件，写入一写无序的内容</span><br><span class="line">[root@lqz ~]# cat &gt;&gt; file.txt &lt;&lt;EOF</span><br><span class="line">b:3</span><br><span class="line">c:2</span><br><span class="line">a:4</span><br><span class="line">e:5</span><br><span class="line">d:1</span><br><span class="line">f:11</span><br><span class="line">EOF</span><br><span class="line"></span><br><span class="line">#2.使用sort下面对输出的内容进行排序</span><br><span class="line">[root@lqz ~]# sort file.txt</span><br><span class="line">a:4</span><br><span class="line">b:3</span><br><span class="line">c:2</span><br><span class="line">d:1</span><br><span class="line">e:5</span><br><span class="line">f:11</span><br><span class="line"></span><br><span class="line">#结果并不是按照数字排序，而是按字母排序。</span><br><span class="line">#可以使用-t指定分隔符, 使用-k指定需要排序的列。</span><br><span class="line">[root@lqz ~]# sort -t &quot;:&quot; -k2 sort.txt</span><br><span class="line">d:1</span><br><span class="line">f:11 #第二行为什么是11？不应该按照顺序排列？</span><br><span class="line">c:2</span><br><span class="line">b:3</span><br><span class="line">a:4</span><br><span class="line">e:5</span><br><span class="line"></span><br><span class="line">#按照排序的方式, 只会看到第一个字符,11的第一个字符是1, 按照字符来排序确实比2小。 </span><br><span class="line">#如果想要按照数字的方式进行排序, 需要使用 -n参数。</span><br><span class="line">[root@lqz ~]# sort -t &quot;:&quot; -n -k2 p.txt</span><br><span class="line">d:1</span><br><span class="line">c:2</span><br><span class="line">b:3</span><br><span class="line">a:4</span><br><span class="line">e:5</span><br><span class="line">f:11</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#测试案例，下载文件http:&#x2F;&#x2F;fj.xuliangwei.com&#x2F;public&#x2F;ip.txt，对该文件进行排序</span><br><span class="line">[root@lqz ~]# sort -t. -k3.1,3.1nr -k4.1,4.3nr ip.txt</span><br></pre></td></tr></table></figure><p>uniq去重<br>如果文件中有多行完全相同的内容，当前是希望能删除重复的行，同时还可以统计出完全相同的行出现的总次数, 那么就可以使用<code>uniq</code>命令解决这个问题(但是必须配合<code>sort</code>使用)。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">uniq [OPTION]... [INPUT [OUTPUT]]</span><br><span class="line">#选项：-c  计算重复的行</span><br><span class="line"></span><br><span class="line">#1.创建一个file.txt文件:</span><br><span class="line">[root@lqz ~]# cat file.txt</span><br><span class="line">abc</span><br><span class="line">123</span><br><span class="line">abc</span><br><span class="line">123</span><br><span class="line">#2.uniq需要和sort一起使用, 先使用sort排序, 让重复内容连续在一起</span><br><span class="line">[root@lqz ~]# cat file.txt |sort</span><br><span class="line">123</span><br><span class="line">123</span><br><span class="line">abc</span><br><span class="line">abc</span><br><span class="line">#3.使用uniq去除相邻重复的行</span><br><span class="line">[root@lqz ~]# cat file.txt |sort|uniq</span><br><span class="line">123</span><br><span class="line">abc</span><br><span class="line">#4.-c参数能统计出文件中每行内容重复的次数</span><br><span class="line">[root@lqz ~]# cat file.txt |sort|uniq -c</span><br><span class="line">      2 123</span><br><span class="line">      2 abc</span><br></pre></td></tr></table></figure><p>cut截取字段</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">cut OPTION... [FILE]...</span><br><span class="line">#选项：-d 指定分隔符 -f 数字,取第几列 –f3,6三列和6列 -c 按字符取(空格也算)</span><br><span class="line">#echo &quot;Im xlw, is QQ 552408925&quot; &gt;file.txt   #过滤出文件里 xlw以及552408925</span><br><span class="line"></span><br><span class="line">#实现上述题目几种思路</span><br><span class="line"># cut -d &quot; &quot; -f2,5 file.txt</span><br><span class="line"># cut -d &quot; &quot; -f2,5 file.txt |sed &#39;s#,##g&#39;</span><br><span class="line"># sed &#39;s#,# #g&#39; file.txt | awk -F &quot; &quot; &#39;&#123;print $2 &quot; &quot; $5&#125;&#39;</span><br><span class="line"># awk  &#39;&#123;print $2,$5&#125;&#39; file.txt |awk -F &#39;,&#39; &#39;&#123;print $1,$2&#125;&#39;</span><br><span class="line"># awk -F  &quot;[, ]&quot; &#39;&#123;print $2,$6&#125;&#39; file.txt</span><br><span class="line"># awk -F &#39;[, ]+&#39; &#39;&#123;print $2,$5&#125;&#39; file.txt</span><br></pre></td></tr></table></figure><p>wc统计行号</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">wc [OPTION]... [FILE]...</span><br><span class="line">#选项：-l显示文件行数 -c显示文件字节 -w显示文件单词</span><br><span class="line"></span><br><span class="line"># wc -l &#x2F;etc&#x2F;fstab      #统计&#x2F;etc&#x2F;fstab文件有多少行</span><br><span class="line"># wc -l &#x2F;etc&#x2F;services   #统计&#x2F;etc&#x2F;services 文件行号</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#扩展方法</span><br><span class="line"># grep -n &quot;.&quot; &#x2F;etc&#x2F;services  | tail -1</span><br><span class="line"># awk &#39;&#123;print NR $0&#125;&#39; &#x2F;etc&#x2F;services | tail -1</span><br><span class="line"># cat -n &#x2F;etc&#x2F;services  | tail -1</span><br></pre></td></tr></table></figure><p>习题: 分析如下日志，统计每个域名被访问的次数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[root@student tmp]# cat web.log </span><br><span class="line">http:&#x2F;&#x2F;www.lqz.com&#x2F;index.html</span><br><span class="line">http:&#x2F;&#x2F;www.lqz.com&#x2F;1.html</span><br><span class="line">http:&#x2F;&#x2F;post.lqz.com&#x2F;index.html</span><br><span class="line">http:&#x2F;&#x2F;mp3.lqz.com&#x2F;index.html</span><br><span class="line">http:&#x2F;&#x2F;www.lqz.com&#x2F;3.html</span><br><span class="line">http:&#x2F;&#x2F;post.lqz.com&#x2F;2.html</span><br><span class="line"></span><br><span class="line"># awk -F &#39;&#x2F;&#39; &#39;&#123;print $3&#125;&#39; web.log|sort -rn|uniq –c</span><br><span class="line"># cut -d &#x2F; -f3 web.log|sort -rn|uniq –c</span><br></pre></td></tr></table></figure><p>习题: 使用awk取出系统的IP地址图解<br><img src= "/img/loading.gif" data-src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ghu6vfp9n4j30pm0br0vg.jpg" alt="img"></p><h2 id="5-系统文件属性"><a href="#5-系统文件属性" class="headerlink" title="5.系统文件属性"></a>5.系统文件属性</h2><p>当我们使用ls -l列目录下所有文件时，通常会以长格式的方式显示，其实长格式显示就是我们Windows下看到的文件详细信息，我们也将其称为文件属性，那整个文件的属性分为十列。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[root@lqz ~]# ls -l ks.cfg</span><br><span class="line">-rw-------. 1 root root 4434 May 30 13:58 ks.cfg</span><br><span class="line"></span><br><span class="line">#</span><br><span class="line">-rw-------. ①:第一个字符是文件类型，其他则是权限</span><br><span class="line">1           ②:硬链接次数</span><br><span class="line">root        ③:文件属于哪个用户</span><br><span class="line">root        ④:文件属于哪个组</span><br><span class="line">4434        ⑤:文件大小</span><br><span class="line">May30 13:58 ⑥⑦⑧:最新修改的时间与日期</span><br><span class="line">ks.cfg      ⑨:文件或目录名称</span><br></pre></td></tr></table></figure><h2 id="6-系统文件类型"><a href="#6-系统文件类型" class="headerlink" title="6.系统文件类型"></a>6.系统文件类型</h2><p>1.通常我们使用颜色或者后缀名称来区分文件类型，但很多时候不是很准确，所以我们可以通过ls -l以长格式显示一个文件的属性，通过第一列的第一个字符来近一步的判断文件具体的类型。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">[root@lqz ~]# ll -d &#x2F;etc&#x2F;hosts &#x2F;tmp &#x2F;bin&#x2F;ls  &#x2F;dev&#x2F;sda &#x2F;dev&#x2F;tty1 &#x2F;etc&#x2F;grub2.cfg &#x2F;dev&#x2F;log &#x2F;run&#x2F;dmeventd-client</span><br><span class="line">-rwxr-xr-x.  1 root root 117656 Jun 30  2016 &#x2F;bin&#x2F;ls</span><br><span class="line">srw-rw-rw-.  1 root root      0 Jan 20 10:35 &#x2F;dev&#x2F;log</span><br><span class="line">brw-rw----.  1 root disk   8, 0 Jan 20 10:36 &#x2F;dev&#x2F;sda</span><br><span class="line">crw--w----.  1 root tty    4, 1 Jan 20 10:36 &#x2F;dev&#x2F;tty1</span><br><span class="line">lrwxrwxrwx.  1 root root     22 Jan 13 11:31 &#x2F;etc&#x2F;grub2.cfg -&gt; ..&#x2F;boot&#x2F;grub2&#x2F;grub.cfg</span><br><span class="line">-rw-r--r--.  1 root root    199 Jan 20 11:03 &#x2F;etc&#x2F;hosts</span><br><span class="line">prw-------.  1 root root      0 Jan 20 10:36 &#x2F;run&#x2F;dmeventd-client</span><br><span class="line">drwxrwxrwt. 61 root root   8192 Jan 21 13:01 &#x2F;tmp</span><br><span class="line"></span><br><span class="line">#说明</span><br><span class="line">-   #普通文件(文本, 二进制, 压缩, 图片, 日志等) </span><br><span class="line">d   #目录文件</span><br><span class="line">b   #设备文件(块设备)存储设备硬盘 &#x2F;dev&#x2F;sda1, &#x2F;dev&#x2F;sda2</span><br><span class="line">c   #设备文件(字符设备)，终端 &#x2F;dev&#x2F;tty1, &#x2F;dev&#x2F;zero</span><br><span class="line">s   #套接字文件, 进程间通信(socket)</span><br><span class="line">p   #管道文件</span><br><span class="line">l   #链接文件</span><br></pre></td></tr></table></figure><p>2.但有些情况下，我们无法通过ls -l文件的类型，比如: 一个文件，它可能是普通文件、也可能是压缩文件、或者是命令文件等，那么此时就需要使用file来更加精准的判断这个文件的类型。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">[root@lqz ~]# file &#x2F;etc&#x2F;hosts</span><br><span class="line">&#x2F;etc&#x2F;hosts: ASCII text</span><br><span class="line"></span><br><span class="line">[root@lqz ~]# file &#x2F;bin&#x2F;ls</span><br><span class="line">&#x2F;bin&#x2F;ls: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked (uses shared libs), for GNU&#x2F;Linux 2.6.32, BuildID[sha1]&#x3D;aa7ff68f13de25936a098016243ce57c3c982e06, stripped</span><br><span class="line"></span><br><span class="line">[root@lqz ~]# file &#x2F;dev&#x2F;sda</span><br><span class="line">&#x2F;dev&#x2F;sda: block special</span><br><span class="line"></span><br><span class="line">[root@lqz ~]# file &#x2F;dev&#x2F;tty1</span><br><span class="line">&#x2F;dev&#x2F;tty1: character special</span><br><span class="line"></span><br><span class="line">[root@lqz ~]# file &#x2F;etc&#x2F;grub2.cfg</span><br><span class="line">&#x2F;etc&#x2F;grub2.cfg: broken symbolic link to &#96;..&#x2F;boot&#x2F;grub2&#x2F;grub.cfg&#39;</span><br><span class="line"></span><br><span class="line">[root@lqz ~]# file &#x2F;home</span><br><span class="line">&#x2F;home: directory</span><br><span class="line"></span><br><span class="line">[root@lqz ~]# file &#x2F;run&#x2F;dmeventd-client</span><br><span class="line">&#x2F;run&#x2F;dmeventd-client: fifo (named pipe)</span><br><span class="line"></span><br><span class="line">[root@lqz ~]# ll but</span><br><span class="line">-rw-r--r-- 1 root root 42125 Apr  1 12:26 but</span><br><span class="line">[root@lqz ~]# file but</span><br><span class="line">but: Zip archive data, at least v1.0 to extract</span><br></pre></td></tr></table></figure><p>PS: Linux文件扩展名不代表任何含义，仅为了我们能更好的识别该文件是什么类型。</p><h2 id="7-系统链接文件"><a href="#7-系统链接文件" class="headerlink" title="7.系统链接文件"></a>7.系统链接文件</h2><p>文件有文件名与数据，在Linux上被分成两个部分：用户数据 (user data) 与元数据 (metadata)。<br>用户数据，即文件数据块 (data block)，数据块是记录文件真实内容的地方，我们将其称为Block<br>元数据，即文件的附加属性，如文件大小、创建时间、所有者等信息。我们称其为Inode<br>在Linux中，inode是文件元数据的一部分但其并不包含文件名，inode号即索引节点号）<br>文件名仅是为了方便人们的记忆和使用，系统或程序通过 inode 号寻找正确的文件数据块。图1.展示了程序通过文件名获取文件内容的过程。<br><img src= "/img/loading.gif" data-src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ghu6vl9z4yj308w03c0so.jpg" alt="img"></p><p>Linux 系统引入了两种链接：硬链接 (hard link) 与软链接（又称符号链接，即 soft link 或 symbolic link）</p><h3 id="1-什么是软链接"><a href="#1-什么是软链接" class="headerlink" title="1.什么是软链接"></a>1.什么是软链接</h3><p>软链接相当于Windows的快捷方式，软链接文件会将inode指向源文件的block，当我们访问这个软链接文件时，其实访问的是源文件本身。那么当我们对一个文件创建多个软链接，其实就是多个inode指向同一个block。当我们删除软链接文件时，其实只是删除了一个inode指向，并不会对源文件源文件造成影响，但如果删除的是源文件则会造成所有软链接文件失效。</p><p><img src= "/img/loading.gif" data-src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ghu6vol7ggj30hu08cq3p.jpg" alt="img"></p><h3 id="2-什么是硬链接"><a href="#2-什么是硬链接" class="headerlink" title="2.什么是硬链接"></a>2.什么是硬链接</h3><p>若一个inode号对应多个文件名，则称这些文件为硬链接。换言之，硬链接就是同一个文件使用了多个别名，如下图hard link 就是 file 的一个别名，他们有共同的 inode。<br><img src= "/img/loading.gif" data-src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ghu6vsgq8ij30b80b80t8.jpg" alt="img"></p><h3 id="3-软链接实践"><a href="#3-软链接实践" class="headerlink" title="3.软链接实践"></a>3.软链接实践</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">#文件软链接示例</span><br><span class="line">touch &#x2F;root&#x2F;file</span><br><span class="line">ln -s &#x2F;root&#x2F;file &#x2F;tmp&#x2F;file_bak</span><br><span class="line">ll &#x2F;tmp&#x2F;file_bak  &#x2F;&#x2F;root下file链接到&#x2F;tmp下并重命名为file_bak</span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">#目录软链接示例</span><br><span class="line">mkdir &#x2F;soft&#x2F;nginx1.1 -p</span><br><span class="line">ln -s &#x2F;soft&#x2F;nginx1.1&#x2F; &#x2F;soft&#x2F;nginx</span><br><span class="line">ll &#x2F;soft&#x2F;nginx   &#x2F;&#x2F;查看链接指向</span><br><span class="line"></span><br><span class="line">#软链接使用场景</span><br><span class="line">1.软件升级</span><br><span class="line">2.企业代码发布 </span><br><span class="line">3.不方便目录移动</span><br></pre></td></tr></table></figure><h3 id="4-硬链接实践"><a href="#4-硬链接实践" class="headerlink" title="4.硬链接实践"></a>4.硬链接实践</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#文件硬链接示例</span><br><span class="line">ln  &#x2F;root&#x2F;file &#x2F;tmp&#x2F;file_hard</span><br><span class="line">ll &#x2F;tmp&#x2F;file_hard</span><br><span class="line"></span><br><span class="line">#PS：目录不能创建硬链接，硬链接文件可以用rm命令删除</span><br></pre></td></tr></table></figure><p>5.硬链接与软链接区别<br>1)ln命令创建硬链接，ln -s命令创建软链接。<br>2)目录不能创建硬链接，并且硬链接不可以跨越分区系统。<br>3)目录软链接特别常用,并且软链接支持跨越分区系统。<br>4)硬链接文件与源文件的inode相同，软链接文件与源文件inode不同。<br>5)删除软链接文件，对源文件及硬链接文件无任何影响。<br>6)删除文件的硬链接文件，对源文件及链接文件无任何影响。<br>7)删除链接文件的源文件，对硬链接无影响，会导致软链接失效。<br>8)删除源文件及其硬链接文件，整个文件会被真正的删除。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1-文件管理概述&quot;&gt;&lt;a href=&quot;#1-文件管理概述&quot; class=&quot;headerlink&quot; title=&quot;1.文件管理概述&quot;&gt;&lt;/a&gt;1.文件管理概述&lt;/h2&gt;&lt;h3 id=&quot;1-Bash-Shell对文件进行管理&quot;&gt;&lt;a href=&quot;#1-Bash-She
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>2-Linux——Shell</title>
    <link href="http://yoursite.com/2019/02/21/Linux%E2%80%94%E2%80%94shell/"/>
    <id>http://yoursite.com/2019/02/21/Linux%E2%80%94%E2%80%94shell/</id>
    <published>2019-02-21T13:23:20.000Z</published>
    <updated>2020-08-18T12:10:11.364Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-什么是Bash-shell-壳"><a href="#1-什么是Bash-shell-壳" class="headerlink" title="1.什么是Bash shell(壳)"></a>1.什么是Bash shell(壳)</h3><p>Bash Shell是一个命令解释器，它在操作系统的最外层，负责用户程序与内核进行交互操作的一种接口，将用户输入的命令翻译给操作系统，并将处理后的结果输出至屏幕。</p><p>通过xshell连接，就是打开了一个bash程序的窗口，不能点鼠标，只能输入命令</p><p>当我们使用远程连接工具连接linux服务，系统则会给打开一个默认的shell，我们可在这个界面执行命令、比如：获取系统当前时间，创建一个用户等等…</p><p><img src= "/img/loading.gif" data-src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ght13kpua0j30w80gq0vs.jpg" alt="image-20200816223737732"></p><h3 id="2-Bash-Shell能干什么"><a href="#2-Bash-Shell能干什么" class="headerlink" title="2.Bash Shell能干什么?"></a>2.Bash Shell能干什么?</h3><p>使用Shell实现对Linux系统的大部分管理，例如:<br>1.文件管理(文件创建，移动，复制，删除，编辑…)<br>2.权限管理(不同用户不通权限)<br>3.用户管理（创建，删除….）<br>4.磁盘管理（挂载）<br>5.网络管理<br>6.软件管理<br>.等等.</p><h3 id="3-平时我们如何使用Shell呢？"><a href="#3-平时我们如何使用Shell呢？" class="headerlink" title="3.平时我们如何使用Shell呢？"></a>3.平时我们如何使用Shell呢？</h3><p>输入命令 –&gt; 效率低 –&gt;适合少量的工作<br>Shell Script –&gt; 效率高–&gt;适合复杂重复性的工作<br>例如:创建100个用户，单纯输入命令需要执行100次，而Shell脚本只需要几行命令即可完成100个用户的创建</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">vim test.sh</span><br><span class="line">for i in &#123;1..100&#125;</span><br><span class="line">do</span><br><span class="line"> useradd test$i</span><br><span class="line"> echo &quot;create test$i&quot;</span><br><span class="line">done</span><br><span class="line"></span><br><span class="line">bash test.sh</span><br></pre></td></tr></table></figure><h3 id="4-Shell提示符"><a href="#4-Shell提示符" class="headerlink" title="4.Shell提示符"></a>4.Shell提示符</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"># $ &#x3D; 普通用户, # &#x3D; root用户(超级管理员)</span><br><span class="line">### [root@lqz ~]# </span><br><span class="line"># root:当前登录用户</span><br><span class="line"># @ ：没有意义</span><br><span class="line"># lqz：主机名称，如果很长会显示不全，通过hostname查看</span><br><span class="line"># ~：当前用户所在家目录</span><br><span class="line"># #：通常指超级管理员</span><br><span class="line"># $:普通用户</span><br><span class="line">[root@lqz ~]# whoami</span><br><span class="line">root</span><br><span class="line"></span><br><span class="line">[root@web01 ~]# useradd jack</span><br><span class="line">[root@web01 ~]# passwd jack</span><br><span class="line">Changing password for user jack.</span><br><span class="line">New password:</span><br><span class="line">BAD PASSWORD: The password is a palindrome</span><br><span class="line">Retype new password:</span><br><span class="line">passwd: all authentication tokens updated successfully.</span><br><span class="line">[root@web01 ~]# su jack</span><br><span class="line">[root@web01 ~]# cd root   提示没有权限</span><br></pre></td></tr></table></figure><h3 id="5-Shell基础语法"><a href="#5-Shell基础语法" class="headerlink" title="5.Shell基础语法"></a>5.Shell基础语法</h3><p>命令行bash shell， 为用户提供输入, 执行命令的界面</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">#命令  选项  参数</span><br><span class="line">command [-options] [arguments]</span><br><span class="line"></span><br><span class="line">[root@lqz ~]# ls             #命令</span><br><span class="line">[root@lqz ~]# ls -a          #命令+选项</span><br><span class="line">[root@lqz ~]# ls -a &#x2F;home&#x2F;   #命令+选项+参数</span><br><span class="line">ls -a -l</span><br><span class="line">ls -la</span><br><span class="line">ls --all</span><br><span class="line">ls --list</span><br><span class="line">ls -c</span><br><span class="line">ls --color</span><br><span class="line">ls -a &#x2F;tmp</span><br><span class="line">#命令: 整条shell命令的主体</span><br><span class="line">#选项: 用于调节命令的输出效果</span><br><span class="line">    #以 “-”引导短格式选项（单个字符），例如“-l”</span><br><span class="line">    #以“--”引导长格式选项（多个字符），例如“--color”</span><br><span class="line">    #多个短格式选项可以写在一起，只用一个“-”引导，例如“-al”</span><br><span class="line">#参数: 命令操作的对象，如文件、目录名等</span><br><span class="line"># 选项和参数可以出现位置调换，命令，选项，参数之间要至少有一个空格</span><br><span class="line"># 命令必须开头， 选项和参数位置可以发生变化</span><br></pre></td></tr></table></figure><h2 id="2-Bash-Shell基本特性"><a href="#2-Bash-Shell基本特性" class="headerlink" title="2.Bash Shell基本特性"></a>2.Bash Shell基本特性</h2><h3 id="1-命令补全"><a href="#1-命令补全" class="headerlink" title="1.命令补全"></a>1.命令补全</h3><p>当使用windows查找一个目录层级特别多的文件时，打开的效率会非常的慢，但如果使用linux查找一个目录层级特别多的文件时，可以通过tab键快速的补全</p><p>PS: tab键可以实现命令补全，路径补全，在实际生产中tab补全往往是我们使用的最多的, 因为可以减少执行命令以及路径出错率。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"># yum provides ifconfig</span><br><span class="line"># yum install net-tools</span><br><span class="line"></span><br><span class="line">#查看ip时忘记具体了命令</span><br><span class="line">[root@lqz ~]# ifcon</span><br><span class="line">#按下tab键会自动补全</span><br><span class="line">[root@lqz ~]# ifconfig</span><br><span class="line"></span><br><span class="line">#按一下tab键没有反应, 按两下tab键列出所有if开头的命令</span><br><span class="line">[root@lqz ~]# if</span><br><span class="line">if         ifconfig   ifenslave  ifrename</span><br><span class="line">ifcfg      ifdown     ifnames    ifup</span><br><span class="line"></span><br><span class="line">#linux目录较深，经常使用tab键进行补全, 如果路径出错是没有办法补全(带斜线表示是目录（window叫文件夹）)</span><br><span class="line">[root@lqz ~]# ls &#x2F;etc&#x2F;sysconfig&#x2F;network-scripts&#x2F;</span><br><span class="line"></span><br><span class="line"># 安装选项补全</span><br><span class="line">yum install bash-comple*</span><br><span class="line">yum install bash-completion </span><br><span class="line"># ls -- Tab建，空格上下翻</span><br></pre></td></tr></table></figure><h3 id="2-命令快捷键，快捷键可以帮助我们大大提升工作效率"><a href="#2-命令快捷键，快捷键可以帮助我们大大提升工作效率" class="headerlink" title="2.命令快捷键，快捷键可以帮助我们大大提升工作效率"></a>2.命令快捷键，快捷键可以帮助我们大大提升工作效率</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Ctrl + a    #光标跳转至正在输入的命令行的首部</span><br><span class="line">Ctrl + e    #光标跳转至正在输入的命令行的尾部</span><br><span class="line">Ctrl + c    #终止前台运行的程序</span><br><span class="line">Ctrl + d    #在shell中，ctrl-d表示推出当前shell。</span><br><span class="line">Ctrl + z    #将任务暂停，挂至后台</span><br><span class="line">Ctrl + l    #清屏，和clear命令等效。</span><br><span class="line">Ctrl + k    #删除从光标到行末的所有字符</span><br><span class="line">Ctrl + u    #删除从光标到行首的所有字符</span><br><span class="line">Ctrl + r    #搜索历史命令, 利用关键字，Tab建选中</span><br><span class="line">Ctrl + w    #按单词或空格进行向前删除</span><br><span class="line">Ctrl + 左右建 #按单词或空格进行向前向后跳</span><br><span class="line"></span><br><span class="line">#在命令行前加面加 &quot;#&quot; 则该命令不会被执行</span><br></pre></td></tr></table></figure><h3 id="3-历史命令History-追溯之前发生情况"><a href="#3-历史命令History-追溯之前发生情况" class="headerlink" title="3.历史命令History, 追溯之前发生情况"></a>3.历史命令History, 追溯之前发生情况</h3><p>-w 保存命令历史到历史文件<br>-c 清空命令历史记录, 不会情况文件<br>-d 删除命令历史的第 N 条行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">#1.使用双 !! 可执行上一条执行过的命令</span><br><span class="line">[root@lqz ~]# ls</span><br><span class="line">lqz.com</span><br><span class="line">[root@lqz ~]# !!</span><br><span class="line">ls</span><br><span class="line">lqz.com</span><br><span class="line"></span><br><span class="line">#2.输入!6, 执行history命令历史中第 6 行命令</span><br><span class="line">[root@lqz ~]# !6</span><br><span class="line">touch lqz.com</span><br><span class="line"></span><br><span class="line">#使用!cat, 调用history命令历史最近一次执行过的cat命令</span><br><span class="line">[root@lqz ~]# cat &#x2F;etc&#x2F;sysconfig&#x2F;network-scripts&#x2F;ifcfg-eth0</span><br><span class="line">[root@lqz ~]# !cat  # 最近一次</span><br><span class="line">cat &#x2F;etc&#x2F;sysconfig&#x2F;network-scripts&#x2F;ifcfg-eth0</span><br><span class="line"></span><br><span class="line">[root@lqz ~]# ls &#x2F;etc&#x2F;passwd</span><br><span class="line">#调用上一条命令的最后参数或选项, 按下ESC松开, 然后按下 &quot;.&quot;</span><br><span class="line">[root@lqz ~]# cat</span><br><span class="line">[root@lqz ~]# cat &#x2F;etc&#x2F;passwd</span><br><span class="line">#第二种方式, 输入!$</span><br><span class="line">[root@lqz ~]# ls !$</span><br><span class="line">ls &#x2F;etc&#x2F;passwd</span><br><span class="line">&#x2F;etc&#x2F;passwd</span><br><span class="line"></span><br><span class="line"># history -d 100  删除第100条历史记录</span><br><span class="line"># history -c      清空记录(保存到文件中的还有)</span><br><span class="line"># history -w      保存历史集合，保存到当前用户的家目录 .bash_history</span><br><span class="line"># &gt; .bash_history  清空文件的保存（操作完，不让别人看你执行的命令）</span><br></pre></td></tr></table></figure><h3 id="3-命令别名"><a href="#3-命令别名" class="headerlink" title="3.命令别名"></a>3.命令别名</h3><p>命令别名将用户经常使用的复杂命令简单化, 可以用<code>&quot;alias 别名名称=命令&quot;</code>命令创建属于自己的命令别名, 若要取消一个命令别名，则是用<code>unalias 别名名称</code>命令。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">#1.定义临时别名, wk为查看eth0网卡别名</span><br><span class="line">[root@lqz ~]# alias wk&#x3D;&#39;ifconfig&#39;</span><br><span class="line"># alias 查看一下是否成功，发现系统内置了很多</span><br><span class="line">[root@lqz ~]# wk</span><br><span class="line"># 取消别名（都是临时的）</span><br><span class="line">[root@lqz ~]# unalias wk </span><br><span class="line"></span><br><span class="line">#2.如果定义命令本身, 会执行什么?</span><br><span class="line">[root@lqz ~]# alias ifconfig&#x3D;&#39;ifconfig eth0&#39;</span><br><span class="line">#绝对路径执行, 调用命令本身</span><br><span class="line">[root@lqz ~]# &#x2F;sbin&#x2F;ifconfig</span><br><span class="line">#通过转义字符, 调用命令本身</span><br><span class="line">[root@WebServer ~]# ifconfig</span><br><span class="line"></span><br><span class="line">#3.取消别名</span><br><span class="line">[root@lqz ~]# unalias ifconfig</span><br><span class="line"></span><br><span class="line">#4.永久生效，&#x2F;etc&#x2F;bashrc</span><br><span class="line">[root@lqz ~]# echo &quot;alias ifconfig&#x3D;&#39;ifconfig eth0&#39;&quot; &gt;&gt; &#x2F;etc&#x2F;bashrc</span><br></pre></td></tr></table></figure><h2 id="3-Bash-Shell获取帮助"><a href="#3-Bash-Shell获取帮助" class="headerlink" title="3.Bash Shell获取帮助"></a>3.Bash Shell获取帮助</h2><h3 id="1-命令-–help帮助"><a href="#1-命令-–help帮助" class="headerlink" title="1.命令 –help帮助"></a>1.命令 –help帮助</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">[root@lqz ~]# ls --help</span><br><span class="line">用法: ls [选项]...[文件]...</span><br><span class="line"></span><br><span class="line">#ls 常见选项</span><br><span class="line">-a  #查看目录下的所有文件，包括隐藏文件</span><br><span class="line">-l  #以长格式的方式显示文件的详细内容</span><br><span class="line">-h  #以人性化的方式显示内容，配合-l使用</span><br><span class="line">-d  #只列出目录名，不列出目录以下的内容</span><br><span class="line">-t  #按修改时间进行排序</span><br><span class="line">-i  #显示文件的inode(该文件在该分区的一个编号)</span><br><span class="line"></span><br><span class="line">[root@lqz ~]# date --help</span><br><span class="line">Usage: date [OPTION]... [+FORMAT]</span><br><span class="line">  or:  date [-u|--utc|--universal] [MMDDhhmm[[CC]YY][.ss]]</span><br><span class="line">  </span><br><span class="line">[root@lqz ~]# date +%F   #查看日期</span><br><span class="line">2019-03-28</span><br><span class="line">[root@lqz ~]# date -s 12:00  #修改时间</span><br><span class="line"></span><br><span class="line">#时间不是用来查看，而是有其他的用途</span><br><span class="line">[root@web01 ~]# touch &#96;date +%F&#96;_file.txt</span><br><span class="line">[root@web01 ~]# ls</span><br><span class="line">2019-03-28_file.txt</span><br></pre></td></tr></table></figure><h3 id="2-命令-man手册"><a href="#2-命令-man手册" class="headerlink" title="2.命令 man手册"></a>2.命令 man手册</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># man ls    #查看ls命令的手册</span><br></pre></td></tr></table></figure><p>3.linux命令大全url传送门<br><a href="http://man.linuxde.net/" target="_blank" rel="noopener">linux命令大全</a><br><a href="http://linux.51yip.com/" target="_blank" rel="noopener">linux命令手册</a></p><h2 id="4-Bash-Shell命令流程"><a href="#4-Bash-Shell命令流程" class="headerlink" title="4.Bash Shell命令流程"></a>4.Bash Shell命令流程</h2><h3 id="1-当我们执行一个命令-整个命令执行流程如下"><a href="#1-当我们执行一个命令-整个命令执行流程如下" class="headerlink" title="1.当我们执行一个命令, 整个命令执行流程如下:"></a>1.当我们执行一个命令, 整个命令执行流程如下:</h3><p>1) 判断命令是否通过绝对路径执行<br>2) 判断命令是否存在alias别名<br>3) 判断用户输入的是内部命令还是外部命令<br>4) Bash内部命令直接执行，外部命令检测是否存在缓存<br>5) 通过PATH路径查找命令，有执行，无报错</p><h3 id="2-什么是内部命令，什么是外部命令"><a href="#2-什么是内部命令，什么是外部命令" class="headerlink" title="2.什么是内部命令，什么是外部命令"></a>2.什么是内部命令，什么是外部命令</h3><p>内部命令: shell程序自带的命令。<br>外部命令: 在系统PATH变量的某个路径下的可执行程序。</p><h3 id="3-如何检查用户输入的命令是内部命令还是外部命令"><a href="#3-如何检查用户输入的命令是内部命令还是外部命令" class="headerlink" title="3.如何检查用户输入的命令是内部命令还是外部命令"></a>3.如何检查用户输入的命令是内部命令还是外部命令</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#cd命令属于shell内部命令</span><br><span class="line">[root@linux-node1 ~]# type -a cd</span><br><span class="line">cd is a shell builtin</span><br><span class="line">cd is &#x2F;usr&#x2F;bin&#x2F;cd</span><br><span class="line"></span><br><span class="line">#ping属于外部命令, 同时会打印当前命令路径</span><br><span class="line">[root@lqz ~]# type -a  ping</span><br><span class="line">ping is &#x2F;bin&#x2F;ping</span><br></pre></td></tr></table></figure><h3 id="4-如果是外置命令，Bash可以通过查找PATH变量，获取该命令的绝对路径。"><a href="#4-如果是外置命令，Bash可以通过查找PATH变量，获取该命令的绝对路径。" class="headerlink" title="4.如果是外置命令，Bash可以通过查找PATH变量，获取该命令的绝对路径。"></a>4.如果是外置命令，Bash可以通过查找PATH变量，获取该命令的绝对路径。</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#打印当前环境变量目录</span><br><span class="line">[root@lqz ~]# echo $PATH</span><br><span class="line">&#x2F;usr&#x2F;local&#x2F;sbin:&#x2F;usr&#x2F;local&#x2F;bin:&#x2F;sbin:&#x2F;bin:&#x2F;usr&#x2F;sbin:&#x2F;usr&#x2F;bin:&#x2F;root&#x2F;bin</span><br></pre></td></tr></table></figure><p>PS: PATH由多个路径组成，每个路径值之间用冒号间隔，对这些路径的增加和删除操作都将影响到Bash解释器对Linux命令的查找</p><h3 id="5-如果是外置命令还会涉及到一个内存缓存，也就是说，当我们出现重复执行相同的命令，会通过缓存调取执行，也就意味着不会搜索PATH路径。"><a href="#5-如果是外置命令还会涉及到一个内存缓存，也就是说，当我们出现重复执行相同的命令，会通过缓存调取执行，也就意味着不会搜索PATH路径。" class="headerlink" title="5.如果是外置命令还会涉及到一个内存缓存，也就是说，当我们出现重复执行相同的命令，会通过缓存调取执行，也就意味着不会搜索PATH路径。"></a>5.如果是外置命令还会涉及到一个内存缓存，也就是说，当我们出现重复执行相同的命令，会通过缓存调取执行，也就意味着不会搜索PATH路径。</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">#表缓存命令所在位置</span><br><span class="line">[root@lqz ~]# hash</span><br><span class="line">hits    command</span><br><span class="line">   1    &#x2F;usr&#x2F;bin&#x2F;tty</span><br><span class="line">   3    &#x2F;sbin&#x2F;ifconfig</span><br><span class="line"></span><br><span class="line">#已缓存命令,如果移动位置会导致无法找到该命令</span><br><span class="line">[root@lqz ~]# mv &#x2F;sbin&#x2F;ifconfig &#x2F;bin&#x2F;</span><br><span class="line">[root@lqz ~]# ifconfig</span><br><span class="line">-bash: &#x2F;sbin&#x2F;ifconfig: No such file or directory</span><br><span class="line"></span><br><span class="line">#删除缓存过的ifconfig命令, 即可执行</span><br><span class="line">[root@lqz ~]# hash -d ifconfig</span><br><span class="line">[root@lqz ~]# ifconfig</span><br><span class="line"></span><br><span class="line">#当然可以清空缓存表</span><br><span class="line">[root@lqz ~]# hash -r</span><br><span class="line"></span><br><span class="line">#注意: 命令缓存hash需要注意如下情况:</span><br><span class="line">1.只要执行外部命令1次就会对该命令进行缓存</span><br><span class="line">2.如果将命令移动了位置，该如何执行</span><br><span class="line">    a.使用绝对路径执行</span><br><span class="line">    b.删除hash表的缓存指令</span><br></pre></td></tr></table></figure><h3 id="6-命令执行流程总结-当我们执行了一个ping命令之后-整个命令执行的流程步骤如下"><a href="#6-命令执行流程总结-当我们执行了一个ping命令之后-整个命令执行的流程步骤如下" class="headerlink" title="6.命令执行流程总结: 当我们执行了一个ping命令之后, 整个命令执行的流程步骤如下:"></a>6.命令执行流程总结: 当我们执行了一个<code>ping</code>命令之后, 整个命令执行的流程步骤如下:</h3><p>1) 检查执行的命令是否使用的是绝对路径执行的。<br>2) 检查ping命令是否存在alias别名<br>3) 检查ping命令是内部命令还是外部命令<br>4) 如果是内部命令Bash直接执行，如果是外部命令，首先检查Hash缓存，存在则直接调取<br>5) 如果该命令不存在Hash缓存，则通过PATH路径进行逐行查找该命令所在的位置<br>6) 如果PATH路径没有查找到该命令所在的路径，则返回错误码。command not found</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-什么是Bash-shell-壳&quot;&gt;&lt;a href=&quot;#1-什么是Bash-shell-壳&quot; class=&quot;headerlink&quot; title=&quot;1.什么是Bash shell(壳)&quot;&gt;&lt;/a&gt;1.什么是Bash shell(壳)&lt;/h3&gt;&lt;p&gt;Bash She
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>1-Linux的发展史</title>
    <link href="http://yoursite.com/2019/02/20/Linux%E2%80%94%E2%80%94%E5%8F%91%E5%B1%95%E5%8F%B2/"/>
    <id>http://yoursite.com/2019/02/20/Linux%E2%80%94%E2%80%94%E5%8F%91%E5%B1%95%E5%8F%B2/</id>
    <published>2019-02-20T12:53:28.000Z</published>
    <updated>2020-08-18T12:09:29.202Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是Linux"><a href="#什么是Linux" class="headerlink" title="什么是Linux"></a>什么是Linux</h2><p><em>Linux:和我们常见的Windows一样，都是操作系统，但不同的是:<br>Windows: 收费，不开源，主要用于日常办公、游戏、娱乐多一些。<br>Linux: 免费，开源，主要用于服务器领域，性能稳定，安全。<br>例如:淘宝、百度、腾讯等互联网公司，他们使用的服务器全都是 Linux 系统。</em></p><h2 id="一-Linux前身"><a href="#一-Linux前身" class="headerlink" title="一 Linux前身"></a>一 Linux前身</h2><p>1968年 Multics项目</p><p><strong>MIT**</strong>、Bell<strong><em>\</em>实验室、美国通用电气有限公司</strong>走到了一起，致力于开发Multics项目。到后期由于开发进度不是很好，MIT和Bell实验室相继离开这个项目的开发，最终导致项目搁浅。</p><p><strong>1970**</strong>年（Unix<strong><em>\</em>元年，时间戳）</strong> Unix诞生</p><p>当时在开发Multics项目的时候，实验室中有一个开发成员开发了一款游戏（travel space：遨游太空），因为两个实验室相继离开项目开发，导致这名开发人员没法玩游戏，后来他提议组织人员重新在Multics项目之上重新的开发，也就出现了1970年的Unix。当时Unix操作系统是使用的<strong>汇编语言（机器语言）</strong>开发的。</p><p>1973年 用<strong>C**</strong>语言**重写Unix</p><p>因为汇编语言有一个最大的局限性：对于计算机硬件过于依赖。导致移植性不好，所以后期在1973年使用了C语言对其进行重新开发。</p><p>1975年 Bell实验室允许大学使用Unix。</p><p>1975年，bell实验室允许大学使用Unix操作系统用于教学作用，而不允许用于商业用途。</p><h2 id="二-Linux诞生"><a href="#二-Linux诞生" class="headerlink" title="二 Linux诞生"></a>二 Linux诞生</h2><p>人物 Linus</p><p><img src= "/img/loading.gif" data-src="https://tva1.sinaimg.cn/large/00831rSTly1gdk2y1v2c9j30ia0mi7vw.jpg" alt="image-20200406153007420"></p><p>Linux的开发作者，Linux之父，李纳斯·托瓦兹。Linux诞生时是荷兰在校大学生。</p><p>1991年 0.0.1版本</p><p>李纳斯当时学校使用的就是Unix操作系统，然后其对系统的底层代码进行了修改，放到了学校为学生开放的网站上，原先他把文件命名写成了Linus’s Unix，后期网络管理发现之后觉得这个名字不好，自己手动的将名字改成Linux。随后其他同学下载之后发现这个版本还是挺好用的，随后都把自己代码贡献给李纳斯。</p><p>1992年 0.0.2版本</p><p>1994年 1.0版本</p><p>2003年 2.6版本</p><p><strong>上述所提及的版本号并不是分支版本，而是指Linux**</strong>的内核版本。</p><p><a href="https://www.kernel.org/" target="_blank" rel="noopener">Linux内核网站</a>（现在3.x多一些，原来2.x多，现在docker要跑在3上）<br><a href="https://www.doit.com.cn/p/278606.html" target="_blank" rel="noopener">linux大神在2017-06-26来到中国</a></p><h2 id="三-开源文化"><a href="#三-开源文化" class="headerlink" title="三 开源文化"></a>三 开源文化</h2><p>Linux是<strong>开源</strong>的操作系统。所谓开源就是指开放源代码。</p><p><em>自由软件之父 Richard M. Stallman 1984 GNU组织 copyleft opensource free GPL</em></p><p>理查德·马修·斯托曼（Richard Matthew Stallman, RMS），于1953年出生，自由软件运动的精神领袖、GNU计划以及自由软件基金会（Free Software Foundation）的创立者、著名黑客</p><p>copyleft: 代表无版权。copyright: 则代表有版权。<br>opensource free: 源代码开放、软件谁都可以使用、谁都可以传播、谁都可以二次开发，使用GPL协议保护<br>GPL: 通用版权许可证协议，如果软件被打上GPL，那么任何人都可以对这个软件进行修改，但是修改完之后必须将源码发布出来，以便更好的传承下去。(那Linux中的软件百分之80都是GPL提供)*</p><p>Linux内核使用GPL协议发布，内核也是开源，有了内核的加入，整个GNU的系统更加的完善。其实Linux完整叫法应该叫GNU/Linux，GNU的软件加上Linux内核。</p><p><img src= "/img/loading.gif" data-src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ght0idita4j30qe0hi197.jpg" alt="image-20200816221714662"></p><p><strong>1983**</strong>年 GNU<strong><em>\</em>计划</strong></p><p>1985年 FSF基金会</p><p>1990年 Emacs、<strong>GCC</strong>（c语言的编译器）、程序库</p><p>1991年 Stallman去找Linus，商谈让Linux加入其开源计划（GNU计划）</p><p>1992年 GNU/Linux</p><h2 id="四-Linux系统特点"><a href="#四-Linux系统特点" class="headerlink" title="四 Linux系统特点"></a>四 Linux系统特点</h2><p>开放性（开源）、多用户、多任务、良好的用户界面、优异的性能与稳定性</p><p>多用户多任务：</p><p>单用户：一个用户，在登录计算机（操作系统），只能允许<strong>同时</strong>登录一个用户；</p><p>单任务：一个任务，允许用户<strong>同时</strong>进行的操作任务数量；</p><p>多用户：多个用户，在登录计算机（操作系统），允许<strong>同时</strong>登录多个用户进行操作；</p><p>多任务：多个任务，允许用户<strong>同时</strong>进行多个操作任务；</p><p><strong>Windows**</strong>属于：单用户、多任务。**</p><p><strong>Linux**</strong>属于：多用户、多任务。**</p><h2 id="五-Linux分支"><a href="#五-Linux分支" class="headerlink" title="五 Linux分支"></a>五 Linux分支</h2><p>我们现在说的Linux其实都是指的是发行版(Distribution version)，就是使用Linux内核加上各种GNU的库文件、应用程序，构造而成的操作系统。Linux发行版介绍RHEL/Centos/Ubuntu/Suse<br>Redhat 1993年，将Linux的内核进行编译安装相应软件进行发行。<br>CentOS 社区企业级操作系统, 改与Redhat, 完全开源。<br>Ubuntu 社区维护， 现在主要做手机系统和电脑桌面系统。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;什么是Linux&quot;&gt;&lt;a href=&quot;#什么是Linux&quot; class=&quot;headerlink&quot; title=&quot;什么是Linux&quot;&gt;&lt;/a&gt;什么是Linux&lt;/h2&gt;&lt;p&gt;&lt;em&gt;Linux:和我们常见的Windows一样，都是操作系统，但不同的是:&lt;br&gt;Win
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>10-drf-Xadmin的使用</title>
    <link href="http://yoursite.com/2018/06/10/10-drf-Xadmin%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <id>http://yoursite.com/2018/06/10/10-drf-Xadmin%E7%9A%84%E4%BD%BF%E7%94%A8/</id>
    <published>2018-06-10T11:54:55.000Z</published>
    <updated>2020-07-14T00:39:54.307Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一-Xadmin的使用"><a href="#一-Xadmin的使用" class="headerlink" title="一 Xadmin的使用"></a>一 Xadmin的使用</h1><p>xadmin是Django的第三方扩展，可是使Django的admin站点使用更方便。</p><p>文档：<a href="https://xadmin.readthedocs.io/en/latest/index.html" target="_blank" rel="noopener">https://xadmin.readthedocs.io/en/latest/index.html</a></p><h2 id="1-1-安装"><a href="#1-1-安装" class="headerlink" title="1.1 安装"></a>1.1 安装</h2><p>通过如下命令安装xadmin的最新版</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install https://codeload.github.com/sshwsfc/xadmin/zip/django2</span><br></pre></td></tr></table></figure><p>在配置文件中注册如下应用</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">BASE_DIR = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))</span><br><span class="line"><span class="comment"># 把apps目录设置环境变量中的导包路径</span></span><br><span class="line">sys.path.append( os.path.join(BASE_DIR,<span class="string">"luffy/apps"</span>) )</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">INSTALLED_APPS = [</span><br><span class="line">    ...</span><br><span class="line">    <span class="string">'xadmin'</span>,</span><br><span class="line">    <span class="string">'crispy_forms'</span>,</span><br><span class="line">    <span class="string">'reversion'</span>,</span><br><span class="line">    ...</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改使用中文界面</span></span><br><span class="line">LANGUAGE_CODE = <span class="string">'zh-Hans'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改时区</span></span><br><span class="line">TIME_ZONE = <span class="string">'Asia/Shanghai'</span></span><br></pre></td></tr></table></figure><p>xadmin有建立自己的数据库模型类，需要进行数据库迁移</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">python manage.py makemigrations</span><br><span class="line">python manage.py migrate</span><br></pre></td></tr></table></figure><p>在总路由中添加xadmin的路由信息</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> xadmin</span><br><span class="line">xadmin.autodiscover()</span><br><span class="line"></span><br><span class="line"><span class="comment"># version模块自动注册需要版本控制的 Model</span></span><br><span class="line"><span class="keyword">from</span> xadmin.plugins <span class="keyword">import</span> xversion</span><br><span class="line">xversion.register_models()</span><br><span class="line"></span><br><span class="line">urlpatterns = [</span><br><span class="line">    path(<span class="string">r'xadmin/'</span>, xadmin.site.urls)</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>创建超级用户</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python manage.py createsuperuser</span><br></pre></td></tr></table></figure><h2 id="1-2-使用"><a href="#1-2-使用" class="headerlink" title="1.2 使用"></a>1.2 使用</h2><ul><li>xadmin不再使用Django的admin.py，而是需要编写代码在adminx.py文件中。</li><li>xadmin的站点管理类不用继承<code>admin.ModelAdmin</code>，而是直接继承<code>object</code>即可。</li></ul><p>例如：在子应用中创建adminx.py文件。</p><h3 id="1-2-1-站点的全局配置"><a href="#1-2-1-站点的全局配置" class="headerlink" title="1.2.1 站点的全局配置"></a>1.2.1 站点的全局配置</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> xadmin</span><br><span class="line"><span class="keyword">from</span> xadmin <span class="keyword">import</span> views</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BaseSetting</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="string">"""xadmin的基本配置"""</span></span><br><span class="line">    enable_themes = <span class="literal">True</span>  <span class="comment"># 开启主题切换功能</span></span><br><span class="line">    use_bootswatch = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">xadmin.site.register(views.BaseAdminView, BaseSetting)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GlobalSettings</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="string">"""xadmin的全局配置"""</span></span><br><span class="line">    site_title = <span class="string">"路飞学城"</span>  <span class="comment"># 设置站点标题</span></span><br><span class="line">    site_footer = <span class="string">"路飞学城有限公司"</span>  <span class="comment"># 设置站点的页脚</span></span><br><span class="line">    menu_style = <span class="string">"accordion"</span>  <span class="comment"># 设置菜单折叠</span></span><br><span class="line"></span><br><span class="line">xadmin.site.register(views.CommAdminView, GlobalSettings)</span><br></pre></td></tr></table></figure><h3 id="1-2-2-站点Model管理"><a href="#1-2-2-站点Model管理" class="headerlink" title="1.2.2 站点Model管理"></a>1.2.2 站点Model管理</h3><p>xadmin可以使用的页面样式控制基本与Django原生的admin一直。</p><ul><li><p><strong>list_display</strong> 控制列表展示的字段</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">list_display &#x3D; [&#39;id&#39;, &#39;btitle&#39;, &#39;bread&#39;, &#39;bcomment&#39;]</span><br></pre></td></tr></table></figure></li><li><p><strong>search_fields</strong> 控制可以通过搜索框搜索的字段名称，xadmin使用的是模糊查询</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">search_fields &#x3D; [&#39;id&#39;,&#39;btitle&#39;]</span><br></pre></td></tr></table></figure></li><li><p><strong>list_filter</strong> 可以进行过滤操作的列，对于分类、性别、状态</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">list_filter &#x3D; [&#39;is_delete&#39;]</span><br></pre></td></tr></table></figure></li><li><p><strong>ordering</strong> 默认排序的字段</p></li><li><p><strong>readonly_fields</strong> 在编辑页面的只读字段</p></li><li><p><strong>exclude</strong> 在编辑页面隐藏的字段</p></li><li><p><strong>list_editable</strong> 在列表页可以快速直接编辑的字段</p></li><li><p><strong>show_detail_fields</strong> 在列表页提供快速显示详情信息</p></li><li><p><strong>refresh_times</strong> 指定列表页的定时刷新</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">refresh_times &#x3D; [5, 10,30,60]  # 设置允许后端管理人员按多长时间(秒)刷新页面</span><br></pre></td></tr></table></figure></li><li><p><strong>list_export</strong> 控制列表页导出数据的可选格式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">list_export &#x3D; (&#39;xls&#39;, &#39;xml&#39;, &#39;json&#39;)   list_export设置为None来禁用数据导出功能</span><br><span class="line">list_export_fields &#x3D; (&#39;id&#39;, &#39;btitle&#39;, &#39;bpub_date&#39;)</span><br></pre></td></tr></table></figure></li><li><p><strong>show_bookmarks</strong> 控制是否显示书签功能</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show_bookmarks &#x3D; True</span><br></pre></td></tr></table></figure></li><li><p><strong>data_charts</strong> 控制显示图表的样式</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">data_charts = &#123;</span><br><span class="line">        <span class="string">"order_amount"</span>: &#123;</span><br><span class="line">          <span class="string">'title'</span>: <span class="string">'图书发布日期表'</span>, </span><br><span class="line">          <span class="string">"x-field"</span>: <span class="string">"bpub_date"</span>, </span><br><span class="line">          <span class="string">"y-field"</span>: (<span class="string">'btitle'</span>,),</span><br><span class="line">          <span class="string">"order"</span>: (<span class="string">'id'</span>,)</span><br><span class="line">        &#125;,</span><br><span class="line">    <span class="comment">#    支持生成多个不同的图表</span></span><br><span class="line">    <span class="comment">#    "order_amount": &#123;</span></span><br><span class="line">    <span class="comment">#      'title': '图书发布日期表', </span></span><br><span class="line">    <span class="comment">#      "x-field": "bpub_date", </span></span><br><span class="line">    <span class="comment">#      "y-field": ('btitle',),</span></span><br><span class="line">    <span class="comment">#      "order": ('id',)</span></span><br><span class="line">    <span class="comment">#    &#125;,</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ul><li>title 控制图标名称</li><li>x-field 控制x轴字段</li><li>y-field 控制y轴字段，可以是多个值</li><li>order 控制默认排序</li></ul></li><li><p><strong>model_icon</strong> 控制菜单的图标</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">class BookInfoAdmin(object):</span><br><span class="line">    model_icon &#x3D; &#39;fa fa-gift&#39;</span><br><span class="line"></span><br><span class="line">xadmin.site.register(models.BookInfo, BookInfodmin)</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;一-Xadmin的使用&quot;&gt;&lt;a href=&quot;#一-Xadmin的使用&quot; class=&quot;headerlink&quot; title=&quot;一 Xadmin的使用&quot;&gt;&lt;/a&gt;一 Xadmin的使用&lt;/h1&gt;&lt;p&gt;xadmin是Django的第三方扩展，可是使Django的admi
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>9-drf-JWT认证</title>
    <link href="http://yoursite.com/2018/05/30/9-drf-JWT%E8%AE%A4%E8%AF%81/"/>
    <id>http://yoursite.com/2018/05/30/9-drf-JWT%E8%AE%A4%E8%AF%81/</id>
    <published>2018-05-30T09:53:28.000Z</published>
    <updated>2020-07-14T00:39:54.310Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一-JWT认证"><a href="#一-JWT认证" class="headerlink" title="一 JWT认证"></a>一 JWT认证</h1><h2 id="1-1-工作原理"><a href="#1-1-工作原理" class="headerlink" title="1.1 工作原理"></a>1.1 工作原理</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">1) jwt = base64(头部).base(载荷).hash256(base64(头部).base(载荷).密钥)</span></span><br><span class="line"><span class="string">2) base64是可逆的算法、hash256是不可逆的算法</span></span><br><span class="line"><span class="string">3) 密钥是固定的字符串，保存在服务器</span></span><br><span class="line"><span class="string">"""</span></span><br></pre></td></tr></table></figure><h2 id="1-2-drf-jwt"><a href="#1-2-drf-jwt" class="headerlink" title="1.2 drf-jwt"></a>1.2 drf-jwt</h2><h5 id="官网"><a href="#官网" class="headerlink" title="官网"></a>官网</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://getblimp.github.io/django-rest-framework-jwt/</span><br></pre></td></tr></table></figure><h5 id="安装子：虚拟环境"><a href="#安装子：虚拟环境" class="headerlink" title="安装子：虚拟环境"></a>安装子：虚拟环境</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install djangorestframework-jwt</span><br></pre></td></tr></table></figure><h5 id="使用：user-urls-py"><a href="#使用：user-urls-py" class="headerlink" title="使用：user/urls.py"></a>使用：user/urls.py</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.urls <span class="keyword">import</span> path</span><br><span class="line"><span class="keyword">from</span> rest_framework_jwt.views <span class="keyword">import</span> obtain_jwt_token</span><br><span class="line">urlpatterns = [</span><br><span class="line">    path(<span class="string">'login/'</span>, obtain_jwt_token),</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h5 id="测试接口：post请求"><a href="#测试接口：post请求" class="headerlink" title="测试接口：post请求"></a>测试接口：post请求</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">postman发生post请求</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">接口：http://api.luffy.cn:8000/user/login/</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">数据：</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">"username":"admin",</span></span><br><span class="line"><span class="string">"password":"admin"</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">"""</span></span><br></pre></td></tr></table></figure><h2 id="1-3-drf-jwt开发"><a href="#1-3-drf-jwt开发" class="headerlink" title="1.3 drf-jwt开发"></a>1.3 drf-jwt开发</h2><h5 id="配置信息：JWT-AUTH到dev-py中"><a href="#配置信息：JWT-AUTH到dev-py中" class="headerlink" title="配置信息：JWT_AUTH到dev.py中"></a>配置信息：JWT_AUTH到dev.py中</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> datetime</span><br><span class="line">JWT_AUTH = &#123;</span><br><span class="line">    <span class="comment"># 过期时间</span></span><br><span class="line">    <span class="string">'JWT_EXPIRATION_DELTA'</span>: datetime.timedelta(days=<span class="number">1</span>),</span><br><span class="line">    <span class="comment"># 自定义认证结果：见下方序列化user和自定义response</span></span><br><span class="line">    <span class="string">'JWT_RESPONSE_PAYLOAD_HANDLER'</span>: <span class="string">'user.utils.jwt_response_payload_handler'</span>,  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="序列化user：user-serializers-py-自己创建"><a href="#序列化user：user-serializers-py-自己创建" class="headerlink" title="序列化user：user/serializers.py(自己创建)"></a>序列化user：user/serializers.py(自己创建)</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> rest_framework <span class="keyword">import</span> serializers</span><br><span class="line"><span class="keyword">from</span> . <span class="keyword">import</span> models</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserModelSerializers</span><span class="params">(serializers.ModelSerializer)</span>:</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Meta</span>:</span></span><br><span class="line">        model = models.User</span><br><span class="line">        fields = [<span class="string">'username'</span>]</span><br></pre></td></tr></table></figure><h5 id="自定义response：user-utils-py"><a href="#自定义response：user-utils-py" class="headerlink" title="自定义response：user/utils.py"></a>自定义response：user/utils.py</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> .serializers <span class="keyword">import</span> UserModelSerializers</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">jwt_response_payload_handler</span><span class="params">(token, user=None, request=None)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="string">'status'</span>: <span class="number">0</span>,</span><br><span class="line">        <span class="string">'msg'</span>: <span class="string">'ok'</span>,</span><br><span class="line">        <span class="string">'data'</span>: &#123;</span><br><span class="line">            <span class="string">'token'</span>: token,</span><br><span class="line">            <span class="string">'user'</span>: UserModelSerializers(user).data</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h5 id="基于drf-jwt的全局认证：user-authentications-py-自己创建"><a href="#基于drf-jwt的全局认证：user-authentications-py-自己创建" class="headerlink" title="基于drf-jwt的全局认证：user/authentications.py(自己创建)"></a>基于drf-jwt的全局认证：user/authentications.py(自己创建)</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> jwt</span><br><span class="line"><span class="keyword">from</span> rest_framework.exceptions <span class="keyword">import</span> AuthenticationFailed</span><br><span class="line"><span class="keyword">from</span> rest_framework_jwt.authentication <span class="keyword">import</span> jwt_decode_handler</span><br><span class="line"><span class="keyword">from</span> rest_framework_jwt.authentication <span class="keyword">import</span> get_authorization_header</span><br><span class="line"><span class="keyword">from</span> rest_framework_jwt.authentication <span class="keyword">import</span> BaseJSONWebTokenAuthentication</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">JSONWebTokenAuthentication</span><span class="params">(BaseJSONWebTokenAuthentication)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">authenticate</span><span class="params">(self, request)</span>:</span></span><br><span class="line">        jwt_value = get_authorization_header(request)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> jwt_value:</span><br><span class="line">            <span class="keyword">raise</span> AuthenticationFailed(<span class="string">'Authorization 字段是必须的'</span>)</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            payload = jwt_decode_handler(jwt_value)</span><br><span class="line">        <span class="keyword">except</span> jwt.ExpiredSignature:</span><br><span class="line">            <span class="keyword">raise</span> AuthenticationFailed(<span class="string">'签名过期'</span>)</span><br><span class="line">        <span class="keyword">except</span> jwt.InvalidTokenError:</span><br><span class="line">            <span class="keyword">raise</span> AuthenticationFailed(<span class="string">'非法用户'</span>)</span><br><span class="line">        user = self.authenticate_credentials(payload)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> user, jwt_value</span><br></pre></td></tr></table></figure><h5 id="全局启用：settings-dev-py"><a href="#全局启用：settings-dev-py" class="headerlink" title="全局启用：settings/dev.py"></a>全局启用：settings/dev.py</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">REST_FRAMEWORK = &#123;</span><br><span class="line">    <span class="comment"># 认证模块</span></span><br><span class="line">    <span class="string">'DEFAULT_AUTHENTICATION_CLASSES'</span>: (</span><br><span class="line">        <span class="string">'user.authentications.JSONWebTokenAuthentication'</span>,</span><br><span class="line">    ),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="局部启用禁用：任何一个cbv类首行"><a href="#局部启用禁用：任何一个cbv类首行" class="headerlink" title="局部启用禁用：任何一个cbv类首行"></a>局部启用禁用：任何一个cbv类首行</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 局部禁用</span></span><br><span class="line">authentication_classes = []</span><br><span class="line"></span><br><span class="line"><span class="comment"># 局部启用</span></span><br><span class="line"><span class="keyword">from</span> user.authentications <span class="keyword">import</span> JSONWebTokenAuthentication</span><br><span class="line">authentication_classes = [JSONWebTokenAuthentication]</span><br></pre></td></tr></table></figure><h5 id="多方式登录：user-utils-py"><a href="#多方式登录：user-utils-py" class="headerlink" title="多方式登录：user/utils.py"></a>多方式登录：user/utils.py</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">from</span> .models <span class="keyword">import</span> User</span><br><span class="line"><span class="keyword">from</span> django.contrib.auth.backends <span class="keyword">import</span> ModelBackend</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">JWTModelBackend</span><span class="params">(ModelBackend)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">authenticate</span><span class="params">(self, request, username=None, password=None, **kwargs)</span>:</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="keyword">if</span> re.match(<span class="string">r'^1[3-9]\d&#123;9&#125;$'</span>, username):</span><br><span class="line">                user = User.objects.get(mobile=username)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                user = User.objects.get(username=username)</span><br><span class="line">        <span class="keyword">except</span> User.DoesNotExist:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        <span class="keyword">if</span> user.check_password(password) <span class="keyword">and</span> self.user_can_authenticate(user):</span><br><span class="line">            <span class="keyword">return</span> user</span><br></pre></td></tr></table></figure><h5 id="配置多方式登录：settings-dev-py"><a href="#配置多方式登录：settings-dev-py" class="headerlink" title="配置多方式登录：settings/dev.py"></a>配置多方式登录：settings/dev.py</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AUTHENTICATION_BACKENDS = [<span class="string">'user.utils.JWTModelBackend'</span>]</span><br></pre></td></tr></table></figure><h5 id="手动签发JWT：了解-可以拥有原生登录基于Model类user对象签发JWT"><a href="#手动签发JWT：了解-可以拥有原生登录基于Model类user对象签发JWT" class="headerlink" title="手动签发JWT：了解 - 可以拥有原生登录基于Model类user对象签发JWT"></a>手动签发JWT：了解 - 可以拥有原生登录基于Model类user对象签发JWT</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> rest_framework_jwt.settings <span class="keyword">import</span> api_settings</span><br><span class="line"></span><br><span class="line">jwt_payload_handler = api_settings.JWT_PAYLOAD_HANDLER</span><br><span class="line">jwt_encode_handler = api_settings.JWT_ENCODE_HANDLER</span><br><span class="line"></span><br><span class="line">payload = jwt_payload_handler(user)</span><br><span class="line">token = jwt_encode_handler(payload)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;一-JWT认证&quot;&gt;&lt;a href=&quot;#一-JWT认证&quot; class=&quot;headerlink&quot; title=&quot;一 JWT认证&quot;&gt;&lt;/a&gt;一 JWT认证&lt;/h1&gt;&lt;h2 id=&quot;1-1-工作原理&quot;&gt;&lt;a href=&quot;#1-1-工作原理&quot; class=&quot;headerli
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>8-drf-自动生成接口文档</title>
    <link href="http://yoursite.com/2018/05/27/8-drf-%E8%87%AA%E5%8A%A8%E7%94%9F%E6%88%90%E6%8E%A5%E5%8F%A3%E6%96%87%E6%A1%A3/"/>
    <id>http://yoursite.com/2018/05/27/8-drf-%E8%87%AA%E5%8A%A8%E7%94%9F%E6%88%90%E6%8E%A5%E5%8F%A3%E6%96%87%E6%A1%A3/</id>
    <published>2018-05-27T11:33:20.000Z</published>
    <updated>2020-07-14T00:39:54.310Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一-自动生成接口文档"><a href="#一-自动生成接口文档" class="headerlink" title="一 自动生成接口文档"></a>一 自动生成接口文档</h1><p>REST framework可以自动帮助我们生成接口文档。</p><p>接口文档以网页的方式呈现。</p><p>自动接口文档能生成的是继承自<code>APIView</code>及其子类的视图。</p><h2 id="1-1-安装依赖"><a href="#1-1-安装依赖" class="headerlink" title="1.1. 安装依赖"></a>1.1. 安装依赖</h2><p>REST framewrok生成接口文档需要<code>coreapi</code>库的支持。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install coreapi</span><br></pre></td></tr></table></figure><h2 id="1-2-设置接口文档访问路径"><a href="#1-2-设置接口文档访问路径" class="headerlink" title="1.2. 设置接口文档访问路径"></a>1.2. 设置接口文档访问路径</h2><p>在总路由中添加接口文档路径。</p><p>文档路由对应的视图配置为<code>rest_framework.documentation.include_docs_urls</code>，</p><p>参数<code>title</code>为接口文档网站的标题。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> rest_framework.documentation <span class="keyword">import</span> include_docs_urls</span><br><span class="line"></span><br><span class="line">urlpatterns = [</span><br><span class="line">    ...</span><br><span class="line">    path(<span class="string">'docs/'</span>, include_docs_urls(title=<span class="string">'站点页面标题'</span>))</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h2 id="1-3-文档描述说明的定义位置"><a href="#1-3-文档描述说明的定义位置" class="headerlink" title="1.3. 文档描述说明的定义位置"></a>1.3. 文档描述说明的定义位置</h2><p>1） 单一方法的视图，可直接使用类视图的文档字符串，如</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BookListView</span><span class="params">(generics.ListAPIView)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    返回所有图书信息.</span></span><br><span class="line"><span class="string">    """</span></span><br></pre></td></tr></table></figure><p>2）包含多个方法的视图，在类视图的文档字符串中，分开方法定义，如</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BookListCreateView</span><span class="params">(generics.ListCreateAPIView)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    get:</span></span><br><span class="line"><span class="string">    返回所有图书信息.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    post:</span></span><br><span class="line"><span class="string">    新建图书.</span></span><br><span class="line"><span class="string">    """</span></span><br></pre></td></tr></table></figure><p>3）对于视图集ViewSet，仍在类视图的文档字符串中封开定义，但是应使用action名称区分，如</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BookInfoViewSet</span><span class="params">(mixins.ListModelMixin, mixins.RetrieveModelMixin, GenericViewSet)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    list:</span></span><br><span class="line"><span class="string">    返回图书列表数据</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    retrieve:</span></span><br><span class="line"><span class="string">    返回图书详情数据</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    latest:</span></span><br><span class="line"><span class="string">    返回最新的图书数据</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    read:</span></span><br><span class="line"><span class="string">    修改图书的阅读量</span></span><br><span class="line"><span class="string">    """</span></span><br></pre></td></tr></table></figure><h2 id="1-4-访问接口文档网页"><a href="#1-4-访问接口文档网页" class="headerlink" title="1.4. 访问接口文档网页"></a>1.4. 访问接口文档网页</h2><p>浏览器访问 127.0.0.1:8000/docs/，即可看到自动生成的接口文档。</p><p><img src= "/img/loading.gif" data-src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ggghbdeu1pj31is0u013r.jpg" alt="æ¥å£ææ¡£ç½é¡µ"></p><h4 id="两点说明："><a href="#两点说明：" class="headerlink" title="两点说明："></a>两点说明：</h4><p>1） 视图集ViewSet中的retrieve名称，在接口文档网站中叫做read</p><p>2）参数的Description需要在模型类或序列化器类的字段中以help_text选项定义，如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span><span class="params">(models.Model)</span>:</span></span><br><span class="line">    ...</span><br><span class="line">    age = models.IntegerField(default=<span class="number">0</span>, verbose_name=<span class="string">'年龄'</span>, help_text=<span class="string">'年龄'</span>)</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure><p>或</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StudentSerializer</span><span class="params">(serializers.ModelSerializer)</span>:</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Meta</span>:</span></span><br><span class="line">        model = Student</span><br><span class="line">        fields = <span class="string">"__all__"</span></span><br><span class="line">        extra_kwargs = &#123;</span><br><span class="line">            <span class="string">'age'</span>: &#123;</span><br><span class="line">                <span class="string">'required'</span>: <span class="literal">True</span>,</span><br><span class="line">                <span class="string">'help_text'</span>: <span class="string">'年龄'</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;一-自动生成接口文档&quot;&gt;&lt;a href=&quot;#一-自动生成接口文档&quot; class=&quot;headerlink&quot; title=&quot;一 自动生成接口文档&quot;&gt;&lt;/a&gt;一 自动生成接口文档&lt;/h1&gt;&lt;p&gt;REST framework可以自动帮助我们生成接口文档。&lt;/p&gt;
&lt;p&gt;接
      
    
    </summary>
    
    
    
  </entry>
  
</feed>
